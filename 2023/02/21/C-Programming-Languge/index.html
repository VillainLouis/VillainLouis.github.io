

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="V. Louis">
  <meta name="keywords" content="">
  
    <meta name="description" content="The C++ Programming Language  Part Ⅰ: Introductory MaterialChapter 2. A Tour of C++: The Basics Introduction The Basics Hello, World! Types, Variables, and Arithmetic Constants Tests and Loops Pointer">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Programming Languge">
<meta property="og:url" content="http://example.com/2023/02/21/C-Programming-Languge/index.html">
<meta property="og:site_name" content="V. Louis">
<meta property="og:description" content="The C++ Programming Language  Part Ⅰ: Introductory MaterialChapter 2. A Tour of C++: The Basics Introduction The Basics Hello, World! Types, Variables, and Arithmetic Constants Tests and Loops Pointer">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230129151158655-1674976322141-1.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230129151354561.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230117171611635.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230117175706348.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230201162759965-1675240087761-1.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230213150314314.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230124202038535.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230117195603731.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230129145841357.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230129221203091.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230203201357089.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230204162048178.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230204203640537.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230205142817901.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206131551001.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206140620903.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206155452129.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206160024996.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206160253304.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206160538008.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206161206795.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206183745502.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206191643810.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206202030043.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206202926635.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206203844744.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206205536969.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206212239272.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230206230214511.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230207120637785.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230207121023689.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230207123714467.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230207151825566-1675754306748-1.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230207161057433.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230207185954370.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230209164220571.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230209164405259.png">
<meta property="og:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230213144019458.png">
<meta property="article:published_time" content="2023-02-21T05:05:47.000Z">
<meta property="article:modified_time" content="2023-02-21T05:09:13.288Z">
<meta property="article:author" content="V. Louis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/02/21/C-Programming-Languge/image-20230129151158655-1674976322141-1.png">
  
  
  
  <title>C++ Programming Languge - V. Louis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Villian Louis&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ Programming Languge"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-21 13:05" pubdate>
          February 21, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          403k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          3359 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++ Programming Languge</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="The-C-Programming-Language-Part-Ⅰ-Introductory-Material"><a href="#The-C-Programming-Language-Part-Ⅰ-Introductory-Material" class="headerlink" title="The C++ Programming Language  Part Ⅰ: Introductory Material"></a><em>The C++ Programming Language</em>  Part Ⅰ: Introductory Material</h1><h2 id="Chapter-2-A-Tour-of-C-The-Basics"><a href="#Chapter-2-A-Tour-of-C-The-Basics" class="headerlink" title="Chapter 2. A Tour of C++: The Basics"></a>Chapter 2. A Tour of C++: The Basics</h2><ul>
<li>Introduction</li>
<li>The Basics<ul>
<li>Hello, World!</li>
<li>Types, Variables, and Arithmetic</li>
<li>Constants</li>
<li>Tests and Loops</li>
<li>Pointers, Arrays, and Loops</li>
</ul>
</li>
<li>User-Defined Types<ul>
<li>Structures</li>
<li>Classes</li>
<li>Enumerations</li>
</ul>
</li>
<li>Modularity<ul>
<li>Separate Compilation</li>
<li>Namespaces</li>
<li>Error Handling</li>
</ul>
</li>
<li>Postcript</li>
<li>Advice</li>
</ul>
<h3 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h3><ul>
<li><p>2，3，4，5章主要是”give you an idea of what C++ is”</p>
<ul>
<li>Chapter 2给出<ul>
<li>notion of C++</li>
<li>C++‘s model of memory</li>
<li>computation</li>
<li>the basic mechanism for organizing code into program</li>
</ul>
</li>
<li>Chapter 3介绍C++’s Abstraction mechanism</li>
<li>Chapter 4 和 Chapter 5 给出一些Standard-library facilities的例子</li>
</ul>
</li>
<li><p>严格的自底向上的方式介绍C++</p>
</li>
<li><p>This tour present C++ as an integrated whole.</p>
</li>
</ul>
<h3 id="2-2-The-Basics"><a href="#2-2-The-Basics" class="headerlink" title="2.2 The Basics"></a>2.2 The Basics</h3><ol>
<li><p>C++ is a compiled language.</p>
<ul>
<li>Source text必须由 compiler处理，产生object files。然后object files 被linker combined，产生executable program</li>
<li><img src="image-20230129151158655-1674976322141-1.png" srcset="/img/loading.gif" lazyload alt="image-20230129151158655"></li>
</ul>
</li>
<li><p>An executable program is created for a specific hardware/system combination; it is not portable.</p>
<ul>
<li>When talk about portability of C++ programs, we usually mean portability of source code; that is the source code can be successfully compiled and run on a varity of systems.</li>
</ul>
</li>
<li><p>ISO C++ Standard defines two kinds of entities:</p>
<ul>
<li>Core language features.<ul>
<li>Such as built-in types (e.g. char and int) and loops (e.g. for-statements and while-statements)</li>
</ul>
</li>
<li>Standard-library components.<ul>
<li>Such as containers (e.g. vector and map) and I/O operations (e.g. &lt;&lt; and getline())</li>
<li>The standard-library components are perfectly ordinary C++ code provided by every C++ implementation. This implies that C++ is sufficiently expressive and efficient for the most demanding systems programming tasks.</li>
</ul>
</li>
</ul>
</li>
<li><p>C++ is a statically typed language.</p>
<ul>
<li>That is, the type of every entity (e.g., object, value, name, and expression) must be known to the compiler at its point of use.</li>
<li>The type of an object determines the set of operations applicable to it.</li>
</ul>
</li>
</ol>
<h4 id="2-2-1-Hello-World"><a href="#2-2-1-Hello-World" class="headerlink" title="2.2.1 Hello, World!"></a>2.2.1 Hello, World!</h4><ol start="5">
<li>The minimal C++ program is<ul>
<li>定义main函数</li>
<li>没有任何参数</li>
<li>什么都不做</li>
<li>Curly braces, {}, expressing grouping in C++.</li>
<li>// 单行注释</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// the minimal C++ program</span><br></code></pre></td></tr></table></figure>

<ol start="6">
<li><p>Every C++ program must have exactly one global function named main().</p>
<ul>
<li>The program starts by executing that function.</li>
<li>The int value returned by main(), if any, is the program’s return value to “the system.”<ul>
<li>If no value is return, the system will receive a value indicating successful compilation.</li>
<li>A nonzero value from main() indicates failure.</li>
<li>Not every operating system and execution envirnment make use of that return value:<ul>
<li>Linux/Unix-based environments often do</li>
<li>But Windows-based environments rarely do.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Typically, a program produces some output.</p>
<ul>
<li>The line <code>#include &lt;iostream&gt;</code>  instructs the compiler to include the declarations of standard stream I/O facilities as found in iostream.</li>
<li>The operaor <code>&lt;&lt;</code> (“put to”) writes its second argument on its first.<ul>
<li>The string literal “Hello, World!\n” is written onto the standard output stream <code>std::cout</code>.</li>
<li>A string literal is a sequence of characters surrounded by double quotes.<ul>
<li>In a string literal, the backslash character <code>\</code> followed by another character denotes a single ‘‘special character.’’</li>
<li>In this case, <code>\n</code> is the newline character, so that the characters written are Hello, World! followed by a newline.</li>
</ul>
</li>
</ul>
</li>
<li>The <code>std::</code> specifies that the name <code>cout</code> is to be found in the standard-library namespace.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="8">
<li>Essentially all executable code is placed in functions and called directly or indirectly from <code>main()</code>.<ul>
<li>A “return type” <code>void</code> indicates that a function does not return a value.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">// make names from std visible without std::</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> x*x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;The square of &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">square</span>(x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">print_square</span>(<span class="hljs-number">1.234</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-2-Types-Variables-and-Arithmetic"><a href="#2-2-2-Types-Variables-and-Arithmetic" class="headerlink" title="2.2.2 Types, Variables, and Arithmetic"></a>2.2.2 Types, Variables, and Arithmetic</h4><ol start="9">
<li>Every name and every expression has a type that determines the operations that may be performed on it.<ul>
<li>A declaration is a statement that introduces a name into the program. It specifies a type for the named entity.<ul>
<li>A <em>type</em> defines a set of possible values and set of operations (for an object).</li>
<li>An <em>object</em> is some memory that holds a value of some type.</li>
<li>A <em>value</em> is a set of bits interpreted according to a type.</li>
<li>A <em>variable</em> is a named object.</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> inch <span class="hljs-comment">// the declaration specifies that inch is of the type int</span><br></code></pre></td></tr></table></figure>

<ol start="10">
<li><p>C++ offers a variety of fundamental types.</p>
<ul>
<li><code>bool</code>: true or false</li>
<li><code>char</code>: character</li>
<li><code>int</code>: integer</li>
<li><code>double</code>: double-precision floating-point number</li>
</ul>
</li>
<li><p>Each fundamental type corresponds directly to hardware facilities and has a fixed size that determines the range of values that can be stored in it.</p>
<ul>
<li><img src="image-20230129151354561.png" srcset="/img/loading.gif" lazyload alt="image-20230129151354561"></li>
<li>A <code>char</code> variable is of the natural size to hold a character on a given machine (typically an 8-bit byte).</li>
<li>The sizes of other types are quoted in multiples of the size of a char.</li>
<li>The size of a type is implementation-defined and can be obtained by the <code>sizeof</code> operator.</li>
</ul>
</li>
<li><p>The arithmetic operator can be used for appropriate combination of these types.</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">x+y <span class="hljs-comment">// plus</span><br>+x <span class="hljs-comment">// unary plus</span><br>x-y <span class="hljs-comment">//minus</span><br>-x <span class="hljs-comment">//unary minus</span><br>x*y <span class="hljs-comment">//multiply</span><br>x/y <span class="hljs-comment">//divide</span><br>x%y <span class="hljs-comment">// remainder (modulus) for integers</span><br></code></pre></td></tr></table></figure>

<p>So can the comparision operators.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">x==y <span class="hljs-comment">// equal</span><br>x!=y <span class="hljs-comment">// not equal</span><br>x&lt;y <span class="hljs-comment">// less than</span><br>x&gt;y <span class="hljs-comment">// greater than</span><br>x&lt;=y <span class="hljs-comment">// less than or equal</span><br>x&gt;=y <span class="hljs-comment">// greater than or equal</span><br></code></pre></td></tr></table></figure>

<ol start="13">
<li>In assignments and in arithmetic operations, C++ performs all meaningful conversions between the basic types so that they can be mixed freely.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">()</span> <span class="hljs-comment">// function that does not return a value</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">double</span> d = <span class="hljs-number">2.2</span>; <span class="hljs-comment">// initializa floating-point number</span><br>	<span class="hljs-type">int</span> i = <span class="hljs-number">7</span>; <span class="hljs-comment">// initialize integer</span><br>	d = d+i; <span class="hljs-comment">// assign sum of d+i to d</span><br>	i = d*i; <span class="hljs-comment">// assing product to i (truncating the double d*i to an int)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Note that <code>=</code> is the assignment operator and <code>==</code> test equality.</p>
<ol start="14">
<li>C++ offers a variety of notations for expressing initialization.<ul>
<li>the <code>=</code> used above</li>
<li>a universal form based on <code>curly-brace-delimited initializer lists</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">double</span> d1 = <span class="hljs-number">2.3</span>;<br><span class="hljs-type">double</span> d2&#123;<span class="hljs-number">2.3</span>&#125;;<br><br>complex&lt;<span class="hljs-type">double</span>&gt; z = <span class="hljs-number">1</span>; <span class="hljs-comment">// a complex number with double-precision floating-point scalars</span><br>complex&lt;<span class="hljs-type">double</span>&gt; z2&#123;d1,d2&#125;<br>complex&lt;<span class="hljs-type">double</span>&gt; z3 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// the = is optional with &#123;...&#125;</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// a vector of ints</span><br></code></pre></td></tr></table></figure>

<p>The <code>=</code> form is traditional and dates back to C, but if in doubt, use the general {}-list form. If nothing else, it saves you from conversions that lose information (narrowing conversion).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i1 = <span class="hljs-number">7.2</span>; <span class="hljs-comment">// i1 becomes 7</span><br><span class="hljs-type">int</span> i2&#123;<span class="hljs-number">7.2</span>&#125;; <span class="hljs-comment">// error: floating-point to integer conversion (narrowing conversion)</span><br><span class="hljs-type">int</span> i3 = &#123;<span class="hljs-number">7.2</span>&#125;; <span class="hljs-comment">// error: floating-point to integer conversion (the = is redundant)</span><br></code></pre></td></tr></table></figure>

<ol start="15">
<li>A constant cannot be left uninitialized and a variable should only be left uninitialized in extremely rare circumstances.<ul>
<li>Don’t introduce a name untial you have a suitable value for it.</li>
<li>User-defined types (such as string, vector, Matrix, Motor_controller, and Orc_warrior) can be definec to be implicitly initialized.</li>
</ul>
</li>
<li>When defining a variable, you don;t actually need to state its type explicitly when it can be deduced from the initializer.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> b = <span class="hljs-literal">true</span>; <span class="hljs-comment">// a bool</span><br><span class="hljs-keyword">auto</span> ch = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">// a char</span><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">123</span>; <span class="hljs-comment">// an int</span><br><span class="hljs-keyword">auto</span> d = <span class="hljs-number">1.2</span>; <span class="hljs-comment">// a double</span><br><span class="hljs-keyword">auto</span> z = <span class="hljs-built_in">sqrt</span>(y); <span class="hljs-comment">// z has the type of whatever sqrt(y) returns</span><br></code></pre></td></tr></table></figure>

<p>With <code>auto</code>, we use the <code>=</code> syntax because there is no type conversion involved that might cause problems.</p>
<ol start="17">
<li>We use <code>auto</code> where we don’t have a specific reason to mention the type explicitly. “Specific reasons” include:<ul>
<li>The definition is in a large scope where we want to make the type clearly visible to readers of our code.</li>
<li>We want to be explicit about a variable’s range or precision (e.g., double rather than float).</li>
</ul>
</li>
</ol>
<p>Using auto, we avoid redundancy and writing long type names.</p>
<ol start="18">
<li>In addition to the conventional arithmetic and logical operators, C++ offers more specific operations for modifying a variable.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">x+=y; <span class="hljs-comment">// x = x+y</span><br>++x; <span class="hljs-comment">// increment: x = x+1</span><br>x-=y; <span class="hljs-comment">// x = x-y</span><br>--x; <span class="hljs-comment">// decrement: x = x-1</span><br>x*=y; <span class="hljs-comment">// scaling: x = x*y</span><br>x/=y; <span class="hljs-comment">// scaling: x = x/y</span><br>x%=y; <span class="hljs-comment">// x = x%y</span><br></code></pre></td></tr></table></figure>

<p>Thes operators are concise, convenient, and very frequently used.</p>
<h4 id="2-2-3-Constants"><a href="#2-2-3-Constants" class="headerlink" title="2.2.3 Constants"></a>2.2.3 Constants</h4><ol start="19">
<li>C++ supports two notions of immutability.<ul>
<li><code>const</code>: meaning roughly “I promise not to change this value”.<ul>
<li>This is used primarily to specify interfaces, so that data can be passed to functions without fear of it being modified.</li>
<li>The compiler enforces the promise made by <code>const</code>.</li>
</ul>
</li>
<li><code>constexpr</code>: meaning roughly “to be evaluated at compile time”.<ul>
<li>This is used primarily to specify constants, to allow placement of data in memory where it is unlikely to be corrupted, and for performance.</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> dmv = <span class="hljs-number">17</span>; <span class="hljs-comment">// dmv is named constant</span><br><span class="hljs-type">int</span> var = <span class="hljs-number">17</span>; <span class="hljs-comment">// var is a variable, not a constant</span><br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> max1 = <span class="hljs-number">1.4</span>*<span class="hljs-built_in">square</span>(dmv); <span class="hljs-comment">// OK if square(17) is a constant expression</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> max2 = <span class="hljs-number">1.4</span>*<span class="hljs-built_in">square</span>(var); <span class="hljs-comment">// Error: var is not a constant expression(Cannot be know when compiling.)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> max3 = <span class="hljs-number">1.4</span>*<span class="hljs-built_in">square</span>(var); <span class="hljs-comment">// Ok: may be evaluated at run time</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">double</span>&gt;&amp;)</span></span>; <span class="hljs-comment">// Function sum() will bot modify its argument</span><br><br>vector&lt;<span class="hljs-type">double</span>&gt; v&#123;<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">4.5</span>&#125;; <span class="hljs-comment">// v is not a constant</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> s1 = <span class="hljs-built_in">sum</span>(v); <span class="hljs-comment">// Ok: evaluted at run time</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> s2 = <span class="hljs-built_in">sum</span>(v); <span class="hljs-comment">// Error: sum(v) not constant expression</span><br></code></pre></td></tr></table></figure>

<ul>
<li><img src="image-20230117171611635.png" srcset="/img/loading.gif" lazyload alt="image-20230117171611635"></li>
</ul>
<ol start="20">
<li>For a function to be usable in a <code>constant expression</code>, that is, in an expression that will be evaluated by the compiler, it must be defined <code>constexpr</code>.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x*x;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>To be <code>constexpr</code>, a function must be rather simple: just a return-statement computing a value.</li>
<li>A <code>constexpr</code> function can be used for non-constant arguments, but when that is done the result is not a constant expression.<ul>
<li>We allow a <code>constexpr</code> function to be called with non-constant-expression arguments in the contexts that do not require constant expression, so that we don’t have to define essentially the same function twice: once for constant expression and once for variables.</li>
</ul>
</li>
</ul>
<ol start="21">
<li>In a few places, constant expressions are required by language rules(e.g., array bounds, case labels, some template arguments, and constants declared using <code>constexpr</code>). In other cases, compile-time evaluation is important for performance.</li>
</ol>
<ul>
<li>Independently of performance issues, the notion of immutability (of an object with an unchangable state) is an important design concern.</li>
</ul>
<h4 id="2-2-4-Tests-and-Loops"><a href="#2-2-4-Tests-and-Loops" class="headerlink" title="2.2.4 Tests and Loops"></a>2.2.4 Tests and Loops</h4><ol start="22">
<li>C++ provides a conventional set of statements for expressing selection and looping.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept</span><span class="hljs-params">()</span> <span class="hljs-comment">// a simple function that prompts the user and returns a Boolean indicating the response</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Do you want to proceed (y or n)?\n&quot;</span>;<br>  <br>    <span class="hljs-type">char</span> answer = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; answer;<br>  <br>    <span class="hljs-keyword">if</span>(answer==<span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>&gt;&gt;</code> operator (“get from”) is used for input; <code>cin</code> is the standard input stream.<ul>
<li>The type of the right-hand operand of <code>&gt;&gt;</code> determines what input is accepted, and its right-hand operand is the target of the input operation.</li>
</ul>
</li>
</ul>
<ol start="23">
<li>A <code>switch</code>-statement tests a value against a set of constants.<ul>
<li>The case constants must be distinct.</li>
<li>If the value tested does not match any of them, the <code>default</code> is chosen. If no <code>default</code> is provided, no action is taken if the value doesn’t match any case constant.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept2</span><span class="hljs-params">()</span> <span class="hljs-comment">// a simple function that prompts the user and returns a Boolean indicating the response</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Do you want to proceed (y or n)?\n&quot;</span>;<br>  <br>    <span class="hljs-type">char</span> answer = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; answer;<br>  <br>    <span class="hljs-keyword">switch</span>(answer)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;y&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      	<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>n<span class="hljs-number">&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;ll take that for a no.\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="24">
<li>Few programs are written without loops.<ul>
<li>The <code>while</code>-statement executes until its condition becomes <code>false</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept3</span><span class="hljs-params">()</span> <span class="hljs-comment">// a simple function that prompts the user and returns a Boolean indicating the response</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tries = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(tries&lt;<span class="hljs-number">4</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Do you want to proceed (y or n)?\n&quot;</span>;<br><br>        <span class="hljs-type">char</span> answer = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; answer;<br><br>        <span class="hljs-keyword">switch</span>(answer)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;y&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>n<span class="hljs-number">&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">default</span>:<br>                cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;ll take that for a no.\n&quot;</span>;<br>                ++tries;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;ll take that for a no.\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-5-Pointers-Arrays-and-Loops"><a href="#2-2-5-Pointers-Arrays-and-Loops" class="headerlink" title="2.2.5 Pointers, Arrays, and Loops"></a>2.2.5 Pointers, Arrays, and Loops</h4><ol start="25">
<li>An array of elements of type <code>char</code> can be declared like this:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> v[<span class="hljs-number">6</span>]; <span class="hljs-comment">// array of 6 characters</span><br></code></pre></td></tr></table></figure>

<p>Sillarly, a pointer can be declared like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> *p; <span class="hljs-comment">// pointer to character</span><br></code></pre></td></tr></table></figure>

<ul>
<li>In declarations, <code>[]</code> means “array of” and <code>*</code> means “pointer to.”</li>
<li>All arrays have <code>0</code> as their lower bound. The size of an array must be a constant expression.</li>
<li>A pointer variable can hold the address of an object of the appropriate type:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> *p = &amp;v[<span class="hljs-number">3</span>]; <span class="hljs-comment">// p points to v&#x27;s fourth element</span><br><span class="hljs-type">char</span> x = *p; <span class="hljs-comment">// *p is the object that p points to</span><br></code></pre></td></tr></table></figure>

<ul>
<li>In an expression, prefix unary <code>*</code> means “contents of “ and prefix unary <code>&amp;</code> means “address of.”<ul>
<li>We can represent the result of that initialized definition graphically.</li>
<li><img src="image-20230117175706348.png" srcset="/img/loading.gif" lazyload alt="image-20230117175706348"></li>
</ul>
</li>
</ul>
<ol start="26">
<li>The <code>for</code>-statement can be read as “set <code>i</code> to zero; while <code>i</code> is not <code>10</code>, copy the <code>i</code>th element and increment <code>i</code>.”</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_fct</span><span class="hljs-params">()</span> <span class="hljs-comment">// copying ten elements from one array to another</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> v1[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> v2[<span class="hljs-number">10</span>]; <span class="hljs-comment">// to become a copy of v1</span><br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i=<span class="hljs-number">0</span>; i!=<span class="hljs-number">10</span>; ++i) <span class="hljs-comment">// copy elemets</span><br>        v2[i]=v1[i];<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>++</code> operator simply adds <code>1</code>.</li>
</ul>
<ol start="27">
<li>C++ also offers a simplier <code>for</code>-statement, called a range-<code>for</code>-statement, for loops that traverse a sequence in the simplest way.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : v) <span class="hljs-comment">// for each x in v</span><br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : &#123;<span class="hljs-number">10</span>,<span class="hljs-number">21</span>,<span class="hljs-number">32</span>,<span class="hljs-number">43</span>,<span class="hljs-number">54</span>,<span class="hljs-number">65</span>&#125;)<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The first range-<code>for</code>-statement can be read as “for every element of v, from the first to the last, place a copy in <code>x</code> and print it.”</li>
<li>Note that we don’t have to specify an array bound when we initialize it with a list.</li>
<li>The range-<code>for</code>-statement can be used for any sequence of elements.</li>
</ul>
<p>If we didn’t want to copy the values from <code>v</code> into the variable <code>x</code>, but rather just have <code>x</code> refer to an element, we could write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x : v)<br>        ++x;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>In a declaration, the unary suffix <code>&amp;</code> means “reference to.”<ul>
<li>A reference is similar to a pointer, execpt that you don’t need to use a prefix <code>*</code> to access the value referred to by the reference.</li>
<li>A referenc cannot be made to refer to a different object after its initialization.</li>
</ul>
</li>
</ul>
<h2 id="Chapter-3-A-Tour-of-C-Abstraction-mechanisms"><a href="#Chapter-3-A-Tour-of-C-Abstraction-mechanisms" class="headerlink" title="Chapter 3. A Tour of C++: Abstraction mechanisms"></a>Chapter 3. A Tour of C++: Abstraction mechanisms</h2><h3 id="3-2-Classes"><a href="#3-2-Classes" class="headerlink" title="3.2 Classes"></a>3.2 Classes</h3><h4 id="3-2-3-Virtual-Functions"><a href="#3-2-3-Virtual-Functions" class="headerlink" title="3.2.3 Virtual Functions"></a>3.2.3 Virtual Functions</h4><ol>
<li><p>A <code>Container</code> object must contain information to allow it select the right function to call at run time.</p>
<p>The usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions.</p>
<ul>
<li>That table is usually called the <em><strong>virtual function table</strong></em> or simply the <code>vtbl</code>.</li>
<li>Each class with virtual functions has its own <code>vtble</code> identifying its virtual functions.</li>
</ul>
</li>
</ol>
<ol start="2">
<li>The space overhead is one pointer in each object of a class with virtual functions plus one <code>vtbl</code> for each such class.</li>
</ol>
<h4 id="3-2-4-Class-Hierarchies"><a href="#3-2-4-Class-Hierarchies" class="headerlink" title="3.2.4 Class Hierarchies"></a>3.2.4 Class Hierarchies</h4><ol>
<li><p>A <em><strong>class hierarchies</strong></em> is a set of classes ordered in lattice created by derivation (e.g., <code>: public</code>)</p>
<p>We use class hierarchies to represent concepts that have hierarchies relationships, such as</p>
<ul>
<li>“A fire engine is a kind of a truck which is a kind of a vehicle” and</li>
<li>“A smiley face is a kind of a circle which is a kind of a shape.”</li>
</ul>
<p>Huge hierarchies, with hundreds of classes, that are both deep and wide are common.</p>
<p>As a semirealistic class example, let’s consider shapes on a screen:</p>
<ul>
<li><img src="image-20230201162759965-1675240087761-1.png" srcset="/img/loading.gif" lazyload alt="image-20230201162759965"></li>
</ul>
</li>
</ol>
<h3 id="3-4-Templates"><a href="#3-4-Templates" class="headerlink" title="3.4 Templates"></a>3.4 Templates</h3><h4 id="3-4-4-Variadic-Templates"><a href="#3-4-4-Variadic-Templates" class="headerlink" title="3.4.4 Variadic Templates"></a>3.4.4 Variadic Templates</h4><ol>
<li><p>A template can be defined to accept an arbitrary number of arguments of arbitrary types.</p>
<p>Such a template is called a <em><strong>variadic template</strong></em>. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Tail&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T head, Tail... tail)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">g</span>(head); <span class="hljs-comment">// do something to head</span><br>    <span class="hljs-built_in">f</span>(tail...); <span class="hljs-comment">// try again with tail</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">// do nothing</span><br></code></pre></td></tr></table></figure>

<p>The key to implementing a variadic template is to note that when you pass a list of arguments to it, you can separate the first argument from the rest.</p>
<ul>
<li>Here, we do something to the first argument (the <code>head</code>) and then recursively call <code>f()</code> with the rest of the arguments (the <code>tail</code>).</li>
<li>The <strong>elipsis</strong>, <code>...</code>, is used to indicate “the rest” of a list.</li>
<li>Eventually, of course, <code>tail</code> will become empty and we need a separate function to deal with that.</li>
</ul>
</li>
<li><p>We can call this <code>f()</code> like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;first:&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\nsecond:&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">0.2</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&quot;yuck!&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="Chapter-4-A-Tour-of-C-Containers-and-Algorithms"><a href="#Chapter-4-A-Tour-of-C-Containers-and-Algorithms" class="headerlink" title="Chapter 4. A Tour of C++: Containers and Algorithms"></a>Chapter 4. A Tour of C++: Containers and Algorithms</h2><h2 id="Chapter-5-A-Tour-of-C-Concurrency-and-Utilities"><a href="#Chapter-5-A-Tour-of-C-Concurrency-and-Utilities" class="headerlink" title="Chapter 5. A Tour of C++: Concurrency and Utilities"></a>Chapter 5. A Tour of C++: Concurrency and Utilities</h2><h4 id="5-2-1-unique-ptr-and-shared-ptr"><a href="#5-2-1-unique-ptr-and-shared-ptr" class="headerlink" title="5.2.1 unique_ptr and shared_ptr"></a>5.2.1 <code>unique_ptr</code> and <code>shared_ptr</code></h4><ol>
<li><p>The examples so far take care of objects defined in a scope, releasing the resources they acquire at the exit from the scope, but <strong>what about objects allocated on the free store?</strong> </p>
<p>In <code>&lt;memory&gt;</code>, the standard library provides two ‘‘smart pointers’’ to help manage objects on the free store:</p>
<ul>
<li><code>unique_ptr</code> to represent unique ownership (§34.3.1)</li>
<li><code>shared_ptr</code> to represent shared ownership (§34.3.2)</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>The most basic use of these ‘‘smart pointers’’ is to prevent memory leaks caused by careless programming.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-comment">// X* vs. unique_ptr&lt;X&gt;</span></span><br><span class="hljs-function"></span>&#123;<br>    X∗ p = <span class="hljs-keyword">new</span> X; <span class="hljs-comment">// allocate a new X</span><br>    unique_ptr&lt;X&gt; sp &#123;<span class="hljs-keyword">new</span> X&#125;; <span class="hljs-comment">// allocate a new X and give its pointer to unique_ptr</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">99</span>) <span class="hljs-keyword">throw</span> Z&#123;&#125;; <span class="hljs-comment">// may throw an exception</span><br>    <span class="hljs-keyword">if</span> (j&lt;<span class="hljs-number">77</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// may return &quot;early&quot;</span><br>    p−&gt;<span class="hljs-built_in">do_something</span>(); <span class="hljs-comment">// may throw an exception</span><br>    sp−&gt;<span class="hljs-built_in">do_something</span>(); <span class="hljs-comment">// may throw an exception</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// destroy *p</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Here, we ‘‘forgot’’ to delete <code>p</code> if <code>i&lt;99</code> or if <code>j&lt;77</code>. </li>
<li>On the other hand, <strong><code>unique_ptr</code> ensures that its object is properly destroyed whichever way we exit <code>f()</code> (by throwing an exception, by executing return, or by ‘‘falling off the end’’)</strong>. </li>
</ul>
</li>
<li><p>Ironically, we could have solved the problem simply by <strong>not</strong> using a pointer and <strong>not</strong> using <code>new</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-comment">// use a local var iable</span></span><br><span class="hljs-function"></span>&#123;<br>    X x;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Unfortunately, overuse of <code>new</code> (and of pointers and references) seems to be an increasing problem.</p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>However, when you really need the semantics of pointers, <code>unique_ptr</code> is a very lightweight mechanism with no space or time overhead compared to correct use of a built-in pointer. </p>
<p>Its further uses include passing free-store allocated objects in and out of functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;X&gt; <span class="hljs-title">make_X</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// make an X and immediately give it to a unique_ptr</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ... check i, etc. ...</span><br>    <span class="hljs-keyword">return</span> unique_ptr&lt;X&gt;&#123;<span class="hljs-keyword">new</span> X&#123;i&#125;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>A <code>unique_ptr</code> is a handle to an individual object (or an array) in much the same way that a <code>vector</code> is a handle to a sequence of objects.</strong> </p>
<ul>
<li>Both control the lifetime of other objects (using RAII) and <strong>both rely on move semantics</strong> to make return simple and efficient.</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>The <code>shared_ptr</code> is similar to <code>unique_ptr</code> except that <strong><code>shared_ptr</code>s are copied rather than moved</strong>.</p>
<p><strong>The <code>shared_ptr</code>s for an object share ownership of an object and that object is destroyed when the last of its <code>shared_ptr</code>s is destroyed</strong>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(shared_ptr&lt;fstream&gt;)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(shared_ptr&lt;fstream&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; name, ios_base::openmode mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;fstream&gt; fp &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">fstream</span>(name ,mode)&#125;;<br>    <span class="hljs-keyword">if</span> (!∗fp) <span class="hljs-keyword">throw</span> No_file&#123;&#125;; <span class="hljs-comment">// make sure the file was properly opened</span><br>    <br>    <span class="hljs-built_in">f</span>(fp);<br>    <span class="hljs-built_in">g</span>(fp);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Now, the file opened by <code>fp</code>’s constructor will be closed by the last function to (explicitly or implicitly) destroy a copy of <code>fp</code>. </li>
<li>Note that <code>f()</code> or g() may spawn a task holding a copy of <code>fp</code> or in some other way store a copy that outlives <code>user()</code>.</li>
</ul>
</li>
<li><p>Thus, <code>shared_ptr</code> provides a form of garbage collection that respects the destructor-based resource management of the memory-managed objects. </p>
</li>
<li><p>This is neither cost free nor exorbitantly expensive, but does make <strong>the lifetime of the shared object hard to predict</strong>.</p>
<ul>
<li><strong>Use <code>shared_ptr</code> only if you actually need shared ownership</strong>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>Given <code>unique_ptr</code> and <code>shared_ptr</code>, we can implement a complete ‘‘no naked new’’ policy (§3.2.1.2) for many programs.</p>
<p>However, these ‘‘smart pointers’’ are still conceptually pointers and therefore only my second choice for resource management – after containers and other types that manage their resources at a higher conceptual level. </p>
<p>In particular, <strong><code>shared_ptr</code>s do not in themselves provide any rules for which of their owners can read and/or write the shared object</strong>. </p>
<p><strong>Data races</strong> (§41.2.4) and other forms of confusion are not addressed simply by eliminating the resource management issues.</p>
</li>
</ol>
<ol start="6">
<li><p>Where do we use ‘‘smart pointers’’ (such as <code>unique_ptr</code>) rather than resource handles with operations designed specifically for the resource (such as <code>vector</code> or <code>thread</code>)? </p>
<p>Unsurprisingly, the answer is ‘‘when we need pointer semantics.’’</p>
<ul>
<li><strong>When we share an object</strong>, we need pointers (or references) to refer to the shared object, so a <strong><code>shared_ptr</code></strong> becomes the obvious choice (unless there is an obvious single owner).</li>
<li><strong>When we refer to a polymorphic object</strong>, we need a pointer (or a reference) because we don’t know the exact type of the object referred to or even its size), so a <strong><code>unique_ptr</code></strong> becomes the obvious choice.</li>
<li>A <strong>shared polymorphic object</strong> typically requires <code>shared_ptr</code>s.</li>
</ul>
</li>
</ol>
<ol start="7">
<li>We do not need to use a pointer to return a collection of objects from a function; a container that is a resource handle will do that simply and efficiently (§3.3.2).</li>
</ol>
<h3 id="5-3-Concurrency"><a href="#5-3-Concurrency" class="headerlink" title="5.3 Concurrency"></a>5.3 Concurrency</h3><h4 id="5-3-1-Tasks-and-threads"><a href="#5-3-1-Tasks-and-threads" class="headerlink" title="5.3.1 Tasks and threads"></a>5.3.1 Tasks and <code>thread</code>s</h4><h1 id="The-C-Programming-Language-Part-Ⅱ-Basic-Facilities"><a href="#The-C-Programming-Language-Part-Ⅱ-Basic-Facilities" class="headerlink" title="The C++ Programming Language  Part Ⅱ : Basic Facilities"></a>The C++ Programming Language  Part Ⅱ : Basic Facilities</h1><h2 id="Chapter-6-Types-and-Declarations"><a href="#Chapter-6-Types-and-Declarations" class="headerlink" title="Chapter 6. Types and Declarations"></a>Chapter 6. Types and Declarations</h2><ol>
<li><p>The standard header <code>&lt;cstddef&gt;</code> defines an alias that is very widely used in both standard-library declarations and user code:</p>
<ul>
<li><code>size_t</code> is an implementation-defined unsigned integer type that can hold the size in bytes of every object.</li>
</ul>
<p>Consequetly, it is used where we need to hold an object size. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, n)</span></span>; <span class="hljs-comment">// get n bytes</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-3-Declarations"><a href="#6-3-Declarations" class="headerlink" title="6.3 Declarations"></a>6.3 Declarations</h3><h4 id="6-3-4-Scope"><a href="#6-3-4-Scope" class="headerlink" title="6.3.4 Scope"></a>6.3.4 Scope</h4><ol>
<li><p>A declaration introduces a name into a scope; that is, a name can be used only in a part of the program text.</p>
<ul>
<li><p><em><strong>Local scope</strong></em>:</p>
<ul>
<li><p>A name declared in function (Chapter 12) or lambda (section 11.4) is called a <em><strong>local name</strong></em>.</p>
<p>Its scope extends from its point of declaration to the end of the block in which its declaration occurs.</p>
</li>
<li><p>A <em><strong>block</strong></em> is a section of code delimited by a <code>&#123;&#125;</code> pair.</p>
</li>
<li><p>Function and lambda parameter names are considered local names in the outmost block of their function or lambda.</p>
</li>
</ul>
</li>
<li><p><em><strong>Class scope</strong></em>:</p>
<ul>
<li><p>A name is called a <em><strong>member name</strong></em> (or a <em><strong>class member name</strong></em>) if it is defined in a class outside any function, class (Chapter 16), enum class (section 8.4.1), or other namespace.</p>
<p>Its scope extends from the opening <code>&#123;</code> of the class declaration to the end of the class declaration.</p>
</li>
</ul>
</li>
<li><p><em><strong>Namespace scope</strong></em>:</p>
<ul>
<li><p>A name is called a <em><strong>namespace member name</strong></em> if it is defined in a namespace (section 14.3.1) outside any function, lambda (section 11.4), class (Chapter 16), enum class (section 8.4.1), or other namespace.</p>
<p>Its scope extends from the point of declaration to the end of its namespace.</p>
</li>
<li><p>A namespace name may be also be accessible from other translation units (section 15.2).</p>
</li>
</ul>
</li>
<li><p><em><strong>Global scope</strong></em>:</p>
<ul>
<li><p>A name is called a <em><strong>global name</strong></em> if it is defined outside any function, class (Chapter  16), enum class (section 8.4.1), or namespace (section 14.3.1).</p>
<p>The scope of a global name extends from the point of declaration to the end of the file in which its declaration occurs.</p>
</li>
<li><p>A global name may also be accessible from other translation units (section 15.2).</p>
</li>
<li><p>Technically, the global namespace is considered a namespace, so a global name is an example of a namespace member name.</p>
</li>
</ul>
</li>
<li><p><em><strong>Statement scope</strong></em>:</p>
<ul>
<li><p>A namespace is in a statement scope if it is defined within the <code>()</code> part of a <code>for</code>-, <code>while</code>-, <code>if</code>-, or <code>switch</code>-statement.</p>
<p>Its scope extends from its point of declaration to the end of its statement. </p>
</li>
<li><p>All names in statement scope are local names.</p>
</li>
</ul>
</li>
<li><p><em><strong>Function scope</strong></em>:</p>
<ul>
<li>A label (section 9.6) is in scope from its point of declaration until the end of the function.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>A declaration of a name in a block can hide a declaration in an enclosing block or a global name.</p>
<p>That is, a name can be redefined to refer to a different entity within a block.</p>
<p>After exit from the block, the name resumes its previous meaning.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x; <span class="hljs-comment">// global x</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// local x hides global x</span><br>    x = <span class="hljs-number">1</span>; <span class="hljs-comment">// assing 1 to local x</span><br>    &#123;<br>        <span class="hljs-type">int</span> x; <span class="hljs-comment">// hides first local x</span><br>        x = <span class="hljs-number">2</span>; <span class="hljs-comment">// assign to second local x</span><br>    &#125;<br>    x = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-type">int</span>* p = &amp;x; <span class="hljs-comment">// take address of global x</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>Hiding names is unavoidable when writing large program.</p>
<p>However, a human reader can easily fail to notice that a name has been hidden (also known as <em><strong>shadowed</strong></em>).</p>
<ul>
<li>Because such errors are relatively rare, they can be very difficult to find.</li>
</ul>
<p>Consequently, name hiding should be minimized.</p>
<ul>
<li>Using names such as <code>i</code> and <code>x</code> for global variables or for local variables in a large function is asking for trouble.</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>A hidden global name can be referred to using the scope resolution operator, <code>::</code>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// hide global x</span><br>    ::x = <span class="hljs-number">2</span>; <span class="hljs-comment">// assign 2 to global x</span><br>    x = <span class="hljs-number">2</span>; <span class="hljs-comment">// assign 2 to local x</span><br>	<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>There is no way to use a hidden local name.</p>
</li>
</ol>
<ol start="4">
<li><p>The scope of a name that is not a class member starts at its point of declaration, that is, after the complete declarator and before the initializer.</p>
<p>This implies that a name can be used even to specify its own initial value. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">97</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = x; <span class="hljs-comment">// perverse: initialize x with its own (uninitialized) value</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>A good compiler warns if a variable is used before it has been initialized.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>It is possible to use a single name to refer to two different objects in a block without using <code>::</code> operator.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">11</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-comment">// perverse: use of two different objects both called x in a single scope</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = x; <span class="hljs-comment">// use global x (x == 97) to initialize y --&gt; y == 11</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">22</span>; <span class="hljs-comment">// initialize local x to 22</span><br>    y = x; <span class="hljs-comment">// assign local x to y --&gt; y == 22</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Again, such subtleties are best avoided.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>The names of functions arguments are considered declared in the outermost block of a function.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f5</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// x is considered declared in the outermost block of a function</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// Error: x is defined twice in the same scope</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This an error because <code>x</code> is defined twice in the same scope.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="7">
<li><p>Names introduced in a <code>for</code>-statement are local to that statement (in statement scope).</p>
<p>This allows us to use conventional names for loop variables repeatedly in a function.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;string&gt;&amp; v, list&lt;<span class="hljs-type">int</span>&gt;&amp; lst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x : v) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : lst) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i!=v.<span class="hljs-built_in">size</span>(); ++i) cout &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This contains no name clashes.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="8">
<li>A declaration is not allowed as the only statement on the branch of an <code>if</code>-statement (section 9.4.1).</li>
</ol>
<h4 id="6-3-5-Initialization"><a href="#6-3-5-Initialization" class="headerlink" title="6.3.5 Initialization"></a>6.3.5 Initialization</h4><ol>
<li><p>If an initializer is specified for an object, that initializer determines the initial value of an object.</p>
<p>An initializer can use one of four syntactic styles:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">X a1 &#123;v&#125;;<br>X a2 = &#123;v&#125;;<br>X a3 = v;<br><span class="hljs-function">X <span class="hljs-title">a4</span><span class="hljs-params">(v)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Of these, only the first can be used in every context, and I strongly recommend its use. </p>
<ul>
<li>It is clearer and less error-prone than the alternatives. </li>
<li>However, the first form (used for <code>a1</code>) is new in C++11, so the other three forms are what you find in older code. </li>
</ul>
</li>
<li><p>The two forms using <code>=</code> are what you use in C. </p>
<ul>
<li><p>Old habits die hard, so I sometimes (inconsistently) use <code>=</code> when initializing a simple variable with a simple value. </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;z&#x27;</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>However, anything much more complicated than that is better done using <code>&#123;&#125;</code>. </p>
<p>Initialization using <code>&#123;&#125;</code>, <em><strong>list initialization</strong></em>, does not allow narrowing (§iso.8.5.4). </p>
<p>That is:</p>
<ul>
<li>An integer cannot be converted to another integer that cannot hold its value. <ul>
<li>For example, <code>char</code> to <code>int</code> is allowed, but not <code>int</code> to <code>char</code>.</li>
</ul>
</li>
<li>A floating-point value cannot be converted to another floating-point type that cannot hold its value.<ul>
<li>For example, <code>float</code> to <code>double</code> is allowed, but not <code>double</code> to <code>float</code>.</li>
</ul>
</li>
<li>A floating-point value cannot be converted to an integer type.</li>
<li>An integer value cannot be converted to a floating-point type.</li>
</ul>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> val, <span class="hljs-type">int</span> val2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x2 = val; <span class="hljs-comment">// if val==7.9, x2 becomes 7</span><br>    <span class="hljs-type">char</span> c2 = val2; <span class="hljs-comment">// if val2==1025, c2 becomes 1</span><br><br>    <span class="hljs-type">int</span> x3 &#123;val&#125;; <span class="hljs-comment">// error : possible truncation</span><br>    <span class="hljs-type">char</span> c3 &#123;val2&#125;; <span class="hljs-comment">// error : possible narrowing</span><br><br>    <span class="hljs-type">char</span> c4 &#123;<span class="hljs-number">24</span>&#125;; <span class="hljs-comment">// OK: 24 can be represented exactly as a char</span><br>    <span class="hljs-type">char</span> c5 &#123;<span class="hljs-number">264</span>&#125;; <span class="hljs-comment">// error (assuming 8-bit chars): 264 cannot be represented as a char</span><br><br>    <span class="hljs-type">int</span> x4 &#123;<span class="hljs-number">2.0</span>&#125;; <span class="hljs-comment">// error : no double to int value conversion</span><br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;    <br></code></pre></td></tr></table></figure>

<p>See §10.5 for the conversion rules for built-in types.</p>
</li>
</ol>
<ol start="2">
<li><p>There is no advantage to using <code>&#123;&#125;</code> initialization, and one trap, when <strong>using <code>auto</code> to get the type determined by the initializer</strong>. </p>
<p>The trap is that if the initializer is a <code>&#123;&#125;</code>-list, we may not want its type deduced (§6.3.6.2). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> z1 &#123;<span class="hljs-number">99</span>&#125;; <span class="hljs-comment">// z1 is an initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> z2 = <span class="hljs-number">99</span>; <span class="hljs-comment">// z2 is an int</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>So prefer <code>=</code> when using <code>auto</code>.</strong></p>
</li>
</ul>
</li>
<li><p>It is possible to define a class so that an object can be initialized by a list of values and alternatively be constructed given a couple of arguments that are not simply values to be stored. </p>
<ul>
<li><p>The classical example is a <code>vector</code> of integers:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; v1 &#123;<span class="hljs-number">99</span>&#125;; <span class="hljs-comment">// v1 is a vector of 1 element with the value 99</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">99</span>)</span></span>; <span class="hljs-comment">// v2 is a vector of 99 elements each with the default value 0</span><br></code></pre></td></tr></table></figure>

<ul>
<li>I use the explicit invocation of a constructor, <code>(99)</code>, to get the second meaning. </li>
</ul>
</li>
<li><p>Most types do not offer such confusing alternatives – even most <code>vector</code>s do not.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; v1&#123;<span class="hljs-string">&quot;hello!&quot;</span>&#125;; <span class="hljs-comment">// v1 is a vector of 1 element with the value &quot;hello!&quot;</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-string">&quot;hello!&quot;</span>)</span></span>; <span class="hljs-comment">// error : no vector constructor takes a string literal</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>So, prefer <code>&#123;&#125;</code> initialization over alternatives unless you have a strong reason not to.</p>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>The empty initializer list, <code>&#123;&#125;</code>, is used to indicate that a default value is desired. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x4&#123;&#125;; <span class="hljs-comment">// x4 becomes 0</span><br><span class="hljs-type">double</span> d4&#123;&#125;; <span class="hljs-comment">// d4 becomes 0.0</span><br><span class="hljs-type">char</span>∗ p&#123;&#125;; <span class="hljs-comment">//p becomes nullptr</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v4&#123;&#125;; <span class="hljs-comment">// v4 becomes the empty vector</span><br>string s4&#123;&#125;; <span class="hljs-comment">// s4 becomes &quot;&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>Most types have a default value. </p>
<p>For integral types, the default value is a suitable representation of zero. </p>
<p>For pointers, the default value is <code>nullptr</code> (§7.2.2). </p>
<p>For user-defined types, the default value (if any) is determined by the type’s constructors (§17.3.3).</p>
</li>
</ol>
<ol start="5">
<li>For user-defined types, there can be a distinction between direct initialization (where implicit conversions are allowed) and copy initialization (where they are not); see §16.2.6.</li>
</ol>
<ol start="6">
<li>Initialization of particular kinds of objects is discussed where appropriate：<ul>
<li>Pointers: §7.2.2, §7.3.2, §7.4</li>
<li>References: §7.7.1 (lvalues), §7.7.2 (rvalues)</li>
<li>Arrays: §7.3.1, §7.3.2</li>
<li>Constants: §10.4</li>
<li>Classes: §17.3.1 (not using constructors), §17.3.2 (using constructors), §17.3.3 (default), §17.4 (member and base), §17.5 (copy and move)</li>
<li>User-defined containers: §17.3.4</li>
</ul>
</li>
</ol>
<h3 id="6-4-Objects-and-Values"><a href="#6-4-Objects-and-Values" class="headerlink" title="6.4 Objects and Values"></a>6.4 Objects and Values</h3><h3 id="6-4-Objects-and-Values-1"><a href="#6-4-Objects-and-Values-1" class="headerlink" title="6.4 Objects and Values"></a>6.4 Objects and Values</h3><ol>
<li><p>We can allocate and use objects that do not have names (e.g., created using new), and it is possible to assign to strange-looking expressions (e.g., ∗p[a+10]=7). </p>
<p>Consequently, we need a name for ‘‘something in memory.’’ </p>
<ul>
<li><p>This is the simplest and most fundamental notion of an object. </p>
</li>
<li><p>That is, an object is a contiguous region of storage; an lvalue is an expression that refers to an object. </p>
</li>
</ul>
<p>The word ‘‘lvalue’’ was originally coined to mean ‘‘something that can be on the left-hand side of an<br>assignment.’’ </p>
<ul>
<li>However, not every lvalue may be used on the left-hand side of an assignment; an lvalue can refer to a constant (§7.7). </li>
</ul>
<p>An lvalue that has not been declared <code>const</code> is often called a modifiable lvalue. </p>
<p>This simple and low-level notion of an object should not be confused with the notions of class object and object of polymorphic type (§3.2.2, §20.3.2).</p>
</li>
</ol>
<h4 id="6-4-1-Lvalues-and-Rvalues"><a href="#6-4-1-Lvalues-and-Rvalues" class="headerlink" title="6.4.1 Lvalues and Rvalues"></a>6.4.1 Lvalues and Rvalues</h4><ol start="2">
<li><p>To complement the notion of an lvalue, we have the notion of an rvalue. </p>
<p>Roughly, rvalue means ‘‘a value that is not an lvalue,’’ such as a temporary value (e.g., the value returned by a function).</p>
<p>If you need to be more technical (say, because you want to read the ISO C++ standard), you need a more refined view of lvalue and rvalue.</p>
</li>
</ol>
<ol start="3">
<li> There are two properties that matter for an object when it comes to addressing, copying, and moving:</li>
</ol>
<ul>
<li><em>Has identity</em>: <ul>
<li>The program has the name of, pointer to, or reference to the object so that it is possible to determine if two objects are the same, whether the value of the object has changed, etc.</li>
</ul>
</li>
<li><em>Movable</em>: <ul>
<li>The object may be moved from (i.e., we are allowed to move its value to another location and leave the object in a valid but unspecified state, rather than copying; §17.5).</li>
</ul>
</li>
</ul>
<p>   It turns out that three of the four possible combinations of those two properties are needed to precisely describe the C++ language rules (we have no need for objects that do not have identity and cannot be moved). </p>
<ul>
<li>只有三种组合情况需要考虑。因为没有identity的objects没有必要考虑，也不能move。</li>
</ul>
<p>   Using ‘‘<code>m</code> for movable’’ and ‘‘<code>i</code> for has identity,’’ we can represent this classification of expressions graphically:</p>
<p>   <img src="image-20230213150314314.png" srcset="/img/loading.gif" lazyload alt="image-20230213150314314"></p>
<ul>
<li><p>So, a classical lvalue is something that has identity and cannot be moved (because we could examine it after a move), and a classical rvalue is anything that we are allowed to move from. </p>
</li>
<li><p>The other alternatives are prvalue (‘‘pure rvalue’’), glvalue (‘‘generalized lvalue’’), and xvalue (‘‘x’’ for ‘‘extraordinary’’ or ‘‘expert only’’; the suggestions for the meaning of this ‘‘x’’ have been quite imaginative).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;string&gt;&amp; vs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;string&gt;&amp; v2 = std::<span class="hljs-built_in">move</span>(vs); <span class="hljs-comment">// move vs to v2</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Here, <code>std::move(vs)</code> is an xvalue: it clearly has identity (we can refer to it as <code>vs</code>), but we have explicitly given permission for it to be moved from by calling <code>std::move()</code> (§3.3.2, §35.5.1).</p>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>For practical programming, thinking in terms of rvalue and lvalue is usually sufficient. </p>
<p><strong>Note that every expression is either an lvalue or an rvalue, but not both</strong>. </p>
</li>
</ol>
<h4 id="6-4-2-Lifetimes-of-Objects"><a href="#6-4-2-Lifetimes-of-Objects" class="headerlink" title="6.4.2 Lifetimes of Objects"></a>6.4.2 Lifetimes of Objects</h4><ol>
<li><p>The <em><strong>lifetime</strong></em> of an object starts when its constructor completes and ends when its destructor starts executing.</p>
<ul>
<li>Objects of type without a declared constructor, such as an <code>int</code>, can be considered to have default constructors and destructors that do nothing.</li>
</ul>
</li>
<li><p>We can classify objects based on their lifetimes:</p>
<ul>
<li><em><strong>Automatic</strong></em><ul>
<li>Unless the programmer specifies otherwise (section 12.1.8, section 16.2.12), an object declared in a function is created when its definition is encountered and destroyed when its name goes out of scope.</li>
<li>Such objects are sometimes called <em><strong>automatic</strong></em> objects.</li>
<li>In typical implementation, automatic objects are allocated on the stack; each call of the function gets its own <em><strong>stack frame</strong></em> to hold its automatic objects.</li>
</ul>
</li>
<li><em><strong>Static</strong></em>:<ul>
<li><strong>Objects declared in global or namespace scope</strong> (section 6.3.4) and <strong><code>static</code>s declared in functions</strong> (section 12.1.8) <strong>or classes</strong>(section 16.2.12) are created and initialized once (only) and “live” until the program terminates (section 15.4.3).</li>
<li>Such objects are called <em><strong>static</strong></em> objects.</li>
<li>A static object has the same address throughout the life of a program execution.</li>
<li>Static objects can cause serious problems in a multi-threaded program because they are shared among all threads and typically require locking to avoid data races (section 5.3.1, section 42.3).</li>
</ul>
</li>
<li><em><strong>Free store</strong></em>:<ul>
<li>Using the <code>new</code> and <code>delete</code> operators, we can create objects whose lifetimes are controlled directly (section 11.2).</li>
</ul>
</li>
<li><em><strong>Temporary objects</strong></em>:<ul>
<li>E.g., intermediate results in a computation or an object used to hold a value for a reference to <code>const</code> argument.</li>
<li>Their lifetime is determined by their use.</li>
<li>If they are bound to a reference, their lifetime is that of the reference; otherwise, they “live” until the end of the full expression of which they are part.<ul>
<li>A <em><strong>full expression</strong></em> is an expression that is not part of another expression.</li>
<li>Typically, temporary objects are automatic.</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>Thread-local objects</strong></em>:<ul>
<li>that is, objects declared <code>thread_local</code> (section 42.2.8)</li>
<li>Such objects are created when their thread is and destroy when their thread is.</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>Static</strong></em> and <em><strong>automatic</strong></em> are traditionally referred to as <em><strong>storage classes</strong></em>.</p>
</li>
<li><p>Array elements and nonstatic class members have their lifetimes determined by the object of which they are part.</p>
</li>
</ol>
<h2 id="Chapter-7-Pointers-Arrays-and-References"><a href="#Chapter-7-Pointers-Arrays-and-References" class="headerlink" title="Chapter 7. Pointers, Arrays, and References"></a>Chapter 7. Pointers, Arrays, and References</h2><h3 id="7-3-Arrays"><a href="#7-3-Arrays" class="headerlink" title="7.3 Arrays"></a>7.3 Arrays</h3><h4 id="7-3-2-String-Literals"><a href="#7-3-2-String-Literals" class="headerlink" title="7.3.2 String Literals"></a>7.3.2 String Literals</h4><ol>
<li><p>A <em><strong>string literal</strong></em> is a character sequence enclosed within double quotes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;this is a string&quot;</span><br></code></pre></td></tr></table></figure>

<p>A string literal contains one more character than it appears to have; it is terminated by the <strong>null character</strong>, <code>&#39;\0&#39;</code>, with the value <code>0</code>. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sizeof</span>(<span class="hljs-string">&quot;Bohr&quot;</span>)==<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>The type of a string literal is “array of the appropriate number of <code>const</code> characters,” so <code>&quot;Bohr&quot;</code> is of type <code>const char[5]</code>.</p>
</li>
</ol>
<h3 id="7-5-Pointers-and-const"><a href="#7-5-Pointers-and-const" class="headerlink" title="7.5 Pointers and const"></a>7.5 Pointers and <code>const</code></h3><h3 id="7-7-References"><a href="#7-7-References" class="headerlink" title="7.7 References"></a>7.7 References</h3><ol>
<li><p>To reflect the lvalue/rvalue and <code>const</code>/non-<code>const</code> distinctions, there are three kinds of references:</p>
<ul>
<li><em><strong>lvalue references</strong></em>: <ul>
<li>to refer to objects whose value we want to change</li>
</ul>
</li>
<li><code>const</code> <em><strong>references</strong></em>:<ul>
<li>to refer to objects whose value we do not want to change (e.g., a constant)</li>
</ul>
</li>
<li><em><strong>rvalue references</strong></em>: <ul>
<li>to refer to objects whose value we do not need to preserve after we have used it (e.g., a temporary)</li>
</ul>
</li>
</ul>
<p>Collectively, they are called <em><strong>references</strong></em>. The first two are both called <em><strong>lvalue references</strong></em>.</p>
</li>
</ol>
<h4 id="7-7-1-Lvalue-References"><a href="#7-7-1-Lvalue-References" class="headerlink" title="7.7.1 Lvalue References"></a>7.7.1 Lvalue References</h4><ol>
<li><p>Initialization of a reference is trivial when the initializer is an lvalue (an object whose address you can take; section 6.4).</p>
<ul>
<li>The initializer for “plain” <code>T&amp;</code> must be a lvalue of type <code>T</code>.</li>
</ul>
<p>The initializer for a <code>const T&amp;</code> need not be an lvalue or evenof type <code>T</code>. In such cases:</p>
<ul>
<li>First, implicit type conversion to <code>T</code> is applied if necessary (section 10.5).</li>
<li>Then, the resulting value is placed in a temporary variable of type <code>T</code>.</li>
<li>Finally, this temporary variable is used as the value of the initializer.</li>
</ul>
</li>
</ol>
<h4 id="7-7-2-Rvalue-References"><a href="#7-7-2-Rvalue-References" class="headerlink" title="7.7.2 Rvalue References"></a>7.7.2 Rvalue References</h4><h4 id="7-7-3-References-to-References"><a href="#7-7-3-References-to-References" class="headerlink" title="7.7.3 References to References"></a>7.7.3 References to References</h4><h4 id="7-7-3-References-to-References-1"><a href="#7-7-3-References-to-References-1" class="headerlink" title="7.7.3 References to References"></a>7.7.3 References to References</h4><ol>
<li><p>It you take a reference to a reference to a type, you get a reference to that type, rather than some kind of special reference to reference type. </p>
<p>But what kind of reference? Lvalue reference or rvalue reference? </p>
<ul>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> rr_i = <span class="hljs-type">int</span>&amp;&amp;;<br><span class="hljs-keyword">using</span> lr_i = <span class="hljs-type">int</span>&amp;;<br><span class="hljs-keyword">using</span> rr_rr_i = rr_i&amp;&amp;; <span class="hljs-comment">// ‘‘int &amp;&amp; &amp;&amp;’’ is an int&amp;&amp;</span><br><span class="hljs-keyword">using</span> lr_rr_i = rr_i&amp;; <span class="hljs-comment">// ‘‘int &amp;&amp; &amp;’’ is an int&amp;</span><br><span class="hljs-keyword">using</span> rr_lr_i = lr_i&amp;&amp;; <span class="hljs-comment">// ‘‘int &amp; &amp;&amp;’’ is an int&amp;</span><br><span class="hljs-keyword">using</span> lr_lr_i = lr_i&amp;; <span class="hljs-comment">// ‘‘int &amp; &amp;’’ is an int&amp;</span><br></code></pre></td></tr></table></figure></li>
<li><p>In other words, <strong>lvalue reference always wins</strong>. </p>
</li>
<li><p>This makes sense: nothing we can do with types can change the fact that an lvalue reference refers to an lvalue. </p>
</li>
<li><p>This is sometimes known as <em><strong>reference collapse</strong></em>.</p>
</li>
</ul>
<p>The syntax does not allow:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> &amp;&amp; &amp; r = i;<br></code></pre></td></tr></table></figure>

<ul>
<li>Reference to reference can only happen as the result of an alias (§3.4.5, §6.5) or a template type argument (§23.5.2.1).</li>
</ul>
</li>
</ol>
<h4 id="7-7-4-Pointers-and-References"><a href="#7-7-4-Pointers-and-References" class="headerlink" title="7.7.4 Pointers and References"></a>7.7.4 Pointers and References</h4><h2 id="Chapter-8-Structures-Unions-and-Enumerations"><a href="#Chapter-8-Structures-Unions-and-Enumerations" class="headerlink" title="Chapter 8. Structures, Unions, and Enumerations"></a>Chapter 8. Structures, Unions, and Enumerations</h2><h3 id="8-2-struct-Names"><a href="#8-2-struct-Names" class="headerlink" title="8.2 struct Names"></a>8.2 <code>struct</code> Names</h3><ol>
<li><p>The name of a type becomes available for use immediately after it has been encountered and not just after the declaration has been seen. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Link</span> &#123;<br>    Link* previous;<br>    Link* successor;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>However, it is not possible to declare new objects of a <code>struct</code> until its complete declaration has been seen.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">No_good</span> &#123;<br>    No_good member; <span class="hljs-comment">// Error: recursive definition0</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This is an error because the compiler is not able to determine the size of <code>No_good</code>.</li>
</ul>
<p>To allow  two (or more) <code>struct</code>s to refer to each other, we can declare a name to be the name of a <code>struct</code>.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>; <span class="hljs-comment">// struct name declaration: List to be defined later</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Link</span> &#123;<br>    Link* pre;<br>    Link* suc;<br>    List* member_of;<br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span> &#123;<br>    Link* head;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Without the first declaration of <code>List</code>, use of the pointer type <code>List*</code> in the declaration of <code>Link</code> would have been a syntax error.</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>The name of a <code>struct</code> can be used before the type is defined as long as that use does not require the name of a member or the size of the structure to be known.</p>
<p>However, until the completion of the delcaration of a <code>struct</code>, that <code>struct</code> is an incomplete type. </p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>; <span class="hljs-comment">// &quot;S&quot; is the name of some type</span><br><br><span class="hljs-keyword">extern</span> S a;<br><span class="hljs-function">S <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(S)</span></span>;<br><span class="hljs-function">S* <span class="hljs-title">h</span><span class="hljs-params">(S*)</span></span>;<br></code></pre></td></tr></table></figure>

<p>However, many such declarations cannot be used unless the type <code>S</code> is defined:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">k</span><span class="hljs-params">(S* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    S a; <span class="hljs-comment">// Error: S not defined; size needed to allocate</span><br>    <br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// Error: S not defined; size needed to return value</span><br>    <span class="hljs-built_in">g</span>(a); <span class="hljs-comment">// Error: S not defined; size needed to pass argument</span><br>    p-&gt;m = <span class="hljs-number">7</span>; <span class="hljs-comment">// Error: S not defined; member named not known</span><br>    <br>    S* q = <span class="hljs-built_in">h</span>(p); <span class="hljs-comment">// OK: pointers can be allocated and passed</span><br>    q-&gt;m = <span class="hljs-number">7</span>; <span class="hljs-comment">// Error: S not defined; member name not known</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>For reasons that reach into the prehistory of C, it is possible to declare a <code>struct</code> and a non-<code>struct</code> with the same name in the same scope.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123; <span class="hljs-comment">/* ... */</span>&#125;; <span class="hljs-comment">// struct with name &quot;stat&quot;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">char</span>* name, <span class="hljs-keyword">struct</span> stat* buf)</span></span>; <span class="hljs-comment">// non-struct with name &quot;stat&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>In that case, the plain name (<code>stat</code>) is the name of the non-<code>struct</code>, and the <code>struct</code> must be refered to with the prefix <code>struct</code>.</li>
</ul>
<p>Similarly, the keywords <code>class</code>, <code>union</code> (section 8.3), and <code>enum</code> (section 8.4) can be used as prefixes for disambiguation.</p>
<p>However, it is best not to overload names to make such explicit disambiguation necessary.</p>
</li>
</ol>
<h3 id="8-3-Unions"><a href="#8-3-Unions" class="headerlink" title="8.3 Unions"></a>8.3 Unions</h3><ol>
<li>A <code>union</code> is a <code>struct</code> in which all members are allocated at the same address so that <code>union</code> occupies only as much space as its largest member.<ul>
<li>Naturally, a <code>union</code> can hold a value for only one member at a time.</li>
</ul>
</li>
</ol>
<h4 id="8-3-2-Anonymous-unions"><a href="#8-3-2-Anonymous-unions" class="headerlink" title="8.3.2 Anonymous unions"></a>8.3.2 Anonymous <code>union</code>s</h4><ol>
<li>A anonymous <code>union</code> is an object, not a type, and its members can be accessed without mentioning an object name.<ul>
<li>That means that we can use members of an anonymous <code>union</code> exactly as we use other member of a class – as long as we remember that <code>union</code> members really can be used only one at a time.</li>
</ul>
</li>
</ol>
<h3 id="8-4-Enumerations"><a href="#8-4-Enumerations" class="headerlink" title="8.4 Enumerations"></a>8.4 Enumerations</h3><ol>
<li><p>An <em><strong>enumeration</strong></em> is a type that can hold a set of integer values specified by the user. </p>
<p>Some of an enumeration’s possible values are named and called <em><strong>enumerators</strong></em>.</p>
<ul>
<li><p>For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>&#123;red, green, blue&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This defines an enumberation called <code>Color</code> with enumerators <code>red</code>, <code>green</code>, and <code>blue</code>.</li>
</ul>
</li>
<li><p>“An enumeration” is colloquially shortented “an <code>enum</code>.”</p>
</li>
</ul>
</li>
<li><p>There are two kinds of enumerations:</p>
<ul>
<li><code>enum class</code>es, <ul>
<li>for which the enumerator names (e.g., <code>red</code>) are local to the <code>enum</code> and </li>
<li>their values do not explicitly convert to other types.</li>
</ul>
</li>
<li>“Plain <code>enum</code>s,”<ul>
<li>for which the enumerator names are in the same scope as the <code>enum</code> and </li>
<li>their values implicitly convert to integers.</li>
</ul>
</li>
</ul>
<p>In general, prefer the <code>enum class</code>es because they cause fewer surprises.</p>
</li>
</ol>
<h4 id="8-4-1-enum-Classes"><a href="#8-4-1-enum-Classes" class="headerlink" title="8.4.1 enum Classes"></a>8.4.1 <code>enum</code> Classes</h4><h4 id="8-4-2-Plain-enums"><a href="#8-4-2-Plain-enums" class="headerlink" title="8.4.2 Plain enums"></a>8.4.2 Plain <code>enum</code>s</h4><h4 id="8-4-3-Unamed-enums"><a href="#8-4-3-Unamed-enums" class="headerlink" title="8.4.3 Unamed enums"></a>8.4.3 Unamed <code>enum</code>s</h4><h2 id="Chapter-9-Statements"><a href="#Chapter-9-Statements" class="headerlink" title="Chapter 9. Statements"></a>Chapter 9. Statements</h2><h3 id="9-2-Statement-Summary"><a href="#9-2-Statement-Summary" class="headerlink" title="9.2 Statement Summary"></a>9.2 Statement Summary</h3><h3 id="9-4-Selection-Statements"><a href="#9-4-Selection-Statements" class="headerlink" title="9.4 Selection Statements"></a>9.4 Selection Statements</h3><h4 id="9-4-1-if-Statements"><a href="#9-4-1-if-Statements" class="headerlink" title="9.4.1 if Statements"></a>9.4.1 <code>if</code> Statements</h4><ol>
<li>In an <code>if</code>-statement, the first (or only) statement is executed if the condition is <code>true</code> and the second statement (if it is specified) is executed otherwise.</li>
</ol>
<ol start="2">
<li><p>If a condition evaluates to something different from a Boolean, it is – if possible – implicitly converted to a <code>bool</code>.</p>
<p>This implies that any arithmetic or pointer expression can be used as a condition.</p>
<ul>
<li><p>For example, if <code>x</code> is an integer, then</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(x) <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>means</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>) <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure></li>
<li><p>For a pointer <code>p</code>,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(p) <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>is a direct statement of the test “Does <code>p</code> point to a valid object (assuming proper initialization)?” and is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>Note that a “plain” <code>enum</code> can be implicitly converted to an integer and then to a <code>bool</code>, whereas an <code>enum class</code> cannot (section 8.4.1).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">E1</span> &#123;a,b&#125;;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">E2</span> &#123;a,b&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(E1 x, E2 y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x) <span class="hljs-comment">// OK: &quot;plain&quot; enum can be implicitly converted to an integer and then to a bool</span><br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span>(y) <span class="hljs-comment">// Error: no conversion to bool</span><br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span>(y==E2::a) <span class="hljs-comment">// OK</span><br>        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>The logical operators <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> are most commonly used in conditions.</p>
<p>The operators <code>&amp;&amp;</code> and <code>||</code> will not evaluate their second argument unless doing so is necessary.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(p &amp;&amp; <span class="hljs-number">1</span> &lt; p-&gt;count)<br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<ul>
<li>This test <code>1 &lt; p-&gt;count</code> only if <code>p</code> is not a <code>nullptr</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>For choosing between two alternatives each of which produces a value, a conditional expression (section 11.1.3) is a more direct expression of intent than an <code>if</code>-statement.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (a&gt;b) ? a : b; <span class="hljs-comment">// return the larger of a and b</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>A name can only be used within the scope in which it is declared.</p>
<p>In particular, it cannot be used on another branch of an <code>if</code>-statement.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (i) &#123;<br>        <span class="hljs-type">int</span> x = i+<span class="hljs-number">2</span>;<br>        ++x;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        ++x; <span class="hljs-comment">// Error: x is not in scope</span><br>    &#125;<br>    ++x; <span class="hljs-comment">// Error: x is not in scope</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>A branch of an <code>if</code>-statement cannot be just a declaration.</p>
<p>If we need to introduce a name in a branch, it must be enclosed in a block (section 9.2).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (i)<br>        <span class="hljs-type">int</span> x = i+<span class="hljs-number">2</span>; <span class="hljs-comment">// Error: declaration of if-statement branch</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="9-5-Iteration-Statements"><a href="#9-5-Iteration-Statements" class="headerlink" title="9.5 Iteration Statements"></a>9.5 Iteration Statements</h3><h4 id="9-5-1-Range-for-Statements"><a href="#9-5-1-Range-for-Statements" class="headerlink" title="9.5.1 Range-for Statements"></a>9.5.1 Range-<code>for</code> Statements</h4><ol>
<li>The simplest loop is a range-<code>for</code>-statement; it simply gives the programmer access to each element of a range.</li>
</ol>
<h3 id="9-6-goto-Statements"><a href="#9-6-goto-Statements" class="headerlink" title="9.6 goto Statements"></a>9.6 <code>goto</code> Statements</h3><ol>
<li><p>C++ possesses the infamous <code>goto</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">goto</span> identifier;<br>identifier : statement<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>The <code>goto</code> has few uses in general high-level programming, but it can be very useful when C++ code is generated by a program rather than written by a person.<ul>
<li>For example, <code>goto</code>s can be used in a parser generated from a grammer by a parser generator.</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>The scope of a label is the function it is in (section 6.3.4).</p>
<p>This implies that you can use <code>goto</code> to jump both into and out of blocks. </p>
<p>The only restriction is that you cannot jump past an initializer or into an exception handler (section 13.5)</p>
</li>
</ol>
<ol start="4">
<li><p>One of the few sensible uses of <code>goto</code> in ordinary code is to break out from a nested loop or <code>switch</code>-statement (a <code>break</code> breaks out of only the innermost enclosing loop or <code>switch</code>-statement).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// do something to a two-dimensional matrix called mn</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i!=n; ++i)<br>        <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j!=m; ++j)<br>            <span class="hljs-keyword">if</span> (nm[i][j] == a)<br>                <span class="hljs-keyword">goto</span> found;<br>    <span class="hljs-comment">// not found</span><br>    <span class="hljs-comment">// ...</span><br>found:<br>    <span class="hljs-comment">// nm[i][j] == a</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Note that this <code>goto</code> just jumps forward to exit its loop. It does not introduce a new loop or enter a new scope.</p>
<p>That makes it the least troublesome and least confusing use of <code>goto</code>.</p>
</li>
</ol>
<h2 id="Chapter-10-Expressions"><a href="#Chapter-10-Expressions" class="headerlink" title="Chapter 10. Expressions"></a>Chapter 10. Expressions</h2><h3 id="10-3-Operator-Summary"><a href="#10-3-Operator-Summary" class="headerlink" title="10.3 Operator Summary"></a>10.3 Operator Summary</h3><h4 id="10-3-4-Temporary-Objects"><a href="#10-3-4-Temporary-Objects" class="headerlink" title="10.3.4 Temporary Objects"></a>10.3.4 Temporary Objects</h4><ol>
<li>Often, the compiler must introduce an object to hold an intermediate result of an expression.</li>
</ol>
<ul>
<li><p>For example, for <code>v=x+y∗z</code> the result of <code>y∗z</code> has to be put somewhere before it is added to <code>x</code>.</p>
<p> For built-in types, this is all handled so that a <em><strong>temporary object</strong></em> (often referred to as just a <em><strong>temporary</strong></em>) is invisible to the user.</p>
<p> For a user-defined type that holds a resource knowing the lifetime of a temporary can be important.</p>
</li>
</ul>
<ol start="2">
<li><p>Unless bound to a reference or used to initialize a named object (variable), a temporary object is destroyed at the end od the full expression in which it was created.</p>
<ul>
<li>A <em><strong>full expression</strong></em> is an expression that is not a subexpression of some other expression.</li>
</ul>
</li>
<li><p>The standard-library <code>string</code> has a member <code>c_str()</code> that returns a C-style pointer to a zero-terminated array of charactors.</p>
<p>Also, the operator <code>+</code> is defined to mean string concatenation. These are useful facilities for <code>string</code>s.</p>
<p>However, in combination they can cause obscure problems.</p>
<ul>
<li><p>For example:</p>
</li>
<li><p>```C++<br>void f(string&amp; s1, string&amp; s2, string&amp; s3)<br>{</p>
<pre><code class="hljs">const char* cs = (s1+s2).c_str(); // temporary is created and be destroyed. (full expression)
cout &lt;&lt; cs; // Error: cs points to deallocated storage. (might work)
if(strlen(cs=(s2+s3).c_str())&lt;8 &amp;&amp; cs[0]==&#39;a&#39;)&#123;
    // cs used here: not guaranteed to work
&#125;
</code></pre>
<p>}</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>     - <span class="hljs-string">&quot;Don&#x27;t do that!&quot;</span><br>     - Such code does <span class="hljs-keyword">get</span> written, so it <span class="hljs-keyword">is</span> worth knowning how it <span class="hljs-keyword">is</span> interpreted.<br>       - A temporary <span class="hljs-built_in">string</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> created to hold `s1+s2`. Next, A pointer to a C-style <span class="hljs-built_in">string</span> <span class="hljs-keyword">is</span> extraced <span class="hljs-keyword">from</span> that <span class="hljs-built_in">object</span>. Then -- at the end of the expression -- the temporary <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> deleted.<br>       - The C-style <span class="hljs-built_in">string</span> returned <span class="hljs-keyword">by</span> `c_str()` was allocated <span class="hljs-keyword">as</span> part of the temporary <span class="hljs-built_in">object</span> holding `s1+s2`, <span class="hljs-keyword">and</span> that storage <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> guaranteed to exist after that temporary <span class="hljs-keyword">is</span> destroyed.<br>       - Consequently, `cs` points to deallocated storage. The output operation `cout&lt;&lt;cs` might work <span class="hljs-keyword">as</span> expected, but that would be sheer luck.<br>       - A compiler can detect <span class="hljs-keyword">and</span> warn against many variants of <span class="hljs-keyword">this</span> problem.<br>     - The problem <span class="hljs-keyword">with</span> the `<span class="hljs-keyword">if</span>`-statement <span class="hljs-keyword">is</span> a bit more subtle.<br>       - The condition will work <span class="hljs-keyword">as</span> expected because the full expression <span class="hljs-keyword">in</span> which the temporary holding `s2+s3` <span class="hljs-keyword">is</span> created <span class="hljs-keyword">is</span> the condition itself.<br>       - However, that temporary <span class="hljs-keyword">is</span> destroyed before the controlled statement <span class="hljs-keyword">is</span> entered, so any use of `cs` there <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> guaranteed to work.<br><span class="hljs-number">4.</span> Please note that <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">case</span>, <span class="hljs-keyword">as</span> <span class="hljs-keyword">in</span> many others, the problems <span class="hljs-keyword">with</span> temporaries arose <span class="hljs-keyword">from</span> <span class="hljs-keyword">using</span> a high-level data type <span class="hljs-keyword">in</span> a low-level way.<br><br>   - A cleaner programming style yields a more understandable program fragment <span class="hljs-keyword">and</span> avoids the problems <span class="hljs-keyword">with</span> temporaries completely.<br>   - For example:<br><br>     - ```C++<br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">string</span>&amp; s2, <span class="hljs-built_in">string</span>&amp; s3</span>)</span><br>       &#123;<br>           cout &lt;&lt; s1+s2;<br>           <span class="hljs-built_in">string</span> s = s2+s3;<br>           <span class="hljs-keyword">if</span>(s.length()&lt;<span class="hljs-number">8</span> &amp;&amp; s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;a&#x27;</span>)&#123;<br>               <span class="hljs-comment">// use s here</span><br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>A temporary can be used as an initializer for a <code>const</code> reference or a named object.</p>
</li>
<li><p>For example:</p>
<ul>
<li>```C++<br>void g(const string&amp;, const string&amp;);void h(string&amp;s1, string&amp; s2)<br>{<pre><code class="hljs">const string&amp; s = s1+s2;
string ss = s1+s2;

g(s,ss); // we can use s and ss here
</code></pre>
}<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">     - This <span class="hljs-keyword">is</span> fine. The temporary <span class="hljs-keyword">is</span> destroyed <span class="hljs-keyword">when</span> <span class="hljs-string">&quot;its&quot;</span> reference <span class="hljs-keyword">or</span> named <span class="hljs-built_in">object</span> goes <span class="hljs-keyword">out</span> of scope.<br><br>       Remember that returning a reference to a local variable <span class="hljs-keyword">is</span> an error <span class="hljs-keyword">and</span> that a temporary <span class="hljs-built_in">object</span> cannot be bound to a non-`<span class="hljs-keyword">const</span>` lvaue reference.<br><span class="hljs-number">5.</span> A temporary <span class="hljs-built_in">object</span> can also be created explicitly <span class="hljs-keyword">in</span> an expression <span class="hljs-keyword">by</span> invoking a constructor.<br><br>   For example:<br><br>   - ```C++<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params">Shape&amp; s, <span class="hljs-built_in">int</span> n, <span class="hljs-built_in">char</span> ch</span>)</span><br>     &#123;<br>         s.move(<span class="hljs-built_in">string</span>&#123;n,ch&#125;); <span class="hljs-comment">// construct a string with n copies of ch to pass to Shape::move()</span><br>         <span class="hljs-comment">// ...</span><br>     &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Such temporaries are destroyed in exactly the same way as the implicitly generated temporaries.</p>
</li>
</ul>
</li>
</ol>
<h3 id="10-4-Constant-Expressions"><a href="#10-4-Constant-Expressions" class="headerlink" title="10.4 Constant Expressions"></a>10.4 Constant Expressions</h3><ol>
<li><p>C++ offers two related meaning of “constant”:</p>
<ul>
<li><code>constexpr</code>: Evaluate at compile time.</li>
<li><code>const</code>: Do not modify in this scope.</li>
</ul>
<p>Basically, <code>constexpr</code>‘s role is to enable and ensure compile-time evaluation, whereas <code>const</code>‘s primary role is to sepcify immutability in interface.</p>
</li>
<li><p>A <em><strong>constant expression</strong></em> is <strong>an expression that a compiler can evaluate</strong>.</p>
<ul>
<li>It cannot use values that are not known at compile time and it cannot have side effects.</li>
</ul>
<p>Ultimately, a constant expression must start out with an integral value, a floating-point value, or an enumerator, and we can combine those using operator and <code>constexpr</code> functions that in turn produce values.</p>
<p>In addition, some addresses can be used in some forms of constant expressions.</p>
</li>
<li><p>There are a variety of reasons why someone might want a named constant rather than a literal or a value stored in a variable:</p>
<ul>
<li>Named constants make the code easier to understand and maintain.</li>
<li>A variable might be changed.<ul>
<li>So we have to be more careful in our reasoning than for a constant.</li>
</ul>
</li>
<li>The language requires constant expressions for array sizes, <code>case</code> labels, and <code>template</code> value arguments.</li>
<li>Embedded systems programmers like to put immutable data into read-only memory because read-only memory is cheaper than dynamic memory (in terms of cost and energy consumption), and often more plentiful. Also, data in read-only memory is immune to most system crashes.</li>
<li>If initialization is done at compile time, there can be no data races on that object in a multi-threaded system.</li>
<li>Sometimes, evaluating something once (at compile time) gives significantly better performance than doing so a million times at run time.</li>
</ul>
<p>Note that reasons [1], [2], [5] and (partly) [4] are logical.</p>
<p>We don’t just use constant expressions because of an obsession with performance. Often, the reason is that a constant expression is more direct representation of our system requirements.</p>
</li>
</ol>
<ol start="4">
<li> As part of the definition of a data item (here, I deliberately avoid the word “variable”), <code>constexpr</code> expresses the need for compile-time evaluation.</li>
</ol>
<p>   If the initializer for a <code>constexpr</code> can’t be evaluated at compile time, the compiler will give an error.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x1 = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x2 = <span class="hljs-number">7</span>;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x3 = x1; <span class="hljs-comment">// Error: initializer x is not a constant expression</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x4 = x2; <span class="hljs-comment">// OK: initializer x2 is a constant expression</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> y3 = x1; <span class="hljs-comment">// Error: initializer x is not a constant expression</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> y4 = x2; <span class="hljs-comment">// OK: initializer x2 is a constant expression</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>A clever compiler could deduce the value of <code>x1</code> in the initializer for <code>x3</code> was <code>7</code>.</p>
<p>However, we prefer not to rely on degrees of cleverness in compilers.</p>
</li>
</ul>
</li>
</ul>
<p>   In a large program, determining the values of variables at compile time is typically either very difficult or impossible.</p>
<ol start="5">
<li><p>The expressive power of constant expression is great. </p>
<p>We can use integer, floating-point, and enumeration values. We can use any operator that doesn’t modify state (e.g., <code>+</code>, <code>?:</code>, and <code>[]</code>, but not <code>=</code> or <code>++</code>). We can use <code>constexpr</code> functions (section 12.1.6) and literal types (section 10.4.3) to provide a significant level of type safety and expressive power.</p>
<p>It is almost unfair to compare this to what is commonly done with marcros (section 12.6).</p>
</li>
</ol>
<ol start="6">
<li><p>The conditional expression operator <code>?:</code> is the means of selection in a constant expression.</p>
<ul>
<li><p>For example, we can compute an integer square root at compile time:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">isqrt_helper</span><span class="hljs-params">(<span class="hljs-type">int</span> sq, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (sq &lt;= a) ? <span class="hljs-built_in">is_sqrt_helper</span>(sq+d,d+<span class="hljs-number">2</span>,a) : d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">isqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isqrt_helper</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,x)/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> s1 = <span class="hljs-built_in">isqrt</span>(<span class="hljs-number">9</span>); <span class="hljs-comment">// s1 becomes 3</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> s2 = <span class="hljs-built_in">isqrt</span>(<span class="hljs-number">1234</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<p>The condition of a <code>?:</code> is evaluated and then the selected alternative is evaluated.</p>
<p><strong>The alternative not selected is not evaluated and might even not a constant expression.</strong></p>
<p><strong>Similarly, operands of <code>&amp;&amp;</code> and <code>||</code> that are not evaluated need not be constant expressions.</strong></p>
<ul>
<li>This feature is primarily useful in <code>constexpr</code> functions that are sometimes used as constant expressions and sometimes not.</li>
</ul>
</li>
</ol>
<h4 id="10-4-1-Symbolic-Constants"><a href="#10-4-1-Symbolic-Constants" class="headerlink" title="10.4.1 Symbolic Constants"></a>10.4.1 Symbolic Constants</h4><h4 id="10-4-2-consts-in-Constant-Expressions"><a href="#10-4-2-consts-in-Constant-Expressions" class="headerlink" title="10.4.2 consts in Constant Expressions"></a>10.4.2 <code>const</code>s in Constant Expressions</h4><h4 id="10-4-3-Literal-Types"><a href="#10-4-3-Literal-Types" class="headerlink" title="10.4.3 Literal Types"></a>10.4.3 Literal Types</h4><ol>
<li><p>A sufficiently simple user-defined type can be used in a constant expression.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x,y,z;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;x,y,z+d&#125;;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> dx, <span class="hljs-type">int</span> dy)</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;x+dx,y+dy&#125;;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>A class with a <code>constexpr</code> constructor is called a <em><strong>literal type</strong></em>.</p>
<p>To be simple enough to be <code>constexpr</code>, a constructor must have an empty body and all members must be initialized by potentially constant expressions.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> Point origo&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> z = origo.x;<br><br><span class="hljs-keyword">constexpr</span> Point a[] = &#123;<br>    origo, Point&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;, Point&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;, origo.<span class="hljs-built_in">move</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br>&#125;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x = a[<span class="hljs-number">1</span>].x; <span class="hljs-comment">// x becomes 1</span><br><br><span class="hljs-keyword">constexpr</span> Point xy&#123;<span class="hljs-number">0</span>,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)&#125;; <span class="hljs-comment">// Error: sqrt(2) is not a constant expression</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>Note that we can have <code>constexpr</code> arrays and also access array elements and object members.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Naturally, we can define <code>constexpr</code> functions to take arguments of literal types.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x*x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">radial_distance</span><span class="hljs-params">(Point p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isqrt</span>(<span class="hljs-built_in">square</span>(p.x)+<span class="hljs-built_in">square</span>(p.y)+<span class="hljs-built_in">square</span>(p.z));<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> Point p1&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;; <span class="hljs-comment">// the default constructor is constexpr</span><br><span class="hljs-keyword">constexpr</span> Point p2&#123;p1.<span class="hljs-built_in">up</span>(<span class="hljs-number">20</span>)&#125;; <span class="hljs-comment">// Point::up() is constexpr</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> dist = <span class="hljs-built_in">radial_distance</span>(p2);<br></code></pre></td></tr></table></figure>

<ul>
<li>I use <code>int</code> rather than <code>double</code> just because I didn’t have a <code>constexpr</code> floating-point square root function handy.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>For a member function <code>constexpr</code> implies <code>const</code>, so I did not have to write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> dx, <span class="hljs-type">int</span> dy)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;x+dx,x+dy&#125;;&#125; <span class="hljs-comment">// there is no need for const</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="10-4-4-Reference-Arguments"><a href="#10-4-4-Reference-Arguments" class="headerlink" title="10.4.4 Reference Arguments"></a>10.4.4 Reference Arguments</h4><h4 id="10-4-5-Address-Constant-Expressions"><a href="#10-4-5-Address-Constant-Expressions" class="headerlink" title="10.4.5 Address Constant Expressions"></a>10.4.5 Address Constant Expressions</h4><h3 id="10-5-Implicit-Type-Conversion"><a href="#10-5-Implicit-Type-Conversion" class="headerlink" title="10.5 Implicit Type Conversion"></a>10.5 Implicit Type Conversion</h3><h4 id="10-5-1-Promotions"><a href="#10-5-1-Promotions" class="headerlink" title="10.5.1 Promotions"></a>10.5.1 Promotions</h4><h4 id="10-5-2-Conversions"><a href="#10-5-2-Conversions" class="headerlink" title="10.5.2 Conversions"></a>10.5.2 Conversions</h4><h5 id="10-5-2-1-Integral-Conversions"><a href="#10-5-2-1-Integral-Conversions" class="headerlink" title="10.5.2.1 Integral Conversions"></a>10.5.2.1 Integral Conversions</h5><h5 id="10-5-2-2-Floating-Point-Conversions"><a href="#10-5-2-2-Floating-Point-Conversions" class="headerlink" title="10.5.2.2 Floating-Point Conversions"></a>10.5.2.2 Floating-Point Conversions</h5><h5 id="10-5-2-3-Pointer-and-Reference-Conversions"><a href="#10-5-2-3-Pointer-and-Reference-Conversions" class="headerlink" title="10.5.2.3 Pointer and Reference Conversions"></a>10.5.2.3 Pointer and Reference Conversions</h5><h5 id="10-5-2-4-Pointer-to-Member-Conversions"><a href="#10-5-2-4-Pointer-to-Member-Conversions" class="headerlink" title="10.5.2.4 Pointer-to-Member Conversions"></a>10.5.2.4 Pointer-to-Member Conversions</h5><h5 id="10-5-2-5-Boolean-Conversions"><a href="#10-5-2-5-Boolean-Conversions" class="headerlink" title="10.5.2.5 Boolean Conversions"></a>10.5.2.5 Boolean Conversions</h5><h5 id="10-5-2-6-Floating-Integral-Conversions"><a href="#10-5-2-6-Floating-Integral-Conversions" class="headerlink" title="10.5.2.6 Floating-Integral Conversions"></a>10.5.2.6 Floating-Integral Conversions</h5><h4 id="10-5-3-Usual-Arithmetic-Conversions"><a href="#10-5-3-Usual-Arithmetic-Conversions" class="headerlink" title="10.5.3 Usual Arithmetic Conversions"></a>10.5.3 Usual Arithmetic Conversions</h4><h2 id="Chapter-11-Select-Operations"><a href="#Chapter-11-Select-Operations" class="headerlink" title="Chapter 11. Select Operations"></a>Chapter 11. Select Operations</h2><h3 id="11-1-Etc-Operators"><a href="#11-1-Etc-Operators" class="headerlink" title="11.1 Etc. Operators"></a>11.1 Etc. Operators</h3><h4 id="11-1-1-Logical-Operators"><a href="#11-1-1-Logical-Operators" class="headerlink" title="11.1.1 Logical Operators"></a>11.1.1 Logical Operators</h4><h4 id="11-1-2-Bitwise-Logical-Operators"><a href="#11-1-2-Bitwise-Logical-Operators" class="headerlink" title="11.1.2 Bitwise Logical Operators"></a>11.1.2 Bitwise Logical Operators</h4><h4 id="11-1-3-Conditional-Expressions"><a href="#11-1-3-Conditional-Expressions" class="headerlink" title="11.1.3 Conditional Expressions"></a>11.1.3 Conditional Expressions</h4><ol>
<li><p>Some <code>if</code>-statements can conveniently be replaced by <em><strong>conditional-expressions</strong></em>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (a &lt;= b)<br>    max = b;<br><span class="hljs-keyword">else</span><br>    max = a;<br></code></pre></td></tr></table></figure>

<p>This is more directly expressed like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">max = (a&lt;=b) ? b : a;<br></code></pre></td></tr></table></figure>

<ul>
<li>The parentheses around the condition are not necessary, but I find the code easier to read when they are used.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li>Conditional expressions are important in that they can be used in constant expressions (section 10.4 –&gt; 6).</li>
</ol>
<ol start="3">
<li><p>A pair of expressions <code>e1</code> and <code>e2</code> can be used as alternatives in a conditional expression, <code>c?e1:e2</code>, if they are the same type or if there is a common type <code>T</code>, to which they can both be implicitly converted.</p>
<ul>
<li>For arithmetic types, the usual arithmetic conversions (section 10.5.3) are used to find that common type.</li>
<li>For other types, either <code>e1</code> must be implicitly convertible to <code>e2</code>‘s type or vice versa.</li>
</ul>
<p>In addition, one branch may be a <code>throw</code>-expression (section 13.5.1).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fct</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = (p) ? *p : std::runtime_error&#123;<span class="hljs-string">&quot;unexpected nullptr&quot;</span>&#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="11-2-Free-Store"><a href="#11-2-Free-Store" class="headerlink" title="11.2 Free Store"></a>11.2 Free Store</h3><h3 id="11-4-Lambda-Expressions"><a href="#11-4-Lambda-Expressions" class="headerlink" title="11.4 Lambda Expressions"></a>11.4 Lambda Expressions</h3><h3 id="11-5-Explicit-Type-Conversion"><a href="#11-5-Explicit-Type-Conversion" class="headerlink" title="11.5 Explicit Type Conversion"></a>11.5 Explicit Type Conversion</h3><h4 id="11-5-2-Named-Casts"><a href="#11-5-2-Named-Casts" class="headerlink" title="11.5.2 Named Casts"></a>11.5.2 Named Casts</h4><ol>
<li><p>Some type conversions are not well behaved or easy to type check; they are not simple constructions of values from a well-defined set of argument values. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">IO_device∗ d1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;IO_device∗&gt;(<span class="hljs-number">0Xff00</span>); <span class="hljs-comment">// device at 0Xff00</span><br></code></pre></td></tr></table></figure>

<ul>
<li>There is no way a compiler can know whether the integer <code>0Xff00</code> is a valid address (of an I/O device register). </li>
</ul>
</li>
<li><p>Consequently, the correctness of the conversions is completely in the hands of the programmer.</p>
</li>
</ul>
<p>Explicit type conversion, often called <em><strong>casting</strong></em>, is occasionally essential. </p>
<ul>
<li>However, traditionally it is seriously overused and a major source of errors.</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Another classical example of the need for explicit type conversion is dealing with ‘‘raw memory,’’ that is, memory that holds or will hold objects of a type not known to the compiler. </p>
<ul>
<li><p>For example, a memory allocator (such as <code>operator new()</code>; §11.2.3) may return a <code>void∗</code> pointing to newly allocated memory:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span>∗ <span class="hljs-built_in">my_allocator</span>(siz <span class="hljs-type">e_t</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>∗ p = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>∗&gt;(<span class="hljs-built_in">my_allocator</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// new allocation used as ints</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>A compiler does not know the type of the object pointed to by the void∗.</p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>The fundamental idea behind the named casts is to make type conversion more visible and to allow the programmer to express the intent of a cast:</p>
<ul>
<li><code>static_cast</code><ul>
<li>converts between related types such as one pointer type to another the same class hierarchy, an integral type to an enumeration, or a floating-point type to an integral type.</li>
<li>It also does conversions defined by constructors (§16.2.6, §18.3.3, §iso.5.2.9) and conversion operators (§18.4).</li>
</ul>
</li>
<li><code>reinterpret_cast</code><ul>
<li>handles conversions between unrelated types such as an integer to a pointer or a pointer to an unrelated pointer type.</li>
</ul>
</li>
<li><code>const_cast</code><ul>
<li>converts between types that differ only in <code>const</code> and <code>volatile</code> qualifiers (§iso.5.2.11).</li>
</ul>
</li>
<li><code>dynamic_cast</code><ul>
<li>does run-time checked conversion of pointers and references into a class hierarchy (§22.2.1, §iso.5.2.7).</li>
</ul>
</li>
</ul>
<p>These distinctions among the named casts allow the compiler to apply some minimal type checking and make it easier for a programmer to find the more dangerous conversions represented as <code>reinterpret_casts</code>. </p>
<ul>
<li>Some <code>static_cast</code>s are portable, but few <code>reinterpret_cast</code>s are. </li>
</ul>
<p>Hardly any guarantees are made for <code>reinterpret_cast</code>, but generally it produces a value of a new type that has the same bit pattern as its argument. </p>
<ul>
<li><p>If the target has at least as many bits as the original value, we can <code>reinterpret_cast</code> the result back to its original type and use it. </p>
</li>
<li><p>The result of a <code>reinterpret_cast</code> is guaranteed to be usable only if its result is converted back to the exact original type.</p>
</li>
<li><p>Note that <code>reinterpret_cast</code> is the kind of conversion that must be used for pointers to functions (§12.5). </p>
</li>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> x = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">int</span>∗ p1 = &amp;x; <span class="hljs-comment">// error : no implicit char* to int* conversion</span><br><span class="hljs-type">int</span>∗ p2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>∗&gt;(&amp;x); <span class="hljs-comment">// error : no implicit char* to int* conversion</span><br><span class="hljs-type">int</span>∗ p3 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>∗&gt;(&amp;x); <span class="hljs-comment">// OK: on your head be it</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : B &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// see §3.2.2 and §20.5.2</span><br><br>B∗ pb = <span class="hljs-keyword">new</span> D; <span class="hljs-comment">// OK: implicit conversion from D* to B*</span><br>D∗ pd = pb; <span class="hljs-comment">// error : no implicit conversion from B* to D*</span><br>D∗ pd = <span class="hljs-built_in">static_cast</span>&lt;D∗&gt;(pb); <span class="hljs-comment">//OK</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Conversions among class pointers and among class reference types are discussed in §22.2.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>If you feel tempted to use an explicit type conversion, take the time to consider if it is really necessary. </p>
<p>In C++, explicit type conversion is unnecessary in most cases when C needs it (§1.3.3) and also in many cases in which earlier versions of C++ needed it (§1.3.2, §44.2.3). </p>
<p>In many programs, explicit type conversion can be completely avoided; in others, its use can be localized to a few routines.</p>
</li>
</ol>
<h4 id="11-5-4-Function-Style-Cast"><a href="#11-5-4-Function-Style-Cast" class="headerlink" title="11.5.4 Function-Style Cast"></a>11.5.4 Function-Style Cast</h4><ol>
<li> The construction of a value of type <code>T</code> from a value <code>e</code> can be expressed by the functional notation <code>T(e)</code>.</li>
</ol>
<ol start="2">
<li>Prefer <code>T&#123;v&#125;</code> conversion for well-behaved construction and the named casts (e.g., <code>static_cast</code>) for other conversions.</li>
</ol>
<h2 id="Chapter-12-Functions"><a href="#Chapter-12-Functions" class="headerlink" title="Chapter 12. Functions"></a>Chapter 12. Functions</h2><h3 id="12-1-Function-Declarations"><a href="#12-1-Function-Declarations" class="headerlink" title="12.1 Function Declarations"></a>12.1 Function Declarations</h3><h4 id="12-1-1-Why-Functions"><a href="#12-1-1-Why-Functions" class="headerlink" title="12.1.1 Why Functions?"></a>12.1.1 Why Functions?</h4><h4 id="12-1-2-Parts-of-a-Function-Declaration"><a href="#12-1-2-Parts-of-a-Function-Declaration" class="headerlink" title="12.1.2 Parts of a Function Declaration"></a>12.1.2 Parts of a Function Declaration</h4><h4 id="12-1-3-Function-Definitions"><a href="#12-1-3-Function-Definitions" class="headerlink" title="12.1.3 Function Definitions"></a>12.1.3 Function Definitions</h4><h4 id="12-1-4-Returning-Values"><a href="#12-1-4-Returning-Values" class="headerlink" title="12.1.4 Returning Values"></a>12.1.4 Returning Values</h4><h4 id="12-1-5-inline-Functions"><a href="#12-1-5-inline-Functions" class="headerlink" title="12.1.5 inline Functions"></a>12.1.5 <code>inline</code> Functions</h4><ol>
<li><p>A function can be defined to be <code>inline</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (n&lt;<span class="hljs-number">2</span>) ? <span class="hljs-number">1</span> : n∗<span class="hljs-built_in">fac</span>(n−<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>The inline specifier is a hint to the compiler that it should attempt to generate code for a call of <code>fac()</code> inline rather than laying down the code for the function once and then calling through the usual function call mechanism. </p>
<ul>
<li>A clever compiler can generate the constant <code>720</code> for a call <code>fac(6)</code>. </li>
<li>The possibility of mutually recursive inline functions, inline functions that recurse or not depending on input, etc., makes it impossible to guarantee that every call of an inline function is actually inlined.<br>The degree of cleverness of a compiler cannot be legislated, so one compiler might generate <code>720</code>, another 6∗fac(5), and yet another an un-inlined call <code>fac(6)</code>. </li>
</ul>
<p>If you want a guarantee that a value is computed at compile time, declare it <code>constexpr</code> and make sure that all functions used in its evaluation are <code>constexpr</code> (§12.1.6).</p>
</li>
</ol>
<ol start="2">
<li><p>To make inlining possible in the absence of unusually clever compilation and linking facilities, the definition – and not just the declaration – of an inline function must be in scope (§15.2).</p>
<p>An <code>inline</code> specifier does not affect the semantics of a function. </p>
<p>In particular, an <code>inline</code> function still has a unique address, and so do <code>static</code> variables (§12.1.8) of an inline function.</p>
</li>
</ol>
<ol start="3">
<li>If an inline function is defined in more than one translation unit (e.g., typically because it was defined in a header; §15.2.2), its definition in the different translation units must be identical (§15.2.3).</li>
</ol>
<h4 id="12-1-6-constexpr-Functions"><a href="#12-1-6-constexpr-Functions" class="headerlink" title="12.1.6 constexpr Functions"></a>12.1.6 <code>constexpr</code> Functions</h4><ol>
<li><p>In general, a function cannot be evaluated at compile time and therefore cannot be called in a constant expression (section 2.2.3, section 10.4).</p>
<p>By specifying a function <code>constexpr</code>, we indicate that we want it to be usable in constant expression if given constant expressions as arguments.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (n&gt;<span class="hljs-number">1</span>) ? n*<span class="hljs-built_in">fac</span>(n<span class="hljs-number">-1</span>) : <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> f9 = <span class="hljs-built_in">fac</span>(<span class="hljs-number">9</span>); <span class="hljs-comment">// must be evaluated at compile time</span><br>						   <span class="hljs-comment">// given constant expression 9 as arguments</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>When <code>constexpr</code> is used in a function definition, it means “should be usable in a constant expression when given constant expression as arguments.”</p>
<p>When used in an object definition, it means “evaluate the initializer at compile time.”</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> f5 = <span class="hljs-built_in">fac</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// may be evaluated at compile time</span><br>    <span class="hljs-type">int</span> fn = <span class="hljs-built_in">fac</span>(n); <span class="hljs-comment">// evaluated at run time (n is a variable)</span><br>    <br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> f6 = <span class="hljs-built_in">fac</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// must be evaluated at compile time</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> fnn = <span class="hljs-built_in">fac</span>(n); <span class="hljs-comment">// Error: can&#x27;t guarantee compile-time evaluation (n is a variable)</span><br>    <br>    <span class="hljs-type">char</span> a[<span class="hljs-built_in">fac</span>(<span class="hljs-number">4</span>)]; <span class="hljs-comment">// OK: array bounds must be constants and fac() is constexpr</span><br>    <span class="hljs-type">char</span> a2[<span class="hljs-built_in">fac</span>(n)]; <span class="hljs-comment">// Error: arrary bounds must be constants and n is a variable</span><br>    				 <span class="hljs-comment">//        not a constant expresion.</span><br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>To be evaluated at compile time, a function must be suitably simple:</p>
<ul>
<li>a <code>constexpr</code> function must be consist of a single <code>return</code>-statement;</li>
<li>no loops and no local variables are allowed.</li>
<li>Also, a <code>constexpr</code> function may not have side effects.<ul>
<li>That is, a <code>constexpr</code> function is a pure function.</li>
</ul>
</li>
</ul>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> glob;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">bad1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-comment">// Error: constexpr function cannot be void</span></span><br><span class="hljs-function"></span>&#123;<br>    glob = a; <span class="hljs-comment">// Error: side effect in constexpr function </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">bad2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -a; <span class="hljs-comment">// Error: if-statement in constexpr function</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">bad3</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// Error: local variable in constexpr function</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;a;++i) sum += <span class="hljs-built_in">fac</span>(i); <span class="hljs-comment">// Error: loop in constexpr function</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The rules for a <code>constexpr</code> constructor are suitably different (section 10.4.3); there only simple initialization of members are allowed.</p>
</li>
</ol>
<h4 id="12-1-7-return-Functions"><a href="#12-1-7-return-Functions" class="headerlink" title="12.1.7 [[return]] Functions"></a>12.1.7 <code>[[return]]</code> Functions</h4><h4 id="12-1-8-Local-variables"><a href="#12-1-8-Local-variables" class="headerlink" title="12.1.8 Local variables"></a>12.1.8 Local variables</h4><h3 id="12-2-Argument-Passing"><a href="#12-2-Argument-Passing" class="headerlink" title="12.2 Argument Passing"></a>12.2 Argument Passing</h3><h4 id="12-2-5-Default-Arguments"><a href="#12-2-5-Default-Arguments" class="headerlink" title="12.2.5 Default Arguments"></a>12.2.5 Default Arguments</h4><ol>
<li><p>A general function often needs more arguments than are necessary to handle simple cases.</p>
<p>In particular, functions that construct objects (constructors; section 16.2.5) often provide several options for flexibility.</p>
<p>Consider class <code>complex</code> from section 3.2.1.1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) : re&#123;r&#125;, im&#123;i&#125; &#123;&#125; <span class="hljs-comment">// construct complex from two scarlars</span><br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r) : re&#123;r&#125;, im&#123;<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// construct complex from one scalar</span><br>    <span class="hljs-built_in">complex</span>() : re&#123;<span class="hljs-number">0</span>&#125;, im&#123;<span class="hljs-number">0</span>&#125; <span class="hljs-comment">// default complex: &#123;0,0&#125;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The actions of <code>complex</code>‘s contructors are quite trivial, but logically there is something odd about having three functions (here, constructors) doing essentially the same task.</p>
</li>
<li><p>Also, for many classes, constructors do more work and the repetitiveness is common.</p>
<p>We could deal with the repetitiveness by considering one of the constructors “the real one” and forward to that (i.e., delegating constructor; section 17.4.3):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125; <span class="hljs-comment">// construct complex from two scalars</span><br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r) :complex&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// construct complex from one scalar</span><br><span class="hljs-built_in">complex</span>() :complex&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// default complex: &#123;0,0&#125;</span><br></code></pre></td></tr></table></figure>

<p>Say we wanted to add some debugging, tracing, or statistics-gathering code to <code>complex</code>; we now have a single place to do so.</p>
</li>
<li><p>However, this can be abbreviated further:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r =&#123;&#125;, <span class="hljs-type">double</span> i=&#123;&#125;) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125; <span class="hljs-comment">// construct complex from two scalars</span><br></code></pre></td></tr></table></figure>

<ul>
<li>This make it clear that if a user supplies fewer than the two arguments needed, the default is used.</li>
<li>The intent of having a single constructor plus some shorthand notation is now explicit.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>A default argument is type checked at the time of the function declaration and evaluated at the time of the call.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> def_arg;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> =def_arg)</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-type">int</span> X::def_arg = <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(X&amp; a)</span></span><br><span class="hljs-function"></span>&#123;<br>    a.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// maybe f(7)</span><br>    a.def_arg = <span class="hljs-number">9</span>;<br>    a.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// f(9)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Default arguments that can change value are most often best avoided because they introduce subtle context dependencies.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>Default arguments may be provided for trailing arguements only.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span> =<span class="hljs-number">0</span>, <span class="hljs-type">char</span>* =<span class="hljs-literal">nullptr</span>)</span></span>; <span class="hljs-comment">// OK: default argument for trailing argument (char* =nullptr)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> =<span class="hljs-number">0</span>, <span class="hljs-type">int</span> =<span class="hljs-number">0</span>, <span class="hljs-type">char</span>*)</span></span>; <span class="hljs-comment">// Error: default argument for non-trailing argument (int =0, int =0)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">int</span> =<span class="hljs-number">0</span>, <span class="hljs-type">int</span>, <span class="hljs-type">char</span>* =<span class="hljs-literal">nullptr</span>)</span></span>; <span class="hljs-comment">// Error: default argument for non-trailing argument (int =0)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>Note that the space between the <code>*</code> and the <code>=</code> are significant (<code>*=</code> is an assignment operator; section 10.3)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nasty</span><span class="hljs-params">(<span class="hljs-type">char</span>*=<span class="hljs-literal">nullptr</span>)</span></span>; <span class="hljs-comment">// syntax error</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>A default argument cannot be repeated or changed in a subsequent declaration in the same scope.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x =<span class="hljs-number">7</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> =<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">// Error: cannot repeated default argument</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> =<span class="hljs-number">8</span>)</span></span>; <span class="hljs-comment">// Error: different default argument; default argument cannot be changed subsequently</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">9</span>)</span></span>; <span class="hljs-comment">// OK: this declaration hides the outer one</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Declaraing a name in a nested scope so that the name hides a declaration of the same name in outer scope is error-prone.</p>
</li>
</ul>
</li>
</ol>
<h3 id="12-5-Pointer-to-Function"><a href="#12-5-Pointer-to-Function" class="headerlink" title="12.5 Pointer to Function"></a>12.5 Pointer to Function</h3><ol>
<li><p>Like a (data) object, the code generated for a function body is placed in memory somewhere, so it has an address. </p>
<p>We can have a pointer to a function just as we can have a pointer to an object.</p>
<ul>
<li>However, for a variety of reasons – some related to machine architecture and others to system design – <strong>a pointer to function does not allow the code to be modified</strong>. </li>
</ul>
<p><strong>There are only two things one can do to a function: call it and take its address</strong>. </p>
<p>The pointer obtained by taking the address of a function can then be used to call the function. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">(string s)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-built_in">void</span> (∗efct)(string); <span class="hljs-comment">// pointer to function taking a string argument and returning nothing</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    efct = &amp;error; <span class="hljs-comment">// efct points to error</span><br>    <span class="hljs-built_in">efct</span>(<span class="hljs-string">&quot;error&quot;</span>); <span class="hljs-comment">// call error through efct</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>The compiler will discover that <code>efct</code> is a pointer and call the function pointed to. </p>
<p>That is, dereferencing a pointer to function using <code>∗</code> is optional. </p>
<p>Similarly, using <code>&amp;</code> to get the address of a function is optional:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">void</span> (∗f1)(string) = &amp;error; <span class="hljs-comment">// OK: same as = error</span><br><span class="hljs-built_in">void</span> (∗f2)(string) = error; <span class="hljs-comment">// OK: same as = &amp;error</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f1</span>(<span class="hljs-string">&quot;Vasa&quot;</span>); <span class="hljs-comment">//OK: same as (*f1)(&quot;Vasa&quot;)</span><br>    (∗f1)(<span class="hljs-string">&quot;Mary Rose&quot;</span>); <span class="hljs-comment">// OK: as f1(&quot;Mary Rose&quot;)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Pointers to functions have argument types declared just like the functions themselves. </p>
<p>In pointer assignments, the complete function type must match exactly. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">void</span> (∗pf)(string); <span class="hljs-comment">// pointer to void(string)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(string)</span></span>; <span class="hljs-comment">// void(string)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(string)</span></span>; <span class="hljs-comment">// int(string)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-type">int</span>∗)</span></span>; <span class="hljs-comment">// void(int*)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    pf = &amp;f1; <span class="hljs-comment">// OK</span><br>    pf = &amp;f2; <span class="hljs-comment">// error : bad return type</span><br>    pf = &amp;f3; <span class="hljs-comment">// error : bad argument type</span><br>    <br>    <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;Hera&quot;</span>); <span class="hljs-comment">// OK</span><br>    <span class="hljs-built_in">pf</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//error : bad argument type</span><br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;Zeus&quot;</span>); <span class="hljs-comment">// error : void assigned to int</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>The rules for argument passing are the same for calls directly to a function and for calls to a function through a pointer.</p>
</li>
</ol>
<ol start="3">
<li><p>You can convert a pointer to function to a different pointer-to-function type, but you must cast the resulting pointer back to its original type or strange things may happen:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> P1 = <span class="hljs-built_in">int</span>(∗)(<span class="hljs-type">int</span>∗);<br><span class="hljs-keyword">using</span> P2 = <span class="hljs-built_in">void</span>(∗)(<span class="hljs-type">void</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(P1 pf)</span></span><br><span class="hljs-function"></span>&#123;<br>    P2 pf2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;P2&gt;(pf) <span class="hljs-comment">// P1 pf</span><br>    <span class="hljs-built_in">pf2</span>(); <span class="hljs-comment">//likely serious problem</span><br>    P1 pf1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;P1&gt;(pf2); <span class="hljs-comment">// convert pf2 ‘‘back again’’</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-built_in">pf1</span>(&amp;x); <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>We need the nastiest of casts, <code>reinterpret_cast</code>, to do conversion of pointer-to-function types. <ul>
<li>The reason is that the result of using a pointer to function of the wrong type is so unpredictable and system-<br>dependent. </li>
<li>For example, in the example above, the called function may write to the object pointed to by its argument, but the call <code>pf2()</code> didn’t supply any argument!</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>Pointers to functions provide a way of parameterizing algorithms. </p>
<p>Because C does not have function objects (§3.4.3) or lambda expressions (§11.4), pointers to functions are widely used as<br>function arguments in C-style code. </p>
<ul>
<li><p>For example, we can provide the comparison operation needed by a sorting function as a pointer to function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> CFT = <span class="hljs-built_in">int</span>(<span class="hljs-type">const</span> <span class="hljs-type">void</span>∗, <span class="hljs-type">const</span> <span class="hljs-type">void</span>∗);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ssort</span><span class="hljs-params">(<span class="hljs-type">void</span>∗ base, siz <span class="hljs-type">e_t</span> n, <span class="hljs-type">size_t</span> sz, CFT cmp)</span></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function">    Sor t the &quot;n&quot; elements of vector &quot;base&quot; into increasing order</span></span><br><span class="hljs-comment"><span class="hljs-function">    using the comparison function pointed to by &quot;cmp&quot;.</span></span><br><span class="hljs-comment"><span class="hljs-function">    The elements are of size &quot;sz&quot;.</span></span><br><span class="hljs-comment"><span class="hljs-function">    Shell sort (Knuth, Vol3, pg84)</span></span><br><span class="hljs-comment"><span class="hljs-function">*/</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap=n/<span class="hljs-number">2</span>; <span class="hljs-number">0</span>&lt;gap; gap/=<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=gap; i!=n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i−gap; <span class="hljs-number">0</span>&lt;=j; j−=gap) &#123;<br>                <span class="hljs-type">char</span>∗ b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>∗&gt;(base); <span class="hljs-comment">// necessar y cast</span><br>                <span class="hljs-type">char</span>∗ pj = b+j∗sz; <span class="hljs-comment">//&amp;base[j]</span><br>                <span class="hljs-type">char</span>∗ pjg = b+(j+gap)∗sz; <span class="hljs-comment">//&amp;base[j+gap]</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(pjg,pj)&lt;<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// swap base[j] and base[j+gap]:</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k!=sz; k++) &#123;<br>                        <span class="hljs-type">char</span> temp = pj[k];<br>                        pj[k] = pjg[k];<br>                        pjg[k] = temp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>&#125;    <br></code></pre></td></tr></table></figure>

<ul>
<li><p>The <code>ssort()</code> routine does not know the type of the objects it sorts, only the number of elements (the array size), the size of each element, and the function to call to perform a comparison. </p>
</li>
<li><p>The type of <code>ssort()</code> was chosen to be the same as the type of the standard C library sort routine, <code>qsort()</code>. </p>
<p>Real programs use <code>qsort()</code>, the C++ standard-library algorithm <code>sort</code> (§32.6), or a specialized sort routine.</p>
</li>
<li><p>This style of code is common in C, but it is not the most elegant way of expressing this algorithm in C++ (see §23.5, §25.3.4.1).</p>
</li>
</ul>
</li>
<li><p>Such a sort function could be used to sort a table such as this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ name;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ id;<br>    <span class="hljs-type">int</span> dept;<br>&#125;;<br><br>vector&lt;User&gt; heads = &#123;<br>    <span class="hljs-string">&quot;Ritchie D.M.&quot;</span>, <span class="hljs-string">&quot;dmr&quot;</span>, <span class="hljs-number">11271</span>,<br>    <span class="hljs-string">&quot;Sethi R.&quot;</span>, <span class="hljs-string">&quot;ravi&quot;</span>, <span class="hljs-number">11272</span>,<br>    <span class="hljs-string">&quot;Szymanski T.G.&quot;</span>, <span class="hljs-string">&quot;tgs&quot;</span>, <span class="hljs-number">11273</span>,<br>    <span class="hljs-string">&quot;Schr yer N.L.&quot;</span>, <span class="hljs-string">&quot;nls&quot;</span>, <span class="hljs-number">11274</span>,<br>    <span class="hljs-string">&quot;Schr yer N.L.&quot;</span>, <span class="hljs-string">&quot;nls&quot;</span>, <span class="hljs-number">11275</span>,<br>    <span class="hljs-string">&quot;Kernighan B.W.&quot;</span>, <span class="hljs-string">&quot;bwk&quot;</span>, <span class="hljs-number">11276</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_id</span><span class="hljs-params">(vector&lt;User&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : v)<br>        cout &lt;&lt; x.name &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; x.id &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; x.dept &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>To be able to sort, we must first define appropriate comparison functions. </p>
<p>A comparison function must return a negative value if its first argument is less than the second, zero if the arguments are<br>equal, and a positive number otherwise:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>∗ p, <span class="hljs-type">const</span> <span class="hljs-type">void</span>∗ q)</span> <span class="hljs-comment">// Compare name strings</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> User∗&gt;(p)−&gt;name,<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> User∗&gt;(q)−&gt;name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>∗ p, <span class="hljs-type">const</span> <span class="hljs-type">void</span>∗ q)</span> <span class="hljs-comment">// Compare dept numbers</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> User∗&gt;(p)−&gt;dept − <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> User∗&gt;(q)−&gt;dept;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>There is no implicit conversion of argument or return types when pointers to functions are assigned or initialized. </p>
<p>This means that you cannot avoid the ugly and error-prone casts by writing:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp3</span><span class="hljs-params">(<span class="hljs-type">const</span> User∗ p, <span class="hljs-type">const</span> User∗ q)</span> <span class="hljs-comment">// Compare ids</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p−&gt;id,q−&gt;id);<br>&#125;<br><span class="hljs-comment">// using CFT = int(const void*, const void*)</span><br><span class="hljs-comment">// no implicit conversion of argument or return types when</span><br><span class="hljs-comment">// pointers to functions are assigned or initialized</span><br></code></pre></td></tr></table></figure>

<ul>
<li>The reason is that accepting <code>cmp3</code> as an argument to <code>ssort()</code> would violate the guarantee that <code>cmp3</code> will be called with arguments of type <code>const User∗</code> (see also §15.2.6).</li>
</ul>
</li>
<li><p>This program sorts and prints:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Heads in alphabetical order:\n&quot;</span>;<br>    <span class="hljs-built_in">ssort</span>(heads,<span class="hljs-number">6</span>,<span class="hljs-built_in">sizeof</span>(User),cmp1);<br>    <span class="hljs-built_in">print_id</span>(heads);<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Heads in order of department number:\n&quot;</span>;<br>    <span class="hljs-built_in">ssort</span>(heads,<span class="hljs-number">6</span>,<span class="hljs-built_in">sizeof</span>(User),cmp2);<br>    <span class="hljs-built_in">print_id</span>(heads);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>To compare, we can equivalently write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Heads in alphabetical order:\n&quot;</span>;<br>    <span class="hljs-built_in">sort</span>(heads.<span class="hljs-built_in">begin</span>(), head.<span class="hljs-built_in">end</span>(),<br>         [](<span class="hljs-type">const</span> User&amp; x, <span class="hljs-type">const</span> User&amp; y) &#123; <span class="hljs-keyword">return</span> x.name&lt;y.name; &#125;<br>        );<br>    <span class="hljs-built_in">print_id</span>(heads);<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Heads in order of department number:\n&quot;</span>;<br>    <span class="hljs-built_in">sort</span>(heads.<span class="hljs-built_in">begin</span>(), head.<span class="hljs-built_in">end</span>(),<br>         [](<span class="hljs-type">const</span> User&amp; x, <span class="hljs-type">const</span> User&amp; y) &#123; <span class="hljs-keyword">return</span> x.dept&lt;y.dept; &#125;<br>        );<br>    <span class="hljs-built_in">print_id</span>(heads);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>No mention of sizes is needed nor any helper functions. </p>
</li>
<li><p>If the explicit use of <code>begin()</code> and <code>end()</code> is annoying, it can be eliminated by using a version of <code>sort()</code> that takes a container (§14.4.5):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sort</span>(heads,[](<span class="hljs-type">const</span> User&amp; x, <span class="hljs-type">const</span> User&amp; y) &#123; <span class="hljs-keyword">return</span> x.name&lt;y.name; &#125;);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>You can take the address of an overloaded function by assigning to or initializing a pointer to function.<br>In that case, the type of the target is used to select from the set of overloaded functions. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br><br><span class="hljs-built_in">void</span> (∗pf1)(<span class="hljs-type">int</span>) = &amp;f; <span class="hljs-comment">// void f(int)</span><br><span class="hljs-built_in">int</span> (∗pf2)(<span class="hljs-type">char</span>) = &amp;f; <span class="hljs-comment">// int f(char)</span><br><span class="hljs-built_in">void</span> (∗pf3)(<span class="hljs-type">char</span>) = &amp;f; <span class="hljs-comment">// error : no void f(char)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>It is also possible to take the address of member functions (§20.6), but a pointer to member function is quite different from a pointer to (nonmember) function.</p>
</li>
</ol>
<ol start="7">
<li><p>A pointer to a <code>noexcept</code> function can be declared <code>noexcept</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-built_in">void</span> (∗p1)(<span class="hljs-type">int</span>) = f; <span class="hljs-comment">// OK: but we throw away useful information</span><br><span class="hljs-built_in">void</span> (∗p2)(<span class="hljs-type">int</span>) <span class="hljs-keyword">noexcept</span> = f; <span class="hljs-comment">// OK: we preserve the noexcept information</span><br><span class="hljs-built_in">void</span> (∗p3)(<span class="hljs-type">int</span>) <span class="hljs-keyword">noexcept</span> = g; <span class="hljs-comment">// error : we don’t know that g doesn’t throw</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>A pointer to function must reflect the linkage of a function (§15.2.6). </p>
<p>Neither linkage specification nor <code>noexcept</code> may appear in type aliases:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> Pc = <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>); <span class="hljs-comment">// error : linkage specification in alias</span><br><span class="hljs-keyword">using</span> Pn = <span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// error : noexcept in alias</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-6-Macros"><a href="#12-6-Macros" class="headerlink" title="12.6 Macros"></a>12.6 Macros</h3><h2 id="Chapter-13-Exception-Handling"><a href="#Chapter-13-Exception-Handling" class="headerlink" title="Chapter 13. Exception Handling"></a>Chapter 13. Exception Handling</h2><h3 id="13-5-Throwing-and-Catching-Exceptions"><a href="#13-5-Throwing-and-Catching-Exceptions" class="headerlink" title="13.5 Throwing and Catching Exceptions"></a>13.5 Throwing and Catching Exceptions</h3><h4 id="13-5-1-Throwing-Exceptions"><a href="#13-5-1-Throwing-Exceptions" class="headerlink" title="13.5.1 Throwing Exceptions"></a>13.5.1 Throwing Exceptions</h4><h5 id="13-5-1-1-noexcept-Functions"><a href="#13-5-1-1-noexcept-Functions" class="headerlink" title="13.5.1.1 noexcept Functions"></a>13.5.1.1 <code>noexcept</code> Functions</h5><h5 id="13-5-1-2-The-noexcept-Operator"><a href="#13-5-1-2-The-noexcept-Operator" class="headerlink" title="13.5.1.2 The noexcept Operator"></a>13.5.1.2 The <code>noexcept</code> Operator</h5><ol>
<li><p>It is possible to declare a function to be conditionally <code>noexcept</code>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_fct</span><span class="hljs-params">(T&amp; x)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(Is_pod&lt;T&gt;())</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>noexcept(Is_pod&lt;T&gt;())</code> means that <code>my_fct</code> may not throw if the predicate <code>Is_pod&lt;T&gt;()</code> is true but may throw if it is <code>false</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="13-6-A-vector-implementation"><a href="#13-6-A-vector-implementation" class="headerlink" title="13.6 A vector implementation"></a>13.6 A <code>vector</code> implementation</h3><h4 id="13-6-1-A-Simple-vector"><a href="#13-6-1-A-Simple-vector" class="headerlink" title="13.6.1 A Simple vector"></a>13.6.1 A Simple <code>vector</code></h4><ol>
<li><p>A typical implementation of <code>vector</code> (section 4.4.1, section 31.4) will consist of a <strong>handle</strong> holding pointers to the first element, one-past-the-last element, and one-past-the-last allocated space (section 31.2.1) (or the equivalent information represented as a pointer plus offsets):</p>
<ul>
<li><img src="image-20230124202038535.png" srcset="/img/loading.gif" lazyload alt="image-20230124202038535"></li>
</ul>
<p>In addition, it holds an allocator (here, <code>alloc</code>), from which the <code>vector</code> can acquire memory for its elements.</p>
<ul>
<li>The default allocator (section 34.4.1) uses <code>new</code> and <code>delete</code> to acquire and release memory.</li>
</ul>
</li>
<li><p>Here is a declaration of <code>vector</code> simplified to present only what is needed to discuss exception safety and avoidance of resource leaks:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> = allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector&#123;<br><span class="hljs-keyword">private</span>:<br>    T* elem; <span class="hljs-comment">// start of allocation</span><br>    T* space; <span class="hljs-comment">// end of element sequence, start of space allocated for possible expression</span><br>    T* last; <span class="hljs-comment">// end of allocated space</span><br>    A alloc; <span class="hljs-comment">// allocator</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> size_type = <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// type used for vector sizes</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">vector</span><span class="hljs-params">(size_type n, <span class="hljs-type">const</span> T&amp; val = T(), <span class="hljs-type">const</span> A&amp; = A())</span></span>;<br><br>    <span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&amp; a); <span class="hljs-comment">// copy constructor</span><br>    vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&amp; a); <span class="hljs-comment">// copy assignment</span><br><br>    <span class="hljs-built_in">vector</span>(vector&amp;&amp; a); <span class="hljs-comment">// move constructor</span><br>    vector&amp; <span class="hljs-keyword">operator</span>=(vector&amp;&amp; a); <span class="hljs-comment">// move assignment</span><br><br>    ~<span class="hljs-built_in">vector</span>();<br><br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> space-elem;&#125;<br>    <span class="hljs-function">size_type <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> last-elem;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(size_type n)</span></span>; <span class="hljs-comment">// increase capacity to n</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type n, <span class="hljs-type">const</span> T&amp; = &#123;&#125;)</span></span>; <span class="hljs-comment">// increase size to n</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>; <span class="hljs-comment">// add an element at the end</span><br><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="Chapter-14-Namespaces"><a href="#Chapter-14-Namespaces" class="headerlink" title="Chapter 14. Namespaces"></a>Chapter 14. Namespaces</h2><h3 id="14-3-Modularization-and-Interfaces"><a href="#14-3-Modularization-and-Interfaces" class="headerlink" title="14.3 Modularization and Interfaces"></a>14.3 Modularization and Interfaces</h3><h4 id="14-3-1-Namespaces-as-Modules"><a href="#14-3-1-Namespaces-as-Modules" class="headerlink" title="14.3.1 Namespaces as Modules"></a>14.3.1 Namespaces as Modules</h4><ol>
<li><p>A namespace is a mechanism for expressing logical grouping.</p>
<p>That is, if some declarations logically belong together according to some criteria, they can be put in a common namespace to express that fact.</p>
</li>
</ol>
<h4 id="14-2-4-Argument-Dependent-Lookup"><a href="#14-2-4-Argument-Dependent-Lookup" class="headerlink" title="14.2.4 Argument-Dependent Lookup"></a>14.2.4 Argument-Dependent Lookup</h4><ol>
<li>When a class member invokes a named function, other members of the same class and its base classes are preferred over functions potentially found based on argument types (operators follow a different rule; Section 18.5)</li>
</ol>
<h2 id="Chapter-15-Source-Files-and-Programs"><a href="#Chapter-15-Source-Files-and-Programs" class="headerlink" title="Chapter 15. Source Files and Programs"></a>Chapter 15. Source Files and Programs</h2><h3 id="15-2-Linkage"><a href="#15-2-Linkage" class="headerlink" title="15.2 Linkage"></a>15.2 Linkage</h3><ol>
<li><p>Names of functions, classes, templates, variables, namespaces, enumerations, and enumberators must be used consistently across all translation units unless they are explicitly specified to be local.</p>
<p>It is the programmer’s task to ensure that every namespace, class, function, etc., is properly declared in every translation unit in which it appears and that all declarations referring to the same entity are consistent.</p>
<p>- </p>
</li>
</ol>
<h3 id="15-4-Programs"><a href="#15-4-Programs" class="headerlink" title="15.4 Programs"></a>15.4 Programs</h3><h4 id="15-4-3-Program-Termination"><a href="#15-4-3-Program-Termination" class="headerlink" title="15.4.3 Program Termination"></a>15.4.3 Program Termination</h4><h1 id="The-C-Programming-Language-Part-Ⅲ-Abstraction-Mechanisms"><a href="#The-C-Programming-Language-Part-Ⅲ-Abstraction-Mechanisms" class="headerlink" title="The C++ Programming Language  Part Ⅲ : Abstraction Mechanisms"></a>The C++ Programming Language  Part Ⅲ : Abstraction Mechanisms</h1><h2 id="Chapter-16-Classes"><a href="#Chapter-16-Classes" class="headerlink" title="Chapter 16. Classes"></a>Chapter 16. Classes</h2><h3 id="16-2-Class-Basics"><a href="#16-2-Class-Basics" class="headerlink" title="16.2 Class Basics"></a>16.2 Class Basics</h3><h4 id="16-2-1-Member-Functions"><a href="#16-2-1-Member-Functions" class="headerlink" title="16.2.1 Member Functions"></a>16.2.1 Member Functions</h4><ol>
<li><p>Consider implementing the concept of a date using a <code>struct</code> (§2.3.1, §8.2) to define the representation of a <code>Date</code> and a set of functions for manipulating variables of this type:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Date</span> &#123; <span class="hljs-comment">// representation</span><br>    <span class="hljs-type">int</span> d, m, y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_date</span><span class="hljs-params">(Date&amp; d, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// initialize d</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_year</span><span class="hljs-params">(Date&amp; d, <span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n years to d</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_month</span><span class="hljs-params">(Date&amp; d, <span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n months to d</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_day</span><span class="hljs-params">(Date&amp; d, <span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n days to d</span><br></code></pre></td></tr></table></figure>

<p>There is no explicit connection between the data type, <code>Date</code>, and these functions. </p>
<p>Such a connection can be established by declaring the functions as members:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Date</span> &#123;<br>    <span class="hljs-type">int</span> d, m, y;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> dd, <span class="hljs-type">int</span> mm, <span class="hljs-type">int</span> yy)</span></span>; <span class="hljs-comment">// initialize</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_year</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n years</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_month</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n months</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_day</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n days</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>Functions declared within a class definition (a <code>struct</code> is a kind of class; §16.2.4) are called <em><strong>member functions</strong></em> and can be invoked only for a specific variable of the appropriate type using the standard syntax for structure member access (§8.2). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">Date my_bir thday;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Date today;<br>    <br>    today.<span class="hljs-built_in">init</span>(<span class="hljs-number">16</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1996</span>);<br>    my_birthday.<span class="hljs-built_in">init</span>(<span class="hljs-number">30</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1950</span>);<br>    <br>    Date tomorrow = today;<br>    tomorrow.<span class="hljs-built_in">add_day</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>Because different structures can have member functions with the same name, we must specify the structure name when defining a member function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::init</span><span class="hljs-params">(<span class="hljs-type">int</span> dd, <span class="hljs-type">int</span> mm, <span class="hljs-type">int</span> yy)</span></span><br><span class="hljs-function"></span>&#123;<br>    d = dd;<br>    m = mm;<br>    y = yy;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="4">
<li><p>In a member function, member names can be used without explicit reference to an object. </p>
<ul>
<li><p>In that case, the name refers to that member of the object for which the function was invoked. </p>
<ul>
<li><p>For example, when <code>Date::init()</code> is invoked for <code>today</code>, <code>m=mm</code> assigns to <code>today.m</code>. </p>
</li>
<li><p>On the other hand, when <code>Date::init()</code> is invoked for <code>my_birthday</code>, <code>m=mm</code> assigns to <code>my_birthday.m</code>. </p>
</li>
</ul>
</li>
</ul>
<p>A class member function ‘‘knows’’ for which object it was invoked. </p>
<p>But see §16.2.12 for the notion of a <code>static</code> member.</p>
</li>
</ol>
<h4 id="16-2-5-Constructors"><a href="#16-2-5-Constructors" class="headerlink" title="16.2.5 Constructors"></a>16.2.5 Constructors</h4><h4 id="16-2-6-explicit-Constructor"><a href="#16-2-6-explicit-Constructor" class="headerlink" title="16.2.6 explicit Constructor"></a>16.2.6 <code>explicit</code> Constructor</h4><ol>
<li><p>By default, <strong>a constructor invoked by a single argument</strong> acts as <strong>an implicit conversion</strong> from its argument type to its type.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex&lt;<span class="hljs-type">double</span>&gt; d&#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// d==&#123;1,0&#125; section 5.6.2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Such implicit conversions can be extremely useful.</li>
<li>Complex numbers are an example; if we leave out the imaginary part, we get a complex number on the real axis. That’s exactly what mathematics requires.</li>
</ul>
<p>However, in many cases, such conversions can be a significant source of confusion and errors.</p>
<p>Consider <code>Date</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_fct</span><span class="hljs-params">(Date d)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Date d&#123;<span class="hljs-number">15</span>&#125;; <span class="hljs-comment">// plausible: x becomes &#123;15, today.m, today.y&#125;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">my_fct</span>(<span class="hljs-number">15</span>); <span class="hljs-comment">// obscure</span><br>    d = <span class="hljs-number">15</span>; <span class="hljs-comment">// obscure</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>A constructor declared with the keyword <code>explicit</code> can only be used for initialization and explicit conversions.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br>    <span class="hljs-type">int</span> d, m, y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-type">int</span> dd =<span class="hljs-number">0</span>, <span class="hljs-type">int</span> mm =<span class="hljs-number">0</span>, <span class="hljs-type">int</span> yy =<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br>Date d1&#123;<span class="hljs-number">15</span>&#125;; <span class="hljs-comment">// OK: considered explicit</span><br>Date d2 = Date&#123;<span class="hljs-number">15</span>&#125;; <span class="hljs-comment">// OK: explicit</span><br>Date d3 = &#123;<span class="hljs-number">15</span>&#125;; <span class="hljs-comment">// Error: = initialization does not do implicit conversions</span><br>Date d4 = <span class="hljs-number">15</span>; <span class="hljs-comment">// ErrorP: = initialization does not do implicit conversions</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">my_fct</span>(<span class="hljs-number">15</span>); <span class="hljs-comment">// Error: argument passing does not do implicit conversions</span><br>    <span class="hljs-built_in">my_fct</span>(&#123;<span class="hljs-number">15</span>&#125;); <span class="hljs-comment">// Error: argument passing does not do implicit conversions</span><br>    <span class="hljs-built_in">my_fct</span>(Date&#123;<span class="hljs-number">15</span>&#125;); <span class="hljs-comment">// OK: explicit</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>An initialization with an <code>=</code> is consider a <em><strong>copy initialization</strong></em>.</p>
<ul>
<li><p>In principle, a copy of the initializer is placed into the initialized object.</p>
</li>
<li><p>However, such copy may be optimized away (elided), and a move operation (section 3.3.2, section 17.5.2) may be used if the initializer is an rvalue (section 6.4.1)</p>
</li>
</ul>
<p>Leaving out the <code>=</code> makes the initialization explicit. </p>
<p>Explicit initialization is known as <em><strong>direct initialization</strong></em>.</p>
</li>
</ol>
<ol start="3">
<li><p>By default, declare a constructor that can be used with a single argument <code>explicit</code>. </p>
<p>You need a good reason not to do so (as for <code>complex</code>).</p>
<ul>
<li>If you define an implicit construcotr, it is best to document your reason or a maintainer may suspect that you were forgetful (or ignorant).</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>If a constructor is declared <code>explicit</code> and defined outside the class, that <code>explicit</code> cannot be repeated:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br>    <span class="hljs-type">int</span> d, m, y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-type">int</span> dd)</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br>Date::<span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> dd) &#123;<span class="hljs-comment">/*...*/</span>&#125; <span class="hljs-comment">// OK</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Date::Date</span><span class="hljs-params">(<span class="hljs-type">int</span> dd)</span> </span>&#123;<span class="hljs-comment">/*...*/</span>&#125; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="5">
<li><p>Most examples where <code>explicit</code> is important involve a single constructor argument.</p>
<p>However, <code>explicit</code> can also be useful for constructors with zero or more that one argument. </p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">X</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br><br>X x1 = &#123;&#125;; <span class="hljs-comment">// Error: implicit</span><br>X x2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Error: implicit</span><br><br>X x3&#123;&#125;; <span class="hljs-comment">// OK: explicit</span><br>X x4&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// OK: explicit</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(X)</span></span>;<br><br><span class="hljs-type">int</span> i1 = <span class="hljs-built_in">f</span>(&#123;&#125;); <span class="hljs-comment">// Error: implicit</span><br><span class="hljs-type">int</span> i2 = <span class="hljs-built_in">f</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;); <span class="hljs-comment">// Error: implicit</span><br><br><span class="hljs-type">int</span> i3 = <span class="hljs-built_in">f</span>(X&#123;&#125;); <span class="hljs-comment">// OK: explicit</span><br><span class="hljs-type">int</span> i4 = <span class="hljs-built_in">f</span>(X&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;); <span class="hljs-comment">// OK: explicit</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="6">
<li>The distinction between direct and copy initialization is maintained for list initialization (section 17.3.4.3).</li>
</ol>
<h4 id="16-2-9-Mutability"><a href="#16-2-9-Mutability" class="headerlink" title="16.2.9 Mutability"></a>16.2.9 Mutability</h4><ol>
<li><p>We can define a named object as a constant or as a variable. </p>
<p>In other words, a name can refer to an object that holds an <em><strong>immutable</strong></em> or a <em><strong>mutable</strong></em> value. </p>
<p>Since the precise terminology can be a bit clumsy, we end up referring to some variables as being constant or briefer still to <code>const</code> variables.</p>
<ul>
<li>However odd that may sound to a native English speaker, the concept is useful and deeply embedded in the C++ type system.</li>
</ul>
<p>Systematic use of immutable objects leads to more comprehensible code, to more errors being found early, and sometimes to improved performance. </p>
<p>In particular, immutability is a most useful property in a multi-threaded program (§5.3, Chapter 41).</p>
</li>
</ol>
<ol start="2">
<li><p>To be useful beyond the definition of simple constants of built-in types, <strong>we must be able to define functions that operate on <code>const</code> objects of user-defined types</strong>. </p>
<ul>
<li><p>For freestanding functions that means functions that take <code>const T&amp;</code> arguments. </p>
</li>
<li><p>For classes it means that we must be able to define member functions that work on <code>const</code> objects.</p>
</li>
</ul>
</li>
</ol>
<h5 id="16-2-9-1-Constant"><a href="#16-2-9-1-Constant" class="headerlink" title="16.2.9.1 Constant"></a>16.2.9.1 Constant</h5><ol start="3">
<li><p>The <code>Date</code> as defined so far provides member functions for giving a <code>Date</code> a value. </p>
<p>Unfortunately, we didn’t provide a way of examining the value of a <code>Date</code>. </p>
<ul>
<li><p>This problem can easily be remedied by adding functions for reading the day, month, and year:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br>    <span class="hljs-type">int</span> d, m, y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> d; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_year</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n years</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>The <code>const</code> after the (empty) argument list in the function declarations indicates that these functions do not modify the state of a Date.</strong></p>
</li>
<li><p>Naturally, the compiler will catch accidental attempts to violate this promise. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ++y; <span class="hljs-comment">// error : attempt to change member value in const function</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>When a <code>const</code> member function is defined outside its class, the const suffix is required:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::year</span><span class="hljs-params">()</span> <span class="hljs-comment">// error : const missing in member function type</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>In other words, <code>const</code> is part of the type of <code>Date::day()</code>, <code>Date::month()</code>, and <code>Date::year()</code>.</p>
</li>
</ol>
<ol start="5">
<li><p><strong>A <code>const</code> member function can be invoked for both <code>const</code> and non-<code>const</code> objects</strong>, whereas a <strong>non-<code>const</code> member function can be invoked only for non-<code>const</code> objects</strong>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Date&amp; d, <span class="hljs-type">const</span> Date&amp; cd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = d.<span class="hljs-built_in">year</span>(); <span class="hljs-comment">// OK</span><br>    d.<span class="hljs-built_in">add_year</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// OK</span><br>    <br>    <span class="hljs-type">int</span> j = cd.<span class="hljs-built_in">year</span>(); <span class="hljs-comment">// OK</span><br>    cd.<span class="hljs-built_in">add_year</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// error : cannot change value of a const Date</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="16-2-9-2-Physical-and-Logical-Constness"><a href="#16-2-9-2-Physical-and-Logical-Constness" class="headerlink" title="16.2.9.2 Physical and Logical Constness"></a>16.2.9.2 Physical and Logical Constness</h5><ol start="6">
<li><p>Occasionally, a member function is logically <code>const</code>, but it still needs to change the value of a member. </p>
<p>That is, to a user, <strong>the function appears not to change the state of its object, but some detail that the user cannot directly observe is updated</strong>. </p>
<p>This is often called <em><strong>logical constness</strong></em>. </p>
<ul>
<li><p>For example, the <code>Date</code> class might have a function returning a string representation. </p>
<ul>
<li><p>Constructing this representation could be a relatively expensive operation. </p>
</li>
<li><p>Therefore, it would make sense to keep a copy so that repeated requests would simply return the copy, unless the <code>Date</code>’s value had been changed.</p>
</li>
</ul>
</li>
</ul>
<p>Caching values like that is more common for more complicated data structures, but let’s see how it can be achieved for a Date:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">string <span class="hljs-title">string_rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// string representation</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> cache_valid;<br>    string cache;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute_cache_value</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// fill cache</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>From a user’s point of view, <code>string_rep</code> doesn’t change the state of its Date, so it clearly should be a <code>const</code> member function. </li>
<li>On the other hand, the <code>cache</code> and <code>cache_valid</code> members must change occasionally for the design to make sense.</li>
</ul>
</li>
</ol>
<ol start="7">
<li><p>Such problems could be solved through brute force using a cast, for example, a <code>const_cast</code> (§11.5.2). </p>
<p>However, there are also reasonably elegant solutions that do not involve messing with type rules.</p>
</li>
</ol>
<h5 id="16-2-9-3-mutable"><a href="#16-2-9-3-mutable" class="headerlink" title="16.2.9.3 mutable"></a>16.2.9.3 <code>mutable</code></h5><ol start="8">
<li><p>We can define a member of a class to be <code>mutable</code>, meaning that it can be modified even in a <code>const</code> object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">string <span class="hljs-title">string_rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// string representation</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> cache_valid; <span class="hljs-comment">// cache_valid is mutable</span><br>    <span class="hljs-keyword">mutable</span> string cache; <span class="hljs-comment">// cache is mutable</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute_cache_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// fill (mutable) cache</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Now we can define <code>string_rep()</code> in the obvious way:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">Date::string_rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!cache_valid) &#123;<br>        <span class="hljs-built_in">compute_cache_value</span>();<br>        cache_valid = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cache;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>member function <code>string_rep()</code> is const, but since <code>cache_valid</code> and <code>cache</code> is declared <code>mutable</code>, so we can define <code>string_rep()</code> in the common usual way like non-<code>const</code> function.</li>
</ul>
<p>We can now use <code>string_rep()</code> for both <code>const</code> and non-<code>const</code> objects.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Date d, <span class="hljs-type">const</span> Date cd)</span></span><br><span class="hljs-function"></span>&#123;<br>    string s1 = d.<span class="hljs-built_in">string_rep</span>();<br>    string s2 = cd.<span class="hljs-built_in">string_rep</span>(); <span class="hljs-comment">// OK!</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="16-2-9-4-Mutability-through-Indirection"><a href="#16-2-9-4-Mutability-through-Indirection" class="headerlink" title="16.2.9.4 Mutability through Indirection"></a>16.2.9.4 Mutability through Indirection</h5><ol start="9">
<li><p>Declaring a member mutable is most appropriate when only a small part of a representation of a small object is allowed to change. </p>
<p>More complicated cases are often better handled by placing the changing data in a separate object and accessing it indirectly.</p>
<ul>
<li><p>If that technique is used, the string-with-cache example becomes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cache</span> &#123;<br>    <span class="hljs-type">bool</span> valid;<br>    string rep;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function">string <span class="hljs-title">string_rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// string representation</span><br><span class="hljs-keyword">private</span>:<br>    cache∗ c; <span class="hljs-comment">// initialize in constructor</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute_cache_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// fill what cache refers to</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function">string <span class="hljs-title">Date::string_rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!c−&gt;valid) &#123;<br>        <span class="hljs-built_in">compute_cache_value</span>();<br>        c−&gt;valid = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c−&gt;rep;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The programming techniques that support a cache generalize to various forms of lazy evaluation.</p>
</li>
</ul>
</li>
</ol>
<ol start="10">
<li><p>Note that <strong><code>const</code> does not apply (transitively) to objects accessed through pointers or references.</strong></p>
<ul>
<li><p>The human reader may consider such an object as ‘‘a kind of subobject,’’ but the compiler does not know such pointers or references to be any different from any others. </p>
</li>
<li><p>That is, <strong>a member pointer does not have any special semantics that distinguish it from other pointers</strong>.</p>
</li>
</ul>
</li>
</ol>
<h4 id="16-2-12-static-Members"><a href="#16-2-12-static-Members" class="headerlink" title="16.2.12 static Members"></a>16.2.12 <code>static</code> Members</h4><ol>
<li><p>The convenience of a default value for <code>Date</code>s was bought at the cost of a significant hidden problem.</p>
<ul>
<li><p>Our <code>Date</code> class became dependent on the global variable <code>today</code>. </p>
</li>
<li><p>This <code>Date</code> class can be used only in a context in which <code>today</code> is defined and correctly used by every piece of code. </p>
</li>
</ul>
<p>This is the kind of constraint that causes a class to be useless outside the context in which it was first written. </p>
<ul>
<li><p>Users get too many unpleasant surprises trying to use such context-dependent classes, and maintenance becomes messy. </p>
</li>
<li><p>Maybe ‘‘just one little global variable’’ isn’t too unmanageable, but that style leads to code that is useless except to its original programmer. </p>
</li>
</ul>
<p>It should be avoided.</p>
</li>
</ol>
<ol start="2">
<li><p>Fortunately, we can get the convenience without the encumbrance of a publicly accessible global variable. </p>
<p><strong>A variable that is part of a class, yet is not part of an object of that class</strong>, is called a <em><strong><code>static</code> member</strong></em>. </p>
<p>There is exactly one copy of a <code>static</code> member instead of one copy per object, as for ordinary non-<code>static</code> members (§6.4.2). </p>
<p>Similarly, <strong>a function that needs access to members of a class, yet doesn’t need to be invoked for a particular object</strong>, is called a <em><strong><code>static</code> member function</strong></em>.</p>
</li>
</ol>
<ol start="3">
<li><p>Here is a redesign that preserves the semantics of default constructor values for <code>Date</code> without the problems stemming from reliance on a global:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br>    <span class="hljs-type">int</span> d, m, y;<br>    <span class="hljs-type">static</span> Date default_date;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> dd =<span class="hljs-number">0</span>, <span class="hljs-type">int</span> mm =<span class="hljs-number">0</span>, <span class="hljs-type">int</span> yy =<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">set_default</span><span class="hljs-params">(<span class="hljs-type">int</span> dd, <span class="hljs-type">int</span> mm, <span class="hljs-type">int</span> yy)</span></span>; <span class="hljs-comment">// set default_date to Date(dd,mm,yy)</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>We can now define the <code>Date</code> constructor to use <code>default_date</code> like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">Date::<span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> dd, <span class="hljs-type">int</span> mm, <span class="hljs-type">int</span> yy)<br>&#123;<br>    d = dd ? dd : default_date.d;<br>    m = mm ? mm : default_date.m;<br>    y = yy ? yy : default_date.y;<br>    <span class="hljs-comment">// ... check that the Date is valid ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Using <code>set_default()</code>, we can change the default date when appropriate. </p>
<p><strong>A <code>static</code> member can be referred to like any other member.</strong> </p>
<p>In addition, <strong>a <code>static</code> member can be referred to without mentioning an object</strong>. </p>
<p>Instead, <strong>its name is qualified by the name of its class</strong>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Date::<span class="hljs-built_in">set_default</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1945</span>); <span class="hljs-comment">// call Date’s static member set_default()</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>If used, a <code>static</code> member – a function or data member – must be defined somewhere</strong>. </p>
<p><strong>The keyword <code>static</code> is not repeated in the definition of a <code>static</code> member</strong>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Date Date::default_date &#123;<span class="hljs-number">16</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1770</span>&#125;; <span class="hljs-comment">// definition of Date::default_date</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::set_default</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> y)</span> <span class="hljs-comment">// definition of Date::set_default</span></span><br><span class="hljs-function"></span>&#123;<br>    default_date = &#123;d,m,y&#125;; <span class="hljs-comment">// assign new value to default_date</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Now, the default value is Beethoven’s birth date – until someone decides otherwise.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>Note that <code>Date&#123;&#125;</code> serves as a notation for the value of <code>Date::default_date</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">Date copy_of_default_date = Date&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Date)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(Date&#123;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Consequently, we don’t need a separate function for reading the default date. </p>
<p>Furthermore, where the target type is unambiguously a <code>Date</code>, plain <code>&#123;&#125;</code> is sufficient. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(Date)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(Date)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f1</span>(&#123;&#125;); <span class="hljs-comment">// OK: equivalent to f1(Date&#123;&#125;)</span><br>    <br>    <span class="hljs-built_in">f2</span>(&#123;&#125;): <span class="hljs-comment">// error : ambiguous: f2(int) or f2(Date)?</span><br>    <span class="hljs-built_in">f2</span>(Date&#123;&#125;); <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>In multi-threaded code, static data members require some kind of locking or access discipline to avoid race conditions (§5.3.4, §41.2.4). </p>
<p>Since multi-threading is now very common, it is unfortunate that use of <code>static</code> data members was quite popular in older code. </p>
<ul>
<li>Older code tends to use <code>static</code> members in ways that imply race conditions.</li>
</ul>
</li>
</ol>
<h3 id="16-3-Concrete-Classes"><a href="#16-3-Concrete-Classes" class="headerlink" title="16.3 Concrete Classes"></a>16.3 Concrete Classes</h3><ol>
<li>A class is called <em>concrete</em> (or <em>a concrete class</em>) if its representation is part of its definition.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> Chrono&#123;<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Month</span> &#123;jan=<span class="hljs-number">1</span>,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec&#125;;<br>  <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br>    <span class="hljs-keyword">public</span>: <span class="hljs-comment">// public interface</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bad_date</span>&#123;&#125;; <span class="hljs-comment">// exception class</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-type">int</span> dd=&#123;&#125;, Month mm=&#123;&#125;, <span class="hljs-type">int</span> yy=&#123;&#125;)</span></span>; <span class="hljs-comment">// &#123;&#125; means &quot;pick a default&quot;</span><br>      <br>        <span class="hljs-comment">// nonmodifying functions for examining the Date:</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function">Month <span class="hljs-title">month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>      <br>        <span class="hljs-function">string <span class="hljs-title">string_rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// string representation</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">char_rep</span><span class="hljs-params">(<span class="hljs-type">char</span> s[], <span class="hljs-type">int</span> max)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// C-style string representation</span><br>      <br>        <span class="hljs-comment">// (modifying) functions for changing the Date:</span><br>        <span class="hljs-function">Date&amp; <span class="hljs-title">add_year</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n years</span><br>        <span class="hljs-function">Date&amp; <span class="hljs-title">add_month</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n months</span><br>        <span class="hljs-function">Date&amp; <span class="hljs-title">add_day</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n days</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_valid</span><span class="hljs-params">()</span>: // check if this Date representation is a date</span><br><span class="hljs-function">        int d, m, y;</span> <span class="hljs-comment">// representation</span><br>    &#125;;<br>  <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_date</span><span class="hljs-params">(<span class="hljs-type">int</span> d, Month m, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// true for a valid date</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_leapyear</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// true if y is a leap year</span><br>  <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Date&amp; a, <span class="hljs-type">const</span> Date&amp; b);<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Date&amp;a, <span class="hljs-type">const</span> Date&amp; b);<br>  <br>    <span class="hljs-function"><span class="hljs-type">const</span> Date&amp; <span class="hljs-title">default_date</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// the default date</span><br>  <br>    ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Date&amp; d); <span class="hljs-comment">// print d to os</span><br>    istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Date&amp; d); <span class="hljs-comment">// read Date from is into d</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Chapter-17-Construction-Cleanup-Copy-and-Move"><a href="#Chapter-17-Construction-Cleanup-Copy-and-Move" class="headerlink" title="Chapter 17. Construction, Cleanup, Copy, and Move"></a>Chapter 17. Construction, Cleanup, Copy, and Move</h2><h3 id="17-2-Constructors-and-Destructors"><a href="#17-2-Constructors-and-Destructors" class="headerlink" title="17.2 Constructors and Destructors"></a>17.2 Constructors and Destructors</h3><h4 id="17-2-3-Base-and-Member-Destructors"><a href="#17-2-3-Base-and-Member-Destructors" class="headerlink" title="17.2.3 Base and Member Destructors"></a>17.2.3 Base and Member Destructors</h4><ol>
<li><p>Constructors and destructors interact correctly with class hierarchies (section 3.2.4, Chapter 20).</p>
<ul>
<li><strong>A constructor builds a class object “from the bottom up”</strong>:<ul>
<li>first, the constructor invokes its base class constructors,</li>
<li>then, it invokes the member constructors, and</li>
<li>finally, it executes its own body.</li>
</ul>
</li>
<li><strong>A destructor “tears down” an object in the reverse order</strong>:<ul>
<li>first, the destructor executes its own body,</li>
<li>then, it invokes its member destructors, and</li>
<li>finally, it invokes its base class destructors.</li>
</ul>
</li>
</ul>
<p>In particular, a <code>virtual</code> base is constructed before any base that might use it and destroyed after all such bases (section 21.3.5.1).</p>
<ul>
<li><p>This ordering ensures that a base or a member is not used before it has been initialized or used after it has been destroyed.</p>
</li>
<li><p>The programmer can defeat this simple and essential rule, but only through deliberate circumvention involving passing pointers to uninitialized variables as arguments.</p>
<p>Doing so violates language rules and the results are usually disastrous.</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>Constructors execute member and base constructors in declaration order (not the order of initializers)</strong>:<ul>
<li>if two constructors used a different order, the destructor could not (without serious overhead) guarantee to destroy in the reverse order of construction. See also section 17.4.</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>If a class is used so that a default construct is needed, and if the class does not have other constructors, the compiler will try to generate a default constructor. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span> &#123;<br>    string s;<br>&#125;;<br><br>S1 x; <span class="hljs-comment">// OK: x.s is initialized to &quot;&quot;</span><br></code></pre></td></tr></table></figure>

<p>Similarly, memberwise initialization can be used if initializer are needed. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span>&#123;<span class="hljs-built_in">X</span>(<span class="hljs-type">int</span>);&#125;; <span class="hljs-comment">// definition</span><br><br>Struct S2 &#123;<br>    X x;<br>&#125;;<br><br>S2 x1; <span class="hljs-comment">// Error: no default constructor</span><br>S2 x2&#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// OK: x2.x is initialized wiht 1</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="17-2-5-virtual-Destructors"><a href="#17-2-5-virtual-Destructors" class="headerlink" title="17.2.5 virtual Destructors"></a>17.2.5 <code>virtual</code> Destructors</h4><ol>
<li><p>A destructors can be declared to be <code>virtual</code>, and usually should be for a class with a virtual function.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">Circle</span>(); <span class="hljs-comment">// overrides ~Shape()</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>The reason we need a <code>virtual</code> destructor is that an object usually manipulated through the interface provided by a base class is often also <code>delete</code>d through that interface:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">(Shape* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// invoke the appropriate draw()</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// invoke the appropriate destructor</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Had <code>Shape</code>‘s destructor not beed <code>virtual</code> that <code>delete</code> would have failed to invoke the appropriate derived class destructor (e.g., ~Circle()).</p>
<p>That failure would cause the resources owned by the deleted object (if any) to be leaked.</p>
</li>
</ul>
</li>
</ol>
<h3 id="17-3-Class-Object-Initialization"><a href="#17-3-Class-Object-Initialization" class="headerlink" title="17.3 Class Object Initialization"></a>17.3 Class Object Initialization</h3><h4 id="17-3-1-Initialization-Without-Constructors"><a href="#17-3-1-Initialization-Without-Constructors" class="headerlink" title="17.3.1 Initialization Without Constructors"></a>17.3.1 Initialization Without Constructors</h4><ol>
<li><p>We cannot define a constructor for a built-in type, yet we can initialize it with a value of suitable type.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">char</span>* p&#123;<span class="hljs-literal">nullptr</span>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>Similarly, we can initialize objects of a class for which we have not defined a constructor using</strong> </p>
<ul>
<li>memberwise initialization</li>
<li>copy initialization, or</li>
<li>default initialization (without an initializer or with an empty initializer list).</li>
</ul>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Work</span> &#123;<br>    string author;<br>    string name;<br>    <span class="hljs-type">int</span> year;<br>&#125;;<br><br>Work s9&#123; <span class="hljs-string">&quot;Beethoven&quot;</span>,<br>       <span class="hljs-string">&quot;Symphony No. 9 in D minor, Op. 125; Choral&quot;</span>,<br>       <span class="hljs-number">1824</span><br>       &#125;; <span class="hljs-comment">// memberwise initialization</span><br><br>Work currently_playing&#123;s9&#125;; <span class="hljs-comment">// copy initialization</span><br>Work none&#123;&#125;; <span class="hljs-comment">// default initialization</span><br></code></pre></td></tr></table></figure>

<ul>
<li>The three members of <code>currently_playing</code> are copies of those of <code>s9</code>.</li>
</ul>
<p><strong>The default initialization of using <code>&#123;&#125;</code> is defined as initialization of each member by <code>&#123;&#125;</code>.</strong></p>
<ul>
<li>So, <code>none</code> is initialized to <code>&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</code>, which is <code>&#123;&quot;&quot;,&quot;&quot;,0&#125;</code> (section 17.3.3).</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Where no constructor requiring arguments is declared, it is also possible to <strong>leave out the initializer completely</strong>.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">Work alpha; <span class="hljs-comment">// static variable (object declared in global)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Work beta; <span class="hljs-comment">// local variable</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>For this, the rules are not as clean as we might like.</p>
<ul>
<li>For <strong>statically allocated objects</strong> (section 6.4.2), the rules are exactly as if you had used <code>&#123;&#125;</code>, so the value of <code>alpha</code> is <code>&#123;&quot;&quot;,&quot;&quot;,0&#125;</code>.</li>
<li>However, for <strong>local variables</strong> and <strong>free-store</strong> objects, the <strong>default initialization</strong> is done <strong>only for members of class type</strong>, and <strong>members of built-in type are left uninitialized</strong>, so the value of <code>beta</code> is <code>&#123;&quot;&quot;,&quot;&quot;,unknown&#125;</code>.</li>
</ul>
<p>The reason for this complication is to improve performance in rare critical cases. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Buf</span> &#123;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>*<span class="hljs-number">1024</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>You can use a <code>Buf</code> as a local variable without initializing it before using it as a target for an input operation.</li>
</ul>
</li>
</ul>
<p>Most local variable initializations are not performance critical, and uninitialized local variables are a major source of errors.</p>
<p>If you want guaranteed initialization or simply dislike surprises, supply an initializer, such as <code>&#123;&#125;</code>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">Buf buf0; <span class="hljs-comment">// statically allocated, so buf0 is initialized by default</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Buf buf1; <span class="hljs-comment">// leave elements uninitialized</span><br>    Buf buf2&#123;&#125;; <span class="hljs-comment">// I really want to zero out those elements</span><br>    <br>    <span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// *p1 is uninitialized</span><br>    <span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;&#125;; <span class="hljs-comment">// *p2 is initialized to 0; *p2 == 0</span><br>    <span class="hljs-type">int</span>* p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>&#125;; <span class="hljs-comment">// *p3 is initialized to 7; *p3 == 7</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Naturally, memberwise initialization works only if we can access the members. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Checked_pointer</span> &#123; <span class="hljs-comment">// control access to T* member</span><br><span class="hljs-keyword">public</span>:<br>    T&amp; <span class="hljs-keyword">operator</span>*(); <span class="hljs-comment">// check for nullptr and return value</span><br><span class="hljs-comment">// ...</span><br>&#125;;    <br><br>Checked_pointer&lt;<span class="hljs-type">int</span>&gt; p&#123;<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>&#125;&#125;; <span class="hljs-comment">// Error: can&#x27;t access p.p</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>If a class has a private non-<code>static</code> data member, it needs a contructor to initialize it.</p>
</li>
</ol>
<h4 id="17-3-2-Initialization-Using-Constructors"><a href="#17-3-2-Initialization-Using-Constructors" class="headerlink" title="17.3.2 Initialization Using Constructors"></a>17.3.2 Initialization Using Constructors</h4><h4 id="17-3-3-Default-Constructors"><a href="#17-3-3-Default-Constructors" class="headerlink" title="17.3.3 Default Constructors"></a>17.3.3 Default Constructors</h4><ol>
<li><p>A constructor that can be invoked without an argument is called a <em><strong>default constructor</strong></em>.</p>
<p>Default constructors are very common.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>(); <span class="hljs-comment">// default constructor: no elements</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="2">
<li><p><strong>A default constructor is used if no arguments are specified or if an empty initializer list is provided</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Vector v1; <span class="hljs-comment">// OK: on argument are specified</span><br>Vector v2&#123;&#125;; <span class="hljs-comment">// OK: an empty initializer list</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>A default argument (section 12.2.5) can make a constructor that takes arguments into a default constructor.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p =<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// default constructor: empty string</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br>String s1; <span class="hljs-comment">// OK: global variable (static allocated object: equivalent to using &#123;&#125;; section 17.3.1)</span><br>String s2&#123;&#125;; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure></li>
<li><p>The standard-library <code>vector</code> and <code>string</code> have such defaultl constructors (section 36.3.2, section 31.3.2).</p>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>The built-in types are considered to have default and copy constructors.</p>
<p>However, for a built-in type the default constructor is not invoked for uninitialized non-<code>static</code> variables (section 17.3.1).</p>
<ul>
<li>The default value of a built-in type is <code>0</code> for integers,</li>
<li><code>0.0</code> for floating point types, and </li>
<li><code>nullptr</code> for pointers.</li>
</ul>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a0; <span class="hljs-comment">// local variable (non-static: not a global variable or static variable; section 6.4.2)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">a1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// function declaration (intended?)</span><br>    <br>    <span class="hljs-type">int</span> a&#123;&#125;; <span class="hljs-comment">// a becomes 0</span><br>    <span class="hljs-type">double</span> d&#123;&#125;; <span class="hljs-comment">// d becomes 0.0</span><br>    <span class="hljs-type">char</span>* p&#123;&#125;; <span class="hljs-comment">// p becomes nullptr</span><br>    <br>    <span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// uninitialized int (free allocated object; built-in type; uninitialized)</span><br>    <span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;&#125;; <span class="hljs-comment">// the int is initialized to 0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="5">
<li><p>Constructors for built-in types are most often used for template arguments.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Handle</span> &#123;<br>    T* p;<br>    <span class="hljs-built_in">Handle</span>(T* pp = <span class="hljs-keyword">new</span> T&#123;&#125;) :p&#123;pp&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;    <br><br>Handle&lt;<span class="hljs-type">int</span>&gt; px; <span class="hljs-comment">// will generate int&#123;&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>The generated <code>int</code> will be initialized to <code>0</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>References and <code>const</code>s must be initialized (section 7.7, section 7.5).</p>
<p>Therefore, a class containing such members cannot be default constructed unless the programmer supplies in-class member initializers (section 17.4.4) or defines a default constructor that initializes them (section 17.4.1).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> glob&#123;<span class="hljs-number">9</span>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a1&#123;<span class="hljs-number">7</span>&#125;; <span class="hljs-comment">// OK</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a2; <span class="hljs-comment">// Error: requires a user-defined constructor</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; r&#123;<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// OK</span><br>    <span class="hljs-type">int</span>&amp; r1&#123;glob&#125;; <span class="hljs-comment">// OK</span><br>    <span class="hljs-type">int</span>&amp; r2; <span class="hljs-comment">// Error: requires a user-defined constructor</span><br>&#125;;<br><br>X x; <span class="hljs-comment">// Error: no default constructor for X</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="7">
<li><p>An array, a standard-library <code>vector</code>, and similar containers can be declared to allocate a number of default-initialized elements.</p>
<p>In such cases, a default constructor is obviously required for a class used as the element type of a <code>vector</code> or array.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span> &#123; <span class="hljs-built_in">S1</span>();&#125;; <span class="hljs-comment">// has default constructor</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S2</span> &#123; <span class="hljs-built_in">S2</span>(string);&#125; <span class="hljs-comment">// no default constructor</span><br><br>S1 a1[<span class="hljs-number">10</span>]; <span class="hljs-comment">// OK: 10 default elements</span><br>S2 a2[<span class="hljs-number">10</span>]; <span class="hljs-comment">// Error: cannot initialize elements</span><br>S2 a3[]&#123;<span class="hljs-string">&quot;alpha&quot;</span>,<span class="hljs-string">&quot;beta&quot;</span>&#125;; <span class="hljs-comment">// two elements: S2&#123;&quot;alpha&quot;&#125;, S2&#123;&quot;beta&quot;&#125;</span><br><br><span class="hljs-function">vector&lt;S1&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// OK: 10 default elements</span><br><span class="hljs-function">vector&lt;S2&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// Error: cannot initialize elements</span><br>vector&lt;S2&gt; v3&#123;<span class="hljs-string">&quot;alpha&quot;</span>,<span class="hljs-string">&quot;beta&quot;</span>&#125;; <span class="hljs-comment">// OK: two elements: S2&#123;&quot;alpha&quot;&#125;, S2&#123;&quot;beta&quot;&#125;</span><br><br><span class="hljs-function">vector&lt;S2&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;&quot;</span>)</span></span>; <span class="hljs-comment">// OK: 10 elements each initialized to S2&#123;&quot;&quot;&#125;</span><br>vector&lt;S2&gt; v4; <span class="hljs-comment">// OK: no elements</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>When should a class have a default constructor?</p>
<ul>
<li>A simple-minded technical answer is “when you use it as the element type for an arrary, etc.”</li>
</ul>
<p>However, a better question is “For what types does it make sense to have a default value?”</p>
<ul>
<li>String has the empty string, <code>&quot;&quot;</code>, containers have the empty set <code>&#123;&#125;</code>, and numeric values have zero.</li>
<li>The trouble with deciding on a default <code>Date</code> (section 16.3) arose because there is no “natural” default date (the Big Bang  is too far in the past and not precisely associated with our everyday dates).</li>
<li>It is good idea not to be too clever when inventing default values.<ul>
<li>For example, the problem with containers of elements without default values is often best solved by not allocating elements unitl you have proper values for them (e.g., using <code>push_back</code>).</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="17-3-4-Initializer-List-Constructor"><a href="#17-3-4-Initializer-List-Constructor" class="headerlink" title="17.3.4 Initializer-List Constructor"></a>17.3.4 Initializer-List Constructor</h4><p>待续</p>
<h3 id="17-4-Member-and-Base-Initialization"><a href="#17-4-Member-and-Base-Initialization" class="headerlink" title="17.4 Member and Base Initialization"></a>17.4 Member and Base Initialization</h3><h4 id="17-4-1-Member-Initialization"><a href="#17-4-1-Member-Initialization" class="headerlink" title="17.4.1 Member Initialization"></a>17.4.1 Member Initialization</h4><ol>
<li><p>Consider a class that might be used to hold information for a small organization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Club</span> &#123;<br>    string name;<br>    vector&lt;string&gt; members;<br>    vector&lt;string&gt; officers;<br>    Date founded;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">Club</span>(<span class="hljs-type">const</span> string&amp; n, Date fd);<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>Club</code>‘s constructor takes the name of the club and its founding date as arguments.</li>
</ul>
<p><strong>Arguments for a member’s constructor</strong> are specified in a <em><strong>member initializer list</strong></em> in the definition of the constructor of the containing class.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Club::<span class="hljs-built_in">Club</span>(<span class="hljs-type">const</span> string&amp; n, Date fd)<br>    : name&#123;n&#125;, members&#123;&#125;, officiers&#123;&#125;, founded&#123;fd&#125; <span class="hljs-comment">// member initializer list</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The member initializer list starts with a colon, and the individual member initializers are separated by commas.</p>
</li>
</ol>
<ol start="2">
<li><p>The members’ constructors are called before the body of the containing class’s own constructor is executed (section 17.2.3).</p>
<p><strong>The constructors are called in the order in which the members are declared in the class</strong> rather than the order in which the members appears in the initializer list.</p>
<ul>
<li>To avoid confusion, it is best to specify the initializers in the member declaration order.</li>
<li>Hope a compiler warning if you don’t get the order right.</li>
</ul>
<p>The member destructors are called in the reverse order of construction after the body of the class’s own destructor has been executed.</p>
</li>
</ol>
<ol start="3">
<li><p>If a member construcotr needs no arguments, the member need not be mentioned in the member initializer. </p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Club::<span class="hljs-built_in">Club</span>(<span class="hljs-type">const</span> string&amp; n, Date fd)<br>    : name&#123;n&#125;, founded&#123;fd&#125;<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This constructor is equivalent to the previous version.</li>
<li>In each case, <code>Club::officers</code> and <code>Club::members</code> are initialized to a <code>vector</code> with no elements.</li>
</ul>
<p>It is usually a good idea to be explicit about initializing members.</p>
<p>Note that an “implicitly initialized” member of a built-in type is left uninitialized (section 17.3.1).</p>
</li>
</ol>
<ol start="4">
<li><p>A constructor can initialize members and bases of its class, but not members or bases of its members or bases.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span>); <span class="hljs-comment">/* ... */</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BB</span> : B &#123; <span class="hljs-comment">/* ... */</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BBB</span> : BB &#123;<br>    <span class="hljs-built_in">BBB</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">B</span>(i) &#123;&#125;; <span class="hljs-comment">// Error: trying to initialize base&#x27;s base</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="17-4-1-1-Member-Initialization-and-Assignment"><a href="#17-4-1-1-Member-Initialization-and-Assignment" class="headerlink" title="17.4.1.1 Member Initialization and Assignment"></a>17.4.1.1 Member Initialization and Assignment</h5><ol start="5">
<li><p>Member initializers are essential for types for which the meaning of initialization differs from that of assignment.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> i;<br>    Club cl;<br>    Club&amp; rc;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> ii, <span class="hljs-type">const</span> string&amp; n, Date d, Club&amp; c) : i&#123;ii&#125;, cl&#123;n,d&#125;, rc&#123;c&#125; &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>A reference member or a <code>const</code> member must be initialized (section 7.5, section 7.7, section 17.3.3).</p>
<p>However, for most types the programmer has a choice between using an initializer and using an assignment.</p>
<ul>
<li>In that case, I usually prefer to use the member initializer syntax to make it explicit that initialization is being done.</li>
<li>Often, there also is an efficiency advantage to using the initializer syntax (compared to using an assignment)</li>
</ul>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    string name;<br>    string address;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp;);<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> string&amp; n, <span class="hljs-type">const</span> string&amp; a);<br>&#125;;<br><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> string&amp; n, <span class="hljs-type">const</span> string a)<br>    : name&#123;n&#125;<br>&#123;<br>    address = a;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Here <code>name</code> is initialized with a copy of <code>n</code>. </p>
<p>On the other hand, <code>address</code> is first initializeed to the empty string and then a copy of <code>a</code> is assigned.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="17-4-3-Delegating-Constructors"><a href="#17-4-3-Delegating-Constructors" class="headerlink" title="17.4.3 Delegating Constructors"></a>17.4.3 Delegating Constructors</h4><ol>
<li><p>If you want two constructors to do the same action, you can repeat yourself or define “an <code>init()</code> function” to perform the common action.</p>
<p>Both “solutions” are common (because older versions of C++ didn’t offer anything better).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">validate</span>(<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;x &amp;&amp; x&lt;=max) a=x; <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Bad_X</span>(x);&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> x) &#123; <span class="hljs-built_in">validate</span>(x);&#125;<br>    <span class="hljs-built_in">X</span>() &#123; <span class="hljs-built_in">validate</span>(<span class="hljs-number">42</span>);&#125;<br>    <span class="hljs-built_in">X</span>(string s) &#123; <span class="hljs-type">int</span> x= <span class="hljs-built_in">to</span>&lt;<span class="hljs-type">int</span>&gt;(s); <span class="hljs-built_in">validate</span>(x);&#125; <span class="hljs-comment">// section 25.2.5.1</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Verbosity hinders readability and repetition is error-prone. Both get in the way of maintainability.</p>
<p>The alternative is to define one constructor in terms of another:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;x &amp;&amp; x&lt;=max) a=x; <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Bad_X</span>(x);&#125;<br>    <span class="hljs-built_in">X</span>() : X&#123;<span class="hljs-number">42</span>&#125; &#123;&#125;<br>    <span class="hljs-built_in">X</span>(string s) : X&#123;<span class="hljs-built_in">to</span>&lt;<span class="hljs-type">int</span>&gt;(s)&#125; <span class="hljs-comment">// section 25.2.5.1</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This is, a member-style initializer using the class’s own name (its constructor name) calls another construcors as part of the construction.</li>
<li>Such construction is called a <em><strong>delegating constructor</strong></em> (and occasionally a <em><strong>forwarding constructor</strong></em>).</li>
</ul>
<p>You cannot both delegate and explicitly initialize a member.</p>
<ul>
<li><p>For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;x &amp;&amp; x&lt;=max) a=x; <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Bad_X</span>(x);&#125;<br>    <span class="hljs-built_in">X</span>() : X&#123;<span class="hljs-number">42</span>&#125;, a&#123;<span class="hljs-number">56</span>&#125; &#123;&#125; <span class="hljs-comment">// Error: cannot both delegate and explicit initialize a member</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Delegating by calling another constructor in a constructor’s member and base initilizer list is very different from explicitly calling a constructor in the body of a constructor.</p>
<ul>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;x &amp;&amp; x&lt;=max) a=x; <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Bad_X</span>(x);&#125;<br>    <span class="hljs-built_in">X</span>() &#123; X&#123;<span class="hljs-number">42</span>&#125;;&#125; <span class="hljs-comment">// likely error</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The <code>X&#123;42&#125;</code> simply creates a new unnamed object (a temporary) and does nothing with it.</p>
<p>Such use is more often than not a a bug.</p>
</li>
<li><p>Hope for a compiler warning.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>An object is not considered constructed until its constructor compleles (section 6.4.2).</p>
<p>When using a delegating constructor, the object is not considered constructed until the delegating constructor completes – just completing the delegated-to constructor is not sufficient.</p>
<p>A destructor will not be called for an object unless its original constructor completed.</p>
</li>
</ol>
<ol start="4">
<li>If all you need is to set a member to a default value (that doesn’t depend on a constructor argument), a member initializer (section 17.4.4) may be simpler.</li>
</ol>
<h4 id="17-4-4-In-Class-Initializers"><a href="#17-4-4-In-Class-Initializers" class="headerlink" title="17.4.4 In-Class Initializers"></a>17.4.4 In-Class Initializers</h4><ol>
<li><p>We can specify an initializer for a non-<code>static</code> data member in the class declaration.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">77</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>For pretty obscure technical reasons related to parsing and name lookup, <strong>the <code>&#123;&#125;</code> and <code>=</code> initializer notations can be used for in-class member initializers, but the <code>()</code> notation cannot</strong>.</p>
</li>
</ul>
<p>By default, a constructor will use such an in-class initializer, so that example is equivalent to:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">A</span>() : a&#123;<span class="hljs-number">7</span>&#125;, b&#123;<span class="hljs-number">77</span>&#125; &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Such use of in-class initializer can save a bit of typing, but the real benefits come in more complicated classes with multiple constructors.</p>
<p>Often, several constructors use the same initializer for a member. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() :a&#123;<span class="hljs-number">7</span>&#125;,b&#123;<span class="hljs-number">5</span>&#125;,algorithm&#123;<span class="hljs-string">&quot;MD5&quot;</span>&#125;,state&#123;<span class="hljs-string">&quot;Constructor run&quot;</span>&#125; &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a_val) :a&#123;a_val&#125;,b&#123;<span class="hljs-number">5</span>&#125;,algorithm&#123;<span class="hljs-string">&quot;MD5&quot;</span>&#125;,state&#123;<span class="hljs-string">&quot;Constructor run&quot;</span>&#125; &#123;&#125;<br>    <span class="hljs-built_in">A</span>(D d) :a&#123;<span class="hljs-number">7</span>&#125;,b&#123;<span class="hljs-built_in">g</span>(d),algorithm&#123;<span class="hljs-string">&quot;MD5&quot;</span>&#125;,state&#123;<span class="hljs-string">&quot;Constructor run&quot;</span>&#125;&#125; &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a,b;<br>    HashFunction algorithm; <span class="hljs-comment">// cryptographic hash to be applied to all &quot;A&quot;s</span><br>    string state; <span class="hljs-comment">// string indicating state in object life cycle</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The fact that <code>algorithm</code> and <code>state</code> have the same value in all constructor is lost in the mess of code and can easily become a maintainance problem.</li>
</ul>
</li>
</ul>
<p>To make the common values explicit, we can factor out the unique intializer for data members:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() :a&#123;<span class="hljs-number">7</span>&#125;,b&#123;<span class="hljs-number">5</span>&#125; &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a_val) :a&#123;a_val&#125;,b&#123;<span class="hljs-number">5</span>&#125; &#123;&#125;<br>    <span class="hljs-built_in">A</span>(D d) :a&#123;<span class="hljs-number">7</span>&#125;,b&#123;<span class="hljs-built_in">g</span>(d)&#125; &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a,b;<br>    HashFunction algorithm&#123;<span class="hljs-string">&quot;MD5&quot;</span>&#125;; <span class="hljs-comment">// cryptographic hash to be applied to all &quot;A&quot;s</span><br>    string state&#123;<span class="hljs-string">&quot;Constructor run&quot;</span>&#125;; <span class="hljs-comment">// string indicating state in object life cycle</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>If a memeber is initialized by both an in-class initializer and a constructor, only the constructor’s initialization is done (it “overrides” the default).</p>
<ul>
<li><p>So we can simply further:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a_val) :a&#123;a_val&#125; &#123;&#125;<br>    <span class="hljs-built_in">A</span>(D d) :b&#123;<span class="hljs-built_in">g</span>(d)&#125; &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a&#123;<span class="hljs-number">7</span>&#125;; <span class="hljs-comment">// the meaning of 7 for a is ...</span><br>    <span class="hljs-type">int</span> b&#123;<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// the meaning of 5 for b is ...</span><br>    HashFunction algorithm&#123;<span class="hljs-string">&quot;MD5&quot;</span>&#125;; <span class="hljs-comment">// cryptographic hash to be applied to all &quot;A&quot;s</span><br>    string state&#123;<span class="hljs-string">&quot;Constructor run&quot;</span>&#125;; <span class="hljs-comment">// string indicating state in object life cycle</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>As shown, default in-class initializers provides an opportunity for documentation of common cases.</p>
</li>
</ol>
<ol start="3">
<li><p>An in-class member initializer can use names that are in scope at the point of their use in member declaration.</p>
<ul>
<li><p>Consider the following headache-inducing technical example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> count2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; <span class="hljs-keyword">return</span> i+count;&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123;<br>    <span class="hljs-type">int</span> m1&#123;count2&#125;; <span class="hljs-comment">// that is, ::count2</span><br>    <span class="hljs-type">int</span> m2&#123;<span class="hljs-built_in">f</span>(m1)&#125;; <span class="hljs-comment">// that is, this-&gt;m1+::count, that is, ::count2+::count</span><br>    <span class="hljs-built_in">S</span>() &#123; ++count2;&#125; <span class="hljs-comment">// very odd constructor, just for example</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    S s1; <span class="hljs-comment">// &#123;0,0&#125;</span><br>    <span class="hljs-comment">// count == 0; count2 == 1</span><br>    ++count;<br>    <span class="hljs-comment">// count == 1; count2 == 1</span><br>    S s2; <span class="hljs-comment">// &#123;1,2&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Member initialization is done in declaration order (section 17.2.3).</p>
<ul>
<li>So first <code>m1</code> is initialized to the value of a global variable <code>count2</code>.</li>
</ul>
</li>
<li><p>The value of the global variable is obtained at the point where the constructor for a new <code>S</code> object is run, so it can (and in this example does) change.</p>
<ul>
<li>Next, <code>m2</code> is initialized by a call to the global <code>f()</code>.</li>
</ul>
</li>
</ul>
<p>It is a bad idea to hide subtle dependencies on global data in member initializers.</p>
</li>
</ul>
</li>
</ol>
<h4 id="17-4-5-static-Member-Initialization"><a href="#17-4-5-static-Member-Initialization" class="headerlink" title="17.4.5 static Member Initialization"></a>17.4.5 <code>static</code> Member Initialization</h4><ol>
<li><p>A <code>static</code> class member is statically allocated rather than part of each object of the class. </p>
<p>Generally, <strong>the <code>static</code> member declaration acts as a declaration for a definition outside the class.</strong></p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> node_count; <span class="hljs-comment">// declaration</span><br>&#125;;<br><br><span class="hljs-type">int</span> Node::node_count = <span class="hljs-number">0</span>; <span class="hljs-comment">// definition</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>However, for a few simple special cases, it is possible to initialize a static member in the class declaration.</p>
<p><strong>The <code>static</code> member must be a <code>const</code></strong> of <strong>an integral or enumeration type</strong>, or <strong>a <code>constexpr</code> of a literal type</strong> (§10.4.3), and <strong>the initializer must be a <em>constant-expression</em></strong>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Curious</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> c1 = <span class="hljs-number">7</span>; <span class="hljs-comment">// OK</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> c2 = <span class="hljs-number">11</span>; <span class="hljs-comment">// error : not const</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> c3 = <span class="hljs-number">13</span>; <span class="hljs-comment">// OK, but not static (§17.4.4)</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> c4 = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>); <span class="hljs-comment">// error : in-class initializer not constant</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">float</span> c5 = <span class="hljs-number">7.0</span>; <span class="hljs-comment">// error : in-class not integral (use constexpr rather than const)</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>If (and only if) you use an initialized member in a way that requires it to be stored as an object in memory, the member must be (uniquely) defined somewhere. </p>
<p>The initializer may not be repeated:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> Curious::c1; <span class="hljs-comment">// don’t repeat initializer here</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>∗ p = &amp;Curious::c1; <span class="hljs-comment">// OK: Curious::c1 has been defined</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>The main use of member constants is to provide symbolic names for constants needed elsewhere in the class declaration. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fixed</span> &#123; <span class="hljs-comment">// fixed-size array</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> max = N;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    T a[max];<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>For integers, enumerators (§8.4) offer an alternative for defining symbolic constants within a class declaration.</p>
<ul>
<li> For example:</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-keyword">enum</span> &#123; c1 = <span class="hljs-number">7</span>, c2 = <span class="hljs-number">11</span>, c3 = <span class="hljs-number">13</span>, c4 = <span class="hljs-number">17</span> &#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="17-5-Copy-and-Move"><a href="#17-5-Copy-and-Move" class="headerlink" title="17.5 Copy and Move"></a>17.5 Copy and Move</h3><h4 id="17-5-1-Copy"><a href="#17-5-1-Copy" class="headerlink" title="17.5.1 Copy"></a>17.5.1 Copy</h4><p>Consider a simple two-dimensional <code>Matrix</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>&#123;<br>    array&lt;<span class="hljs-type">int</span>,2&gt; dim; <span class="hljs-comment">// two dimensions</span><br>    T* elem; <span class="hljs-comment">// pointer to dim[0]*dim[1] elements of type T</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> d1, <span class="hljs-type">int</span> d2) :dim&#123;d1,d2&#125;, elem&#123;<span class="hljs-keyword">new</span> T[d1*d2]&#125;&#123;&#125; <span class="hljs-comment">// simplified (no error handling)\</span><br><span class="hljs-comment">    int size() const &#123;return dim[0]*dim[1];&#125;</span><br>  <br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp;); <span class="hljs-comment">//copy constructor</span><br>    Matrix&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Matrix&amp;); <span class="hljs-comment">// copy assignment</span><br>  <br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp;); <span class="hljs-comment">// move constructor</span><br>    Matrix&amp; <span class="hljs-keyword">operator</span>=(Matrix&amp;&amp;); <span class="hljs-comment">// move assignment</span><br>  <br>    ~<span class="hljs-built_in">Matrix</span>()&#123; <span class="hljs-keyword">delete</span>[] elem;&#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Chapter-18-Operator-Overloading"><a href="#Chapter-18-Operator-Overloading" class="headerlink" title="Chapter 18 Operator Overloading"></a>Chapter 18 Operator Overloading</h2><ul>
<li>Introduction</li>
<li>Operator Functions<ul>
<li>Binary and Unary Operators</li>
<li>Predefined Meanings for Operators</li>
<li>Operators and User defined Types</li>
<li>Passing Objects</li>
<li>Operators in Namespaces</li>
</ul>
</li>
<li>A Complex Number Type<ul>
<li>Member and Nonmember Operators</li>
<li>Mixed-Mode Arithmetic</li>
<li>Conversions</li>
<li>Literals</li>
<li>Accessor Functions</li>
<li>Helper Functions</li>
</ul>
</li>
<li>Type Conversion<ul>
<li>Conversion Operators</li>
<li><code>explicit</code> Conversion Operators</li>
<li>Ambiguities</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="18-1-Introduction"><a href="#18-1-Introduction" class="headerlink" title="18.1 Introduction"></a>18.1 Introduction</h3><ol>
<li><p>Every technical field – and most nontechnical fields – has developed conventional shorthand notation to make convenient the presentation and discussion involving frequently used concepts.</p>
<ul>
<li><code>x+y*z</code> is clearer to us than <code>mutiply y by z and add the result to x</code>.</li>
</ul>
</li>
<li><p>Like most languages, C++ supports a set of operators for its built-in types. However, most concepts for which operators are conventionally used are not built-in types in C++, so they must be represented as user-defined types.</p>
<ul>
<li>For example, if you need complex arithmetic, matrix algebra, logic signals, or character strings in C++, you use classes to represent these notions.</li>
</ul>
<p>Defining operators for such classes sometimes allows a programmer to provide a more conventional and convenient notation for manipulating objects than that could be achieved using only the basic functional notation.</p>
</li>
<li><p>Consider:</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123; <span class="hljs-comment">// a very simplified complex</span><br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) :re&#123;r&#125;,im&#123;i&#125;&#123;&#125;<br>    complex <span class="hljs-keyword">operator</span>+(complex);<br>    complex <span class="hljs-keyword">operator</span>*(complex);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>This defines a simple implementation of the concept of complex numbers.</p>
<ul>
<li>A <code>complex</code> is represented by a pair of double-precision floating-point numbers manipulated by the operator <code>+</code> and <code>*</code>.</li>
<li>The programmber defines <code>complex::operator+()</code> and <code>complex::operator*()</code> to provide meanings for <code>+</code> and <code>*</code>.<ul>
<li>For example, if <code>b</code> and <code>c</code> are of type <code>complex</code>, <code>b+c</code> means <code>b.operator+(c)</code></li>
</ul>
</li>
</ul>
<p>We can now approximate the conventional interpretation of <code>complex</code> expressions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    complex a = complex&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3.1</span>&#125;;<br>    complex b&#123;<span class="hljs-number">1.2</span>,<span class="hljs-number">2</span>&#125;;<br>    complex c&#123;b&#125;;<br>  <br>    a = b+c;<br>    b = b+c*a;<br>    c = a*b+<span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The usual precedence rules hold.<ul>
<li>So the second statement means <code>b=b+(c*a)</code>, not <code>b=(b+c)*a</code>.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>C++ grammar is written so that the <code>&#123;&#125;</code> notation can only be used for initializers and on the right-hand side of an assignment:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(complex a, complex b)</span></span><br><span class="hljs-function"></span>&#123;<br>    a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Ok: right hand side of assignment</span><br>    a += &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Ok: right hand side of assignment</span><br>    b = a+&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Sytax error</span><br>    b = a+complex&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Ok</span><br>    <span class="hljs-built_in">g</span>(a,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;); <span class="hljs-comment">// Ok: a function argument is considered an initializer</span><br>    &#123;a,b&#125; = &#123;b,a&#125;; <span class="hljs-comment">// Sytax error</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>There seems to be no fundamental reason not to use <code>&#123;&#125;</code> in more places, but the technical problems of writing a grammar allowing <code>&#123;&#125;</code> everywhere in an expression (e.g., how would you know if a <code>&#123;</code> after a semicolon was the start of an expression or a block?) and also giving good error messages led to a more limited use of <code>&#123;&#125;</code> in expressions.</p>
<ol start="5">
<li>Many of the most obvious uses of operator overloading are for numberic types. However, the usefulness of user-defined operators is not restricted to numberic types.<ul>
<li>For example, the design of general and abstract interfaces often leads to the use of operators such as <code>-&gt;</code>, <code>[]</code>, and <code>()</code>.</li>
</ul>
</li>
</ol>
<h3 id="18-2-Operator-Functions"><a href="#18-2-Operator-Functions" class="headerlink" title="18.2 Operator Functions"></a>18.2 Operator Functions</h3><ol start="6">
<li>Functions defining meanings for the following operators can be declared:</li>
</ol>
<ul>
<li><img src="image-20230117195603731.png" srcset="/img/loading.gif" lazyload alt="image-20230117195603731"></li>
</ul>
<ol start="7">
<li><p>The following operators cannot be defined by a user:</p>
<ul>
<li><code>::</code>    scope resolution</li>
<li><code>.</code>     member selection</li>
<li><code>.*</code>    member selection through pointer to member</li>
</ul>
<p>They take a name, rather than a value, as their second operand and provide the primary means of referring to members. Allowing them to  be overloaded would lead to subtleties.</p>
</li>
<li><p>The named “operator” cannot be overloaded because they report fundamental facts about their operands:</p>
<ul>
<li><code>sizeof</code>    size of object</li>
<li><code>alignof</code>    alignment of object</li>
<li><code>typeid</code>    <code>type_info</code> of an object</li>
</ul>
</li>
<li><p>The ternary conditional expression operator cannot be overloaded (for no particularly fundamental reason):</p>
<ul>
<li><code>?:</code>    conditional evaluation</li>
</ul>
</li>
<li><p>User-defined literals are defined by using the <code>operator&quot;&quot;</code> notation.</p>
<ul>
<li>This is a syntactic subterfuge because there is no operator called <code>&quot;&quot;</code>.</li>
</ul>
<p>Similarly, <code>operaor T()</code> defines a conversion to a type <code>T</code>.</p>
</li>
<li><p>It is not possible to define new operator tokens, but you can use the function call notation when this set of operators is not adequate.</p>
<ul>
<li>For example, use <code>pow()</code>, not <code>**</code>.</li>
<li>These restrictions may seem Draconian, but more flexible rules can easily lead to ambiguities.<ul>
<li>For example, defining an operator <code>∗∗</code> to mean exponentiation may seem an obvious and easy task, but think again. Should <code>∗∗</code> bind to the left (as in Fortran) or to the right (as in Algol)? Should the expression <code>a∗∗p</code> be interpreted as <code>a∗(∗p)</code> or as <code>(a)∗∗(p)</code>?</li>
<li>There are solutions to all such technical questions.</li>
<li>However, it is most uncertain if applying subtle technical rules will lead to more readable and maintainable code. If doubt, use a named function.</li>
</ul>
</li>
</ul>
</li>
<li><p>The name of an operator function is the keyword <code>operator</code> followed by the operator itself.</p>
<ul>
<li>For example, <code>operator&lt;&lt;</code>.</li>
</ul>
<p>An operator function is declared and can be used like any other function.</p>
<ul>
<li>A use of the operator is only a shorthand for explicit call of the operator function.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(complex a, complex b)</span></span><br><span class="hljs-function"></span>&#123;<br>    complex c = a + b; <span class="hljs-comment">// shorthand</span><br>    complex d = a.<span class="hljs-keyword">operator</span>+(b); <span class="hljs-comment">// explicit call</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Given the previous definition of <code>complex</code>, the two initializers are synonymous.</p>
<h4 id="18-2-1-Binary-and-Unary-Operators"><a href="#18-2-1-Binary-and-Unary-Operators" class="headerlink" title="18.2.1 Binary and Unary Operators"></a>18.2.1 Binary and Unary Operators</h4><ol start="13">
<li>A binary operator can be defined by either a <a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickyk/p/4238380.html">non-<code>static</code> member function</a> taking one argument or a <a target="_blank" rel="noopener" href="https://www.cnblogs.com/muchen/p/6353793.html">nonmember function</a> taking two arguments.<ul>
<li>For any bianry operator <code>@</code>, <code>aa@bb</code> can be interpreted as either <code>aa.operator@bb</code> or <code>operator@(aa,bb)</code>. If both are defined, overload resolution determines which, if any, interpretation is used.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span>);<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+(X,X); <span class="hljs-comment">// non-static member function</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+(X,<span class="hljs-type">double</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(X a)</span></span><br><span class="hljs-function"></span>&#123;<br>    a+<span class="hljs-number">1</span>; <span class="hljs-comment">// a.operator+(1)</span><br>    <span class="hljs-number">1</span>+a; <span class="hljs-comment">// ::operator+(X(1),a) nonmember function</span><br>    a+<span class="hljs-number">1.0</span>; <span class="hljs-comment">// ：：operator+(a,1.0)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1022477">静态成员函数和非静态成员函数的区别？ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<ol start="14">
<li><p>A unary operator, whether prefix or postfix, can be defined by either a non-<code>static</code> member function taking no arguments or a nonmember function taking one argument.</p>
<ul>
<li>For any prefix unary operator <code>@</code>, <code>@aa</code> can be interpreted as either <code>aa.operator@()</code> or <code>operator@(aa)</code>. If both are defined, overload resolution determines which, if any, interpretation is used.</li>
<li>For any postfix unary operator <code>@</code>, <code>aa@</code> can be interpreted as either <code>aa.operator@()</code> or <code>operator@(aa,int)</code>. If both are defined, overload resolution determines which, if any, interpretation is used.</li>
<li>参考section 19.2.4节，介绍关于argument <code>int</code>作为一个dummy，只是用于区分prefix和postfix.<ul>
<li>The <code>int</code> argument is used to indicate that the function is to be invoked for postfix application of <code>++</code>.<ul>
<li>This <code>int</code> is never used; the argument is simply a dummy used to distinguish between prefix and postfix application.</li>
<li>The way to remember which version of an <code>operator++</code> is prefix is to note that the version without the dummy argument is prefix, exactly like all the other unary arithmetic and logical operators.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>An operator can be declared only for the syntax defined for it in the grammar.</p>
<ul>
<li>For example, a user cannot define a unary <code>%</code> or a ternary <code>+</code>.</li>
</ul>
<p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// members (with implicit this pointer):</span><br>    X* <span class="hljs-keyword">operator</span>&amp;(); <span class="hljs-comment">// prefix unary &amp; (address of)</span><br>    X <span class="hljs-keyword">operator</span>&amp;(X); <span class="hljs-comment">// binary &amp; (and)</span><br>    X <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix increment</span><br>    X <span class="hljs-keyword">operator</span>&amp;(X,X); <span class="hljs-comment">// Error: ternary</span><br>    X <span class="hljs-keyword">operator</span>/(); <span class="hljs-comment">//Erro: Unary /</span><br>&#125;;<br><br><span class="hljs-comment">// nonmember functions:</span><br>X <span class="hljs-keyword">operator</span>-(X); <span class="hljs-comment">// prefix unary minus</span><br>X <span class="hljs-keyword">operator</span>-(X,X); <span class="hljs-comment">// binary minus</span><br>X <span class="hljs-keyword">operator</span>--(X&amp;,<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix decrement</span><br>X <span class="hljs-keyword">operator</span>-(); <span class="hljs-comment">// Error: no operand</span><br>X <span class="hljs-keyword">operator</span>-(X,X,X); <span class="hljs-comment">// Error: ternary</span><br>X <span class="hljs-keyword">operator</span>%(X); <span class="hljs-comment">// Error: unary %</span><br></code></pre></td></tr></table></figure></li>
<li><p>The operators <code>operator=</code>, <code>operator[]</code>, <code>operator()</code>, and <code>operator-&gt;</code> must be non-<code>static</code> member functions.</p>
</li>
<li><p>The default meaning of <code>&amp;&amp;</code>, <code>||</code> and <code>,</code> involves sequencing: the first operand is evaluated before the second (and for <code>&amp;&amp;</code> and <code>||</code> the second operand is not always evaluated).</p>
<ul>
<li>This special rule does not hold for user-defined versions of <code>&amp;&amp;</code> , <code>||</code>, and <code>,</code>; instead these operators are treated exactly like other binary operators.</li>
</ul>
</li>
</ol>
<h4 id="18-2-2-Predefined-Meanings-for-Operators"><a href="#18-2-2-Predefined-Meanings-for-Operators" class="headerlink" title="18.2.2 Predefined Meanings for Operators"></a>18.2.2 Predefined Meanings for Operators</h4><ol start="18">
<li><p>The meaning of some built-in operators are defined to be equivalent to some combination of other operators on the same arguments.</p>
<ul>
<li>For example, if <code>a</code> is an int,  <code>++a</code> means <code>a+=1</code>, which in turn means <code>a=a+1</code>.</li>
</ul>
<p>Such relations do not hold for user-defined operators unless the user defines them to.</p>
<ul>
<li>For example, a compiler will not generate a definition of <code>Z::operator+=()</code> from the definitions of <code>Z::operator+()</code> and <code>Z::operator=()</code>.</li>
</ul>
</li>
<li><p>The operator <code>=</code>(assignment), <code>&amp;</code>(address of), and <code>,</code>(sequencing) have predefined meanings when applied to class objects.</p>
<ul>
<li>These predefined meanings can be eliminated(“deleted”)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> X&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&amp;() = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>,(<span class="hljs-type">const</span> X&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(X a, X b)</span></span><br><span class="hljs-function"></span>&#123;<br>    a = b; <span class="hljs-comment">// Error: no operator=()</span><br>    &amp;a; <span class="hljs-comment">// Error: no operator&amp;()</span><br>    a,b; <span class="hljs-comment">// Error: no operator,()</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Alternatively, they can be given new meanings by suitable definitions.</p>
</li>
</ol>
<h4 id="18-2-3-Operators-and-User-Defined-Types"><a href="#18-2-3-Operators-and-User-Defined-Types" class="headerlink" title="18.2.3 Operators and User-Defined Types"></a>18.2.3 Operators and User-Defined Types</h4><ol start="20">
<li><p>An operator function must either be a member or take at least one argument of a user-defined type (functions redefining the <code>new</code> and <code>delete</code> operators need not).</p>
<ul>
<li>This rule ensures that a user cannot change the meaning of an expression unless the expression contains an object of a user-defined type.</li>
</ul>
<p>In particular, it is not possible to define an operator function that operates exclusively on pointers.</p>
<ul>
<li>This ensures that C++ is extensible but not mutable (with the exception of operators <code>=</code>, <code>&amp;</code>, and <code>,</code> for class objects).</li>
</ul>
</li>
<li><p>An operator function intended to accept a built-in type as its first operand cannot be a member function.</p>
<ul>
<li>For example, consider adding a complex variable <code>aa</code> to the integer <code>2</code>: <code>aa+2</code> can, with suitably declared member function , be interpreted as <code>aa.operator+(2)</code>, but <code>2+aa</code> cannot because there is no class <code>int</code> for which to define <code>+</code> to mean <code>2+operator+(aa)</code>.<ul>
<li>Even if there were, two different member functions would be needed to cope with <code>2+aa</code> and <code>aa+2</code>. Because the compiler does not know the meaning of a user-defined +, it cannot assume that the operator is commutative and so interpret <code>2+aa</code> as <code>aa+2</code>.</li>
<li>This example is trivially handled using one or more nonmember functions.</li>
</ul>
</li>
</ul>
</li>
<li><p>Enumberations are user-defined types so that we can define operators for them.</p>
<ul>
<li><p>For example</p>
<ul>
<li>```C++<br>enum Day{sun,mon,tue,wed,thu,fri,sat};Day&amp; operator++(Day&amp; d)<br>{<pre><code class="hljs">return d = (sat == d) ? sun : static_cast&lt;Day&gt;(d+1);
</code></pre>
}<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><br>Every expression <span class="hljs-keyword">is</span> checked <span class="hljs-keyword">for</span> ambiguities. <span class="hljs-keyword">Where</span> a user-defined <span class="hljs-keyword">operator</span> provide a possible interpretation, the expression <span class="hljs-keyword">is</span> checked according <span class="hljs-keyword">to</span> the <span class="hljs-keyword">overload</span> resolution rules <span class="hljs-keyword">in</span> Section <span class="hljs-number">12.3</span>.<br><br>#### <span class="hljs-number">18.2</span>.<span class="hljs-number">4</span> Passing objects<br><br><span class="hljs-number">23</span>. When we define an <span class="hljs-keyword">operator</span>, we typically want <span class="hljs-keyword">to</span> provide a conventional notation.<br><br>    - <span class="hljs-keyword">For</span> example, `a=b+c`.<br><br>    Consequently, we have limited choices <span class="hljs-keyword">of</span> how <span class="hljs-keyword">to</span> pass arguments <span class="hljs-keyword">to</span> the <span class="hljs-keyword">operator</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">how</span> <span class="hljs-title function_">it</span> <span class="hljs-title function_">returns</span> <span class="hljs-title function_">its</span> <span class="hljs-title function_">value</span>.<br><br>    - <span class="hljs-title function_">For</span> <span class="hljs-title function_">example</span>, <span class="hljs-title function_">we</span> <span class="hljs-title function_">cannot</span> <span class="hljs-title function_">require</span> <span class="hljs-title function_">pointer</span> <span class="hljs-title function_">arguments</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">expect</span> <span class="hljs-title function_">programmers</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">use</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">address</span>-<span class="hljs-title function_">of</span> <span class="hljs-title function_">operator</span> <span class="hljs-title function_">or</span> <span class="hljs-title function_">return</span> <span class="hljs-title function_">a</span> <span class="hljs-title function_">pointer</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">expect</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">user</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">dereference</span> <span class="hljs-title function_">it</span>: `*a=&amp;b+&amp;c` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> acceptable.<br><span class="hljs-number">24</span>. <span class="hljs-keyword">For</span> arguments, we have two main choices:<br><br>    - Pass-<span class="hljs-keyword">by</span>-value<br>    - Pass-<span class="hljs-keyword">by</span>-<span class="hljs-keyword">reference</span><br><br>    <span class="hljs-keyword">For</span> small objects, say, one <span class="hljs-keyword">to</span> four words, call-<span class="hljs-keyword">by</span>-value <span class="hljs-keyword">is</span> typically a viable alternative <span class="hljs-keyword">and</span> often the one that gives the best performance.<br><br>    However, performance <span class="hljs-keyword">of</span> argument passing <span class="hljs-keyword">and</span> use depends <span class="hljs-keyword">on</span> machine architecture, compiler <span class="hljs-keyword">interface</span> conventions (Application Binary Interfaces<span class="hljs-punctuation">;</span> ABIs), <span class="hljs-keyword">and</span> the number <span class="hljs-keyword">of</span> times an argument <span class="hljs-keyword">is</span> accessed (it almost always <span class="hljs-keyword">is</span> faster <span class="hljs-keyword">to</span> access an argument passed <span class="hljs-keyword">by</span> value than one passed <span class="hljs-keyword">by</span> <span class="hljs-keyword">reference</span>).<br><br>    - <span class="hljs-keyword">For</span> example, assument taht a `Point` <span class="hljs-keyword">is</span> represented <span class="hljs-keyword">as</span> a pair <span class="hljs-keyword">of</span> `int`s:<br><br>      - ```C++<br>        void Point::<span class="hljs-keyword">operator</span>+=(Point delta)<span class="hljs-punctuation">;</span> <span class="hljs-comment">// pass-by-value (small object)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>For larger objects, we pass by reference.</p>
<ul>
<li><p>For example.</p>
<ul>
<li>```C++<br>template<class T><br>class Matrix{<pre><code class="hljs">array&lt;int,2&gt; dim; // two dimensions
T* elem; // pointer to dim[0]*dim[1] elements of type T
</code></pre>
public:<pre><code class="hljs">Matrix(int d1, int d2) :dim&#123;d1,d2&#125;, elem&#123;new T[d1*d2]&#125;&#123;&#125; // simplified (no error handling)\
int size() const &#123;return dim[0]*dim[1];&#125;

Matrix(const Matrix&amp;); //copy constructor
Matrix&amp; operator=(const Matrix&amp;); // copy assignment

Matrix(Matrix&amp;&amp;); // move constructor
Matrix&amp; operator=(Matrix&amp;&amp;); // move assignment

~Matrix()&#123; delete[] elem;&#125;
//...
</code></pre>
}<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">- Because a `<span class="hljs-keyword">Matrix</span>` (a simple <span class="hljs-keyword">matrix</span> of `double`s) is most likely larger than a few words, we <span class="hljs-keyword">use</span> pass-<span class="hljs-keyword">by</span>-reference:<br>- ```C++<br>  <span class="hljs-keyword">Matrix</span> operator+(<span class="hljs-keyword">const</span> <span class="hljs-keyword">Matrix</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">Matrix</span>&amp;); <span class="hljs-comment">// pass-by-const-reference</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>In particular, we use <code>const</code> references to pass large objects that are not meant to be modified by the called function.</p>
</li>
</ul>
</li>
<li><p>Typically, an operator returns a result.</p>
<p>Returning a pointer or reference to a newly created object is usually a very bad idea:</p>
<ul>
<li>Using a pointer gives notational problems</li>
<li>Referring to an object on the free store (whether by a pointer or by a reference) results in memory management problems.</li>
</ul>
<p>Instead, return objects by value. For large objects, such as a <code>Matrix</code>, define move operations to make such transfers of values efficient.</p>
<ul>
<li><p>For example:</p>
<ul>
<li>```C++<br>Matrix operator+(const Matrix&amp; a, const Matrix&amp; b) // return-by-value<br>{<pre><code class="hljs">Matrix res&#123;a&#125;;
return res+=b;
</code></pre>
}<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs maxima">- Note that operators that <span class="hljs-built_in">return</span> one of their argument objects can -- <span class="hljs-keyword">and</span> usually <span class="hljs-keyword">do</span> -- <span class="hljs-built_in">return</span> a reference.<br><br>  - For <span class="hljs-built_in">example</span>, we could <span class="hljs-built_in">define</span> `Matrix`&#x27;s operator `+=` like this:<br>  - ```C++<br>    Matrix&amp; Matrix::operator+=(const Matrix&amp; a) // <span class="hljs-built_in">return</span>-by-reference<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dim</span>[<span class="hljs-number">0</span>]!=a.<span class="hljs-built_in">dim</span>[<span class="hljs-number">0</span>] || <span class="hljs-built_in">dim</span>[<span class="hljs-number">1</span>]!=a.<span class="hljs-built_in">dim</span>[<span class="hljs-number">1</span>])<br>            <span class="hljs-built_in">throw</span> <span class="hljs-built_in">std</span>::exception(<span class="hljs-string">&quot;bad Matrix += argument&quot;</span>);<br>        double* p = <span class="hljs-built_in">elem</span>;<br>        double* q = a.<span class="hljs-built_in">elem</span>;<br>        double* end = p+<span class="hljs-built_in">dim</span>[<span class="hljs-number">0</span>]*<span class="hljs-built_in">dim</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(p!=end)<br>            *p++=*q++;<br>    <br>        <span class="hljs-built_in">return</span> *this;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>This is particularly common for operator functions that are implemented as members.</li>
</ul>
</li>
</ul>
</li>
<li><p>If a function is simply passes an object to another function, an rvalue reference argument should be used.</p>
</li>
</ol>
<h4 id="18-2-5-Operators-in-Namespaces"><a href="#18-2-5-Operators-in-Namespaces" class="headerlink" title="18.2.5 Operators in Namespaces"></a>18.2.5 Operators in Namespaces</h4><ol start="27">
<li><p>An operator is either a member of a class or defined in some namespace (possibly the global namespace).</p>
<p>Consider this simplified version of string I/O from the standard library.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std&#123; <span class="hljs-comment">// simplified std</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ostream</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*); <span class="hljs-comment">// ouput C-style string</span><br>    &#125;;<br><br>    <span class="hljs-keyword">extern</span> ostream cout;<br><br>    ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="hljs-type">const</span> string&amp;); <span class="hljs-comment">// output std::string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*p = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::string s = <span class="hljs-string">&quot;world&quot;</span>;<br>    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;!\n&quot;</span>; <span class="hljs-comment">// write out: Hello, world!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Using <code>std::</code> prefix for <code>string</code> and <code>cout</code>, instead of <code>using namepsace std</code>, I was on my best behavior and didn’t pollute the global namespace or in other ways introduce unnecessary dependencies.</p>
</li>
<li><p>The  output operator for C-style strings is a member of <code>std::ostream</code>, so by definition</p>
<ul>
<li><code>std::cout &lt;&lt; p</code> means <code>std::cout.operator&lt;&lt;(p)</code></li>
</ul>
</li>
<li><p><code>std::ostream</code> doesn’t have a member function to output a <code>std::string</code>, so</p>
<ul>
<li><code>std::cout&lt;&lt;s</code> means <code>operator&lt;&lt;(std::cout,s)</code></li>
</ul>
</li>
<li><p>Operators defined in namespaces can be found based on their operand types just as functions can be found based on their argument types.</p>
<ul>
<li><p>In particular, <code>cout</code> is in namespace <code>std</code>, so <code>std</code> is considered when looking for suitable definition of <code>&lt;&lt;</code>.</p>
</li>
<li><p>In that way, for <code>std::cout&lt;&lt;s</code>, the compiler finds and uses:</p>
<ul>
<li>```C++<br>std::operator&lt;&lt;(std::ostream, const std::string&amp;)<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">28</span>. Consider a bianry operator `@`, if `x` is of type `X` <span class="hljs-literal">and</span> `y` is of type `Y`, `x@y` is resolved like this:<br><br>    - If `X` is a class, look for `operator@` as a member of `X` <span class="hljs-literal">or</span> as a member of a base of `X`; <span class="hljs-literal">and</span><br>    - look for declarations of `operator@` in the context surrounding `x@y`; <span class="hljs-literal">and</span><br>    - if `X` is defined in namespace `N`, look for declarations of `operator@` in `N`; <span class="hljs-literal">and</span><br>    - if `Y` is defined in naspace `M`, look for declarations of `operator@` in `M`.<br><br>    Declarations for several `operator@`s may be found an overload resolution rules are used to find the best match, if any.<br><br>    This lookup mechanism is applied only if the operator has at least one operand of a user-defined type.<br><br>    - Therefore, user-defined conversions will be considered.<br>    - Note that a type alias is just a synonym <span class="hljs-literal">and</span> <span class="hljs-literal">not</span> a separate user-defined type.<br><br>    Unary operators are resolved analogously.<br><br>    Note that in operator lookup no preference is given to members over nonmembers.<br><br>    - This different from lookup of named functions.<br><br>      - When a class member invokes a named function, other members of the same class <span class="hljs-literal">and</span> its base classes are preferred over functions potentially found based on argument types.<br>    - The lack of hiding operators ensures that built-in operator are never inaccessible <span class="hljs-literal">and</span> that users can supply <span class="hljs-keyword">new</span> meanings for an operator without modifying existing class declarations.<br><br>      - For example.<br>      - ```C++<br>        X operator!(X)<span class="hljs-comment">;</span><br>        <br>        struct Z&#123;<br>            Z operator!()<span class="hljs-comment">; // does not hide ::operator!()</span><br>            X f(X x) &#123; <span class="hljs-comment">/*...*/</span> <span class="hljs-keyword">return</span> !x<span class="hljs-comment">;&#125; // invoke ::operator!(X)</span><br>            int f(int x) &#123; <span class="hljs-comment">/*...*/</span> <span class="hljs-keyword">return</span> !x<span class="hljs-comment">;&#125; // invokde the built-in ! for ints</span><br>        &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>In particular, the standard <code>iostream</code> library defines <code>&lt;&lt;</code> member functions to output built-in types, and a user can define <code>&lt;&lt;</code> to output user-defined types without modifying class <code>ostream</code>.</p>
</li>
</ul>
</li>
</ol>
<h3 id="18-3-A-Complex-Number-Type"><a href="#18-3-A-Complex-Number-Type" class="headerlink" title="18.3 A Complex Number Type"></a>18.3 A Complex Number Type</h3><ol start="29">
<li><p>The implementation of complex numbers presented in section 18.1 is too restrictive to please anyone.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123; <span class="hljs-comment">// a very simplified complex (from section 18.1)</span><br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) :re&#123;r&#125;,im&#123;i&#125;&#123;&#125;<br>    complex <span class="hljs-keyword">operator</span>+(complex);<br>    complex <span class="hljs-keyword">operator</span>*(complex);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>We would expect this to work:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    complex a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    complex b&#123;<span class="hljs-number">3</span>&#125;;<br>    complex c&#123;a+<span class="hljs-number">2.3</span>&#125;;<br>    complex d&#123;<span class="hljs-number">2</span>+b&#125;;<br>    b = c*<span class="hljs-number">2</span>*c;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>In addtion, we would expect to be provided with a few additional operators.<ul>
<li>Such as <code>==</code> for comparison and <code>&lt;&lt;</code> for output, and a suitable set of mathematical functions, such as <code>sin()</code> and <code>sqrt()</code>.</li>
</ul>
</li>
</ul>
</li>
<li><p>Class <code>complex</code> is a concrete type, so its design follows the guidelines from section 16.3.</p>
<p>In addition, users of complex arithmetic rely so heavily on operators that the definition of <code>complex</code> brings into play most of the basic rules for operator overloading.</p>
</li>
<li><p>The <code>complex</code> type developed in this section uses <code>double</code> for its scalars and is roughly equivalent to the standard-library <code>complex&lt;double&gt;</code>.</p>
</li>
</ol>
<h4 id="18-3-1-Member-and-Nonmember-Operators"><a href="#18-3-1-Member-and-Nonmember-Operators" class="headerlink" title="18.3.1 Member and Nonmember Operators"></a>18.3.1 Member and Nonmember Operators</h4><ol start="32">
<li><p>I prefer to minimize the number of functions that directly manipulate the representation of an object.</p>
<ul>
<li><p>This can be achieved by defining only operators that inherently modify the value of their first argument, such as <code>+=</code>, in the class itself.</p>
</li>
<li><p>Operators that simply produce a new value based on the values of their arguments, such as <code>+</code>, are then defined outside the class and use the essential operators in their implementation:</p>
</li>
<li><p>```C++<br>class complex{</p>
<pre><code class="hljs">double re, im;
</code></pre>
<p>public:</p>
<pre><code class="hljs">complex&amp; operator+=(complex a); // needs access to representation
// ...
</code></pre>
<p>};<br>complex operator+(complex a, complex b)<br>{</p>
<pre><code class="hljs">return a += b; // access representation through +=
</code></pre>
<p>}</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>  - The arguments to <span class="hljs-keyword">this</span> `<span class="hljs-keyword">operator</span>+()` are passed by value, so `a+b` does <span class="hljs-keyword">not</span> modify its operands.<br>- Given these declarations, we can write:<br><br>  ```C++<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(complex x, complex y, complex z)</span></span><br><span class="hljs-function">  </span>&#123;<br>      complex r1&#123;x+y+z&#125;; <span class="hljs-comment">// r1 = operator+(operator+(x,y),z)</span><br>  <br>      complex r2&#123;x&#125;; <span class="hljs-comment">// r2 = x</span><br>      r2 += y; <span class="hljs-comment">// r2.operator+=(y)</span><br>      r2 += z; <span class="hljs-comment">// r2.operator+=(z)</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Except for possible efficiency differentces, the computations of <code>r1</code> and <code>r2</code> are equivalent.</li>
</ul>
</li>
<li><p>Composite assignment operators such as <code>+=</code> and <code>*=</code> tend to be simpler to define than their “simple” counterparts <code>+</code> and <code>*</code>.</p>
<ul>
<li><p>This surprises most people at first, but follows from the fact that three objects are involved in a <code>+</code> operation (the two operands and the result), whereas only two objects are involved in a <code>+=</code> operation.</p>
</li>
<li><p>In the latter case, run-time efficiency is improved by eliminating the need for temporary variables.</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> complex&amp; complex::<span class="hljs-keyword">operator</span>+=(complex a)<br>&#123;<br>    re += a.re;<br>    im += a.im;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This does not require a temporary variable to hold the result of the addition and is simple for a compiler to inline perfectly.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>A good optimizer will generate close to optimal code for uses fo the plain <code>+</code> operator also.</p>
<p>However, we don’t always have a good optimizer, and not all types are as simple as <code>complex</code>.</p>
<ul>
<li>Section 19.4 discusses ways of defining operators with direct access to the representation of classes.</li>
</ul>
</li>
</ol>
<h4 id="18-3-2-Mixed-Mode-Arithmetic"><a href="#18-3-2-Mixed-Mode-Arithmetic" class="headerlink" title="18.3.2 Mixed-Mode Arithmetic"></a>18.3.2 Mixed-Mode Arithmetic</h4><ol start="34">
<li><p>To cope with <code>2+z</code>, where <code>z</code> is a <code>complex</code>, we need to define operator <code>+</code> to accept operands of different types.</p>
<p>In Fortran terminology, we need <em><strong>mixed-mode arithmetic</strong></em>.</p>
<p>We can achieve that simply by adding appropriate versions of the operators:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    complex&amp; <span class="hljs-keyword">operator</span>+=(complex a)<br>    &#123;<br>        re += a.re;<br>        im += a.im;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    complex&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">double</span> a)<br>    &#123;<br>        re += a;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The three variants of <code>operator+()</code> can be defined outside <code>complex</code>:</p>
<ul>
<li>```C++<br>complex operator+(complex a, complex b)<br>{<pre><code class="hljs">return a += b; // calls complex::operator+=(complex)
</code></pre>
}complex operator+(complex a, double b)<br>{<pre><code class="hljs">return &#123;a.real()+b, a.imag()&#125;; // real() and imag() are defined in section 18.3.6
</code></pre>
}complex operator+(double a, complex b)<br>{<pre><code class="hljs">return &#123;a+b.real(), b.imag()&#125;;
</code></pre>
}<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>Given these declarations of `+`, we can write:<br><br>```C++<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(complex x, complex y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> r1 = x+y; <span class="hljs-comment">// calls operator+(complex, complex)</span><br>    <span class="hljs-keyword">auto</span> r2 = x+<span class="hljs-number">2</span>; <span class="hljs-comment">// calls operator+(complex, double)</span><br>    <span class="hljs-keyword">auto</span> r3 = <span class="hljs-number">2</span>+x; <span class="hljs-comment">// calls operator+(double, complex)</span><br>    <span class="hljs-keyword">auto</span> r4 = <span class="hljs-number">2</span>+<span class="hljs-number">3</span>; <span class="hljs-comment">// built-in integer addition (for completeness)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="18-3-3-Conversions"><a href="#18-3-3-Conversions" class="headerlink" title="18.3.3 Conversions"></a>18.3.3 Conversions</h4><ol start="35">
<li><p>To cope with assignments and initialization of <code>complex</code> variables with scalars, we need a conversion of a scalar (integer or floating-point number) to a <code>complex</code>.</p>
<ul>
<li>For example:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex b&#123;<span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// should mean b.re=3, b.im=0</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">comp</span><span class="hljs-params">(complex x)</span></span><br><span class="hljs-function"></span>&#123;<br>    x = <span class="hljs-number">4</span>; <span class="hljs-comment">// should mean x.re=4, x.im=0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>We can achieve that by providing a constructor that takes a single number.</p>
<p>A constructor taking a single argument specifies a conversion from its argument type to the constuctors type.</p>
<ul>
<li>For example</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r) :re&#123;r&#125;, im&#123;<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// build a complex from a double</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The constructor specifies the traditional embedding of the real line in the complex plane.</li>
</ul>
</li>
<li><p>A constructor is a prescription for creating a value of a given type.</p>
<ul>
<li>The constructor is used when a value of a type is expected and when such a value can be created by a constructor for the value supplied as an initializer or assigned value.</li>
<li>Thus, a constructor requiring a single argument need not be called explicitly.</li>
<li>For example:</li>
<li>```C++<br>complex b{3};<br>// means<br>complex b{3,0};<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">37.</span> A user-defined conversion is implicitly applied only <span class="hljs-keyword">if</span> it is unique.<br><br>    - If you don<span class="hljs-number">&#x27;</span>t want a constructor to be used implicitly, declare it `<span class="hljs-keyword">explicit</span>`.<br><span class="hljs-number">38.</span> Naturally, we still need the constructor that takes two `<span class="hljs-type">double</span>`s, <span class="hljs-keyword">and</span> a <span class="hljs-keyword">default</span> constructor initializing a `complex` to `&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;` is also useful:<br><br>    ```C++<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    	<span class="hljs-type">double</span> re, im;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">complex</span>() :re&#123;<span class="hljs-number">0</span>&#125;, im&#123;<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// default constructor</span><br>        <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r) :re&#123;r&#125;, im&#123;<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// constructor from scalar to a complex</span><br>        <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125; <span class="hljs-comment">// constructor that takes two doubles</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Using default arguments, we can abbreviate:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>	<span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> i=<span class="hljs-number">0</span>) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>By default, copying <code>complex</code> values is defined as copying the real and imaginary parts.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    complex z;<br>    complex x&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    complex y&#123;x&#125;; <span class="hljs-comment">// y also has the value &#123;1,2&#125;</span><br>    z = x; <span class="hljs-comment">// z also has the value &#123;1,2&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="18-3-3-1-Conversions-of-Operands"><a href="#18-3-3-1-Conversions-of-Operands" class="headerlink" title="18.3.3.1 Conversions of Operands"></a>18.3.3.1 Conversions of Operands</h5><ol start="40">
<li><p>We defined three versions of each of the four standard arithmetic operators(<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(complex, complex);<br>complex <span class="hljs-keyword">operator</span>+(complex, <span class="hljs-type">double</span>);<br>complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span>, complex);<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>This can get tedious, and what is tedious easily becomes error-prone.</p>
<ul>
<li>What if we had three alternatives for the type of each argument for each funtion?<ul>
<li>We would need 3 versions of each single-argument function,  9 version of each two-argument function, 27 versions of each three-argument function, etc.</li>
</ul>
</li>
<li>Often these variants are very similar.<ul>
<li>In fact, almost all variants involve a simple conversion of arguments to a common type followed by a standard algorithm.</li>
</ul>
</li>
</ul>
</li>
<li><p>The alternative to providing different versions of a function for each combination of arguments is rely on conversions.</p>
<ul>
<li><p>For example, our <code>complex</code> class provides a constructor that converts a <code>double</code> to a <code>complex</code>.</p>
</li>
<li><p>Consequently, we could simply declare only one version of the equality operator for <code>complex</code>:</p>
<ul>
<li>```C++<br>bool operator==(complex, complex);void f(complex x, complex y)<br>{<pre><code class="hljs">x==y; // means operator(x,y)
x==3; // means operator(x,complex(3))
3==y; // means operator(complex(3),y)
</code></pre>
}<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">42.</span> There can be reasons for preferring to define separate functions.<br><br>    - For example, <span class="hljs-keyword">in</span> some cases the conversion can impose overhead, and <span class="hljs-keyword">in</span> other cases, a simpler algorithm can be used for  specific argument types.<br><br>    <span class="hljs-keyword">Where</span> such issues are not significant, relying on conversions and providing <span class="hljs-keyword">only</span> the most general variant of a <span class="hljs-function"><span class="hljs-keyword">function</span></span> -- plus possibly a few critical variants -- contain the combinatorial explosion of variants that can arise from mixed-mode arithmetic.<br><span class="hljs-number">43.</span> <span class="hljs-keyword">Where</span> several variants of a <span class="hljs-function"><span class="hljs-keyword">function</span></span> or an operator <span class="hljs-keyword">exist</span>, the compiler must pick <span class="hljs-string">&quot;the right&quot;</span> variant based on the argument types and  the available (standard and user-defined) conversions.<br><br>    - Unless a best match exists, an expression is ambiguous and is an error.<br><span class="hljs-number">44.</span> An object constructed by explicit or <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">use</span> of a constructor <span class="hljs-keyword">in</span> an expression (temporary objects; section <span class="hljs-number">10.3</span><span class="hljs-number">.4</span>) is automatic and will be destroyed at the first opportunity.<br><span class="hljs-number">45.</span> No <span class="hljs-keyword">implicit</span> user-defined conversions are applied to the left-hand side of a `.` (or a `-&gt;`). This is the <span class="hljs-keyword">case</span> even when `.` is <span class="hljs-keyword">implicit</span>.<br><br>    For example:<br><br>    - ```C++<br>      void g(<span class="hljs-keyword">complex</span> z)<br>      &#123;<br>          <span class="hljs-number">3</span>+z; // Ok: <span class="hljs-keyword">complex</span>(<span class="hljs-number">3</span>)+z<br>          <span class="hljs-number">3.</span>operator+=(z); // Error: <span class="hljs-number">3</span> is not a <span class="hljs-keyword">class</span> object (no user-defined conversion)<br>          <span class="hljs-number">3</span>+=z; // Error: <span class="hljs-number">3</span> is not a <span class="hljs-keyword">class</span> object (. is <span class="hljs-keyword">implicit</span>)<br>      &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Thus, you can approximate tthe notion that an operator requires an lvaue as its left-hand operand by making that operator a member.</p>
<ul>
<li>However, that is only an approximation because it is possible to access a temporary with a modifying operation, such as <code>operator+=()</code>:</li>
<li>```C++<br>complex x{4,5};<br>complex z{sqrt(x)+={1,2}}; // like tmp=sqrt(x), tmp+={1,2}<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">      - If we don&#x27;t want implicit conversions, we can use `explicit` to suppress them.<br><br>#### <span class="hljs-number">18.3</span>.<span class="hljs-number">4</span> Literals<br><br><span class="hljs-number">46</span>. We have literals of built-in types.<br><br>    - For example, `1,<span class="hljs-number">2</span>` <span class="hljs-literal">and</span> `12e3` are literals of type `double`.<br><br>    For `complex`, we can come pretty close to that by declaring constructors `constexpr`.<br><br><span class="hljs-title">    - For example:</span><br><br>      - ```C++<br>        class complex&#123;<br><span class="hljs-title">        public:</span><br><span class="hljs-title">            constexpr complex(double r=0, double i=0) :</span>re&#123;r&#125;, im&#123;i&#125; &#123;&#125;<br>            // ...<br>        &#125;<br></code></pre></td></tr></table></figure></li>
<li>Given that, a <code>complex</code> can be constructed from its constituent parts at compile time just like a literal from a built-in type. For example:</li>
<li>```C++<br>complex z1{1,2,12e3};<br>constexpr complex z2{1.2,12e3}; // guaranteed compile-time initialization<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">    - When constructors are simple <span class="hljs-keyword">and</span> inline, <span class="hljs-keyword">and</span> especially when they are `constexpr`, it <span class="hljs-keyword">is</span> quite reasonable to think of constructor invocations <span class="hljs-keyword">with</span> literal arguments <span class="hljs-keyword">as</span> literals.<br><span class="hljs-number">47.</span> It <span class="hljs-keyword">is</span> possible to go further <span class="hljs-keyword">and</span> introduce a user-defined literal (section <span class="hljs-number">19.2</span><span class="hljs-number">.6</span>) <span class="hljs-keyword">in</span> support of our `<span class="hljs-built_in">complex</span>` <span class="hljs-built_in">type</span>.<br><br>    In particular, we could define `i` to be a suffix meaning <span class="hljs-string">&quot;imaginary.&quot;</span><br><br>    - For example:<br><br>      - ```c++<br>        constexpr <span class="hljs-built_in">complex</span>&lt;double&gt; operato<span class="hljs-string">r&quot;&quot;</span>i(long double d) // imaginary literal<br>        &#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,d&#125;; // <span class="hljs-built_in">complex</span> <span class="hljs-keyword">is</span> a literal <span class="hljs-built_in">type</span> (user-defined)<br>        &#125;<br></code></pre></td></tr></table></figure></li>
<li>This would allow us to wirte:</li>
<li>```C++<br>complex z1{1.2+12e3i};complex f(double d)<br>{<pre><code class="hljs">auto x&#123;2.3i&#125;;
return x+sqrt(d+12e3i)+12e3i;
</code></pre>
}<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fortran">- The user-defined literal gives us one advantage over what we get from `constexpr` constructors:<br><br>  - We can <span class="hljs-keyword">use</span> user-defined literals <span class="hljs-keyword">in</span> the middle of expressions <span class="hljs-keyword">where</span> `&#123;&#125;` notation can <span class="hljs-keyword">only</span> be used when qualified by a <span class="hljs-keyword">type</span> <span class="hljs-keyword">name</span>.<br>- The example above is roughly equivalent to:<br>- ```C++<br>  <span class="hljs-keyword">complex</span> z1&#123;<span class="hljs-number">1.2</span>,<span class="hljs-number">12e3</span>&#125;;<br>  <br>  <span class="hljs-keyword">complex</span> f(<span class="hljs-keyword">double</span> d)<br>  &#123;<br>      <span class="hljs-keyword">complex</span> x&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2.3</span>&#125;;<br>      <span class="hljs-keyword">return</span> x+<span class="hljs-built_in">sqrt</span>(<span class="hljs-keyword">complex</span>&#123;d,<span class="hljs-number">12e3</span>&#125;)+<span class="hljs-keyword">complex</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">12e3</span>&#125;;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>I suspect that the choice of style of literal depends on your sense of aesthetics and the conventions of your field of work.</p>
<p>The standard-library <code>complex</code> uses <code>constexpr</code> constructors rather that a user-defined literal.</p>
</li>
</ol>
<h4 id="18-3-5-Accessor-Functions"><a href="#18-3-5-Accessor-Functions" class="headerlink" title="18.3.5 Accessor Functions"></a>18.3.5 Accessor Functions</h4><ol start="50">
<li><p>So far, we have provided class <code>complex</code> with constructors and arithmetic operators only.</p>
<p>In particular, we often need to be able to examine and change the value of the real and imaginary parts:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">compelx</span>&#123;<br>	<span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> im;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">real</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123;re = r;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">double</span> i)</span> </span>&#123;im = i;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>I don’t consider it a good idea to provide individual access to all members of a class; in general, it is not.</p>
<ul>
<li>For many types, individual access (sometimes referred to as <em>get-and-set functions</em>) is an invitation to disaster.</li>
<li>If we are not careful, individual access could compromise an invariant, and it typically complicates changes to the representation.</li>
<li>For example:<ul>
<li>consider the opportunities for misuse from providing getters and setters for every member of the <code>Date</code> from section 16.3 or (even more so) for the <code>String</code> from section 19.3.</li>
</ul>
</li>
</ul>
</li>
<li><p>However, for <code>complex</code>, <code>real()</code> and <code>imag()</code> are sematically significant:</p>
<ul>
<li><p>Some algorithms are most cleanly written if they can set the real and imaginary parts independently.</p>
</li>
<li><p>For example:</p>
<ul>
<li>Given <code>real()</code> and <code>imag()</code>, we can simplify simple, common, and useful operations, such as <code>==</code>, as nonmember functions (without compromising performance).</li>
<li>```c++<br>inline bool operator==(complex a, complex b)<br>{<pre><code class="hljs">return a.real()==b.real() &amp;&amp; a.imag()==b.imag();
</code></pre>
}<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>#### <span class="hljs-number">18.3</span><span class="hljs-number">.6</span> Helper Functions<br><br><span class="hljs-number">51.</span> If we put all the bits <span class="hljs-keyword">and</span> pieces together, the `complex` <span class="hljs-keyword">class</span> <span class="hljs-title class_">becomes</span>:<br><br>    ```C++<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    	<span class="hljs-type">double</span> re, im;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">double</span> r=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> i=<span class="hljs-number">0</span>)</span> : re(r), im(i) &#123;</span>&#125;<br>    <br>        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im;&#125;<br>    <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">real</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123; re = r;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">double</span> i)</span> </span>&#123; im = i;&#125;<br>    <br>        complex&amp; <span class="hljs-keyword">operator</span>+=(complex);<br>        complex&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">double</span>);<br>    <br>        <span class="hljs-comment">// -=, *= and /=</span><br>    &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In addition, we must provide a number of helper functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(complex, compelx);<br>complex <span class="hljs-keyword">operator</span>+(complex, <span class="hljs-type">double</span>);<br>complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span>, complex);<br><br><span class="hljs-comment">// binary -,*, and /</span><br><br>complex <span class="hljs-keyword">operator</span>-(complex); <span class="hljs-comment">// unary minus</span><br>complex <span class="hljs-keyword">operator</span>+(complex); <span class="hljs-comment">// unary plus</span><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(compelx, complex);<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(complex, complex);<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; complex&amp;); <span class="hljs-comment">//input</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;, complex); <span class="hljs-comment">// output</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Note that the members <code>real()</code> and <code>imag()</code> are essential for defining the comparisons.</li>
<li>The definitions of most of the following helper functions similarly rely on <code>real()</code> and <code>imag()</code>.</li>
</ul>
</li>
<li><p>We might provide functions to allow users to think in terms of polar coordinates:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">complex <span class="hljs-title">polar</span><span class="hljs-params">(<span class="hljs-type">double</span> rho, <span class="hljs-type">double</span> theta)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">conj</span><span class="hljs-params">(complex)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">abs</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">arg</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">norm</span><span class="hljs-params">(complex)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">(complex)</span></span>; <span class="hljs-comment">// for notational convenience</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(complex)</span></span>; <span class="hljs-comment">// for notational convenience</span><br></code></pre></td></tr></table></figure></li>
<li><p>Finally, we must provide an appropriate set of standard mathematical functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">complex <span class="hljs-title">acos</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">asin</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">atan</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure></li>
<li><p>From a user’s point of view, the <code>complex</code> type presented here is almost identical to the <code>complex&lt;double&gt;</code> found in <code>&lt;complex&gt;</code> in the standard library.</p>
</li>
</ol>
<h3 id="18-4-Type-Conversion"><a href="#18-4-Type-Conversion" class="headerlink" title="18.4 Type Conversion"></a>18.4 Type Conversion</h3><ol start="55">
<li><p>Type conversion can be accomplished by:</p>
<ul>
<li>A constructor taking a single argument</li>
<li>A conversion operator</li>
</ul>
<p>In either case the conversion can be</p>
<ul>
<li><code>explicit</code>;<ul>
<li>that is, the conversion is only performed in a direct initialization, i.e., as an initialier not using a <code>=</code>.</li>
</ul>
</li>
<li>Implicit;<ul>
<li>that is, it will be applied wherever it can be used unambiguously, e.g., as a function argument.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="18-4-1-Conversion-Operators"><a href="#18-4-1-Conversion-Operators" class="headerlink" title="18.4.1 Conversion Operators"></a>18.4.1 Conversion Operators</h4><ol start="56">
<li><p>Using a constructor taking a single argument to specify type conversion is convenient but has implications that can be undesirable.</p>
<p>Also, a constructor cannot specify</p>
<ul>
<li>an implicit conversion from a user-defined type to a built-in type (because the built-in types are not classes), or</li>
<li>a conversion from a new class to a previously defined class (without modifying the declaration for the old class).</li>
</ul>
<p>These problems can be handled by defining a <em><strong>conversion operator</strong></em> for the source type.</p>
<ul>
<li><p><strong>A member function <code>X::operator T()</code>, where <code>T</code> is a type name, defines a conversion from <code>X</code> to <code>T</code></strong>.</p>
<ul>
<li><p>For example, we could define a 6-bit non-negative integer, <code>Tingy</code>, that can mix freely with integers in arithmetic operations. <code>Tiny</code> throws <code>Bad_range</code> if its operations overflow or underflow:</p>
</li>
<li><p>```C++<br>class Tiny{</p>
<pre><code class="hljs">char v;
void assign(int i) &#123; if(i&amp;~077) throw Bad_range(); v=i;&#125;
</code></pre>
<p>public:</p>
<pre><code class="hljs">class Bad_range();

Tiny(int i) &#123; assign(i);&#125;
Tiny&amp; operator=(int i) &#123; assign(i); return *this;&#125;

operator int() const &#123; return v;&#125; // conversion to int function
</code></pre>
<p>};</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>  - The range <span class="hljs-keyword">is</span> checked whenever a `Tiny` <span class="hljs-keyword">is</span> initialized <span class="hljs-keyword">by</span> an `<span class="hljs-type">int</span>` <span class="hljs-keyword">and</span> whenever an `<span class="hljs-type">int</span>` <span class="hljs-keyword">is</span> assigned <span class="hljs-keyword">to</span> one.<br>  - <span class="hljs-keyword">No</span> range <span class="hljs-keyword">check</span> <span class="hljs-keyword">is</span> needed <span class="hljs-keyword">when</span> we <span class="hljs-keyword">copy</span> a `Tiny`, so the <span class="hljs-keyword">default</span> <span class="hljs-keyword">copy</span> constructor <span class="hljs-keyword">and</span> assignment are just right.<br>- <span class="hljs-keyword">To</span> <span class="hljs-keyword">enable</span> the usual <span class="hljs-type">integer</span> operations <span class="hljs-keyword">on</span> `Tiny` variables, we define the implicit <span class="hljs-keyword">conversion</span> <span class="hljs-keyword">from</span> `Tiny` <span class="hljs-keyword">to</span> `<span class="hljs-type">int</span>`, `Tiny::<span class="hljs-keyword">operator</span> <span class="hljs-type">int</span>()`.<br>- Note that **the <span class="hljs-keyword">type</span> being converted <span class="hljs-keyword">to</span> <span class="hljs-keyword">is</span> part <span class="hljs-keyword">of</span> the <span class="hljs-type">name</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">operator</span> <span class="hljs-keyword">and</span> cannot be repeated <span class="hljs-keyword">as</span> the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">conversion</span> <span class="hljs-keyword">function</span>**:<br><br>  - ```C++<br>    Tiny::<span class="hljs-keyword">operator</span> <span class="hljs-type">int</span>() const &#123; <span class="hljs-keyword">return</span> v;&#125; // right<br>    <span class="hljs-type">int</span> Tiny::<span class="hljs-keyword">operator</span> <span class="hljs-type">int</span>() const &#123; <span class="hljs-keyword">return</span> v;&#125; // error<br></code></pre></td></tr></table></figure>
<ul>
<li>In this respect also, a conversion operator resembles a constructor. (constructor also doesn’t have a return type)</li>
</ul>
</li>
<li><p>Whenever a <code>Tiny</code> appears where an <code>int</code> is needed, the appropriate <code>int</code> is used. For example:</p>
<ul>
<li>```C++<br>int main()<br>{<pre><code class="hljs">Tiny c1 = 2;
Tiny c2 = 62;
Tiny c3 = c2 - c1; // c3 = 60
Tiny c4 = c3; // no range check (not necessary)
int i = c1 + c2; // i = 64

c1 = c1+c2; // range error: c1 can&#39;t be 64 (6-bit non-negative integer)
i = c3-64; // i = -4
c2 = c3-64; // range error: c2 can&#39;t be -4
c3 = c4; // no range check (not necessary)
</code></pre>
}<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-number">57</span>. Conversion functions appear <span class="hljs-keyword">to</span> be particularly useful <span class="hljs-keyword">for</span> handling data structures <span class="hljs-keyword">when</span> reading (implemented <span class="hljs-keyword">by</span> a conversion <span class="hljs-keyword">operator</span>) <span class="hljs-built_in">is</span> trivial, <span class="hljs-keyword">while</span> assignment <span class="hljs-built_in">and</span> initialization are distinctly less trivial.<br><span class="hljs-number">58</span>. The `istream` <span class="hljs-built_in">and</span> `ostream` types rely <span class="hljs-keyword">on</span> a conversion <span class="hljs-keyword">function</span> <span class="hljs-keyword">to</span> enable statements such <span class="hljs-keyword">as</span>:<br><br>    ```C++<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;x)<br>        cout&lt;&lt;x;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>The input operation <code>cin&gt;&gt;x</code> returns an <code>istream&amp;</code>. That value is implicitly converted to a value indicating the state of <code>cin</code>. This value can then be tested by the <code>while</code>.</p>
</li>
<li><p>However, it is typically <em><strong>not</strong></em> a good idea to define an implicit conversion from one type to another in such a way that information is lost in the conversion.</p>
</li>
</ul>
</li>
<li><p>In general, it is wise to be sparing in the introduction of conversion operators.</p>
<ul>
<li>When used in excess, they lead to ambiguities. Such ambiguities are caught by the compiler, but they can be a nuisance to resolve.</li>
<li>Probably the best idea is initially to do conversions by named functions, such as <code>X::make_int()</code>.<ul>
<li>If such a function becomes popular enough to make explicit use inelegant, it can be replaced by a conversion operator <code>X::operator int()</code>.</li>
</ul>
</li>
</ul>
</li>
<li><p>If both user-defined conversions and user-defined operators are defined, it is possible to get ambiguities between the user-defined operators and the built-in operators. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(Tiny, Tiny);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Tiny t, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    t+i; <span class="hljs-comment">// Error, ambiguous: &quot;operator+(t,Tiny(i))&quot; or &quot;int(t)+i&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="18-4-2-explicit-Conversion-Operators"><a href="#18-4-2-explicit-Conversion-Operators" class="headerlink" title="18.4.2 explicit Conversion Operators"></a>18.4.2 <code>explicit</code> Conversion Operators</h4><ol start="61">
<li><p>Conversion operators tend to be defined so that they can be used everywhere.</p>
<p>However, it is possible to declare a conversion operator <code>explicit</code> and have it apply only for direct initialization, where an equivalent <code>explicit</code> constructor would have beed used.</p>
<ul>
<li><p>For example, the standard-library <code>unique_ptr</code> has an explicit conversion to <code>bool</code>:</p>
</li>
<li><p>```C++<br>template&lt;typename T, typename D = default_delete<T>&gt;<br>class unique_ptr{<br>public:</p>
<pre><code class="hljs">// ...
explicit operator bool() const noexcept; // dose *this hold a pointer(that is not nullptr)?
</code></pre>
<p>};</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- The reason to declare <span class="hljs-keyword">this</span> conversion <span class="hljs-keyword">operator</span> `<span class="hljs-keyword">explicit</span>` is to avoid its use in surprising contexts. Consider:<br><br>  - ```C++<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">(unique_ptr&lt;Record&gt; p, unique_ptr&lt;<span class="hljs-type">int</span>&gt; q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!p) <span class="hljs-comment">// Ok: We want this use</span><br>            <span class="hljs-keyword">throw</span> Invalid_unique_ptr&#123;&#125;;<br>    <br>        <span class="hljs-type">bool</span> b = p; <span class="hljs-comment">// error; suspicious use</span><br>        <span class="hljs-type">int</span> x = p+q; <span class="hljs-comment">// error; we definitly don&#x27;t want this</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>Had <code>unique_ptr</code>‘s conversion to bool not been <code>explicit</code>, the last two definitions would have compiled.</p>
<ul>
<li>The value of <code>b</code> would have become <code>true</code> and the value of <code>x</code> would have become <code>1</code> or <code>2</code> (depending on whether <code>q</code> was valid or not).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="18-4-3-Ambiguities"><a href="#18-4-3-Ambiguities" class="headerlink" title="18.4.3 Ambiguities"></a>18.4.3 Ambiguities</h4><ol start="62">
<li><p>An assignment of a value of type <code>V</code> to an object of class <code>X</code> is legal if there is an assignment operator <code>X::operator=(Z)</code> so that <code>v</code> is <code>Z</code> or there is a unique conversion of <code>V</code> to <code>Z</code>.</p>
<ul>
<li>Initialization is treated equivalently.</li>
</ul>
</li>
<li><p>In some cases, a value if the desired type can be constructed by repeated use of constructors or conversion operators.</p>
<ul>
<li>This must be handled by explicit conversions; only one level of user-defined implicit conversion is legal.</li>
</ul>
<p>In some cases, a value of the desired type can be constructed in more than one way; such cases are illegal. For example:</p>
<ul>
<li>```C++<br>class X{ /<em>…</em>/ X(int); X(const char*);};<br>class Y{ /<em>…</em>/ Y(int);};<br>class Z{/<em>…</em>/ Z(int);};X f(X);<br>Y f(Y);Z g(Z);void k1()<br>{<pre><code class="hljs">f(1); // Error: ambiguous f(X(1)) or f(Y(1))?
f(X(1)); // OK
f(Y(1)); // OK

g(&quot;Mack&quot;); // Error:two user-defined conversions needed; g(Z&#123;X&#123;&quot;Mack&quot;&#125;&#125;) not tried
g(X&#123;&quot;Doc&quot;&#125;); // OK: g(Z&#123;X&#123;&quot;Doc&quot;&#125;&#125;)
g(Z&#123;&quot;Suzy&quot;&#125;); // OK: g(Z&#123;X&#123;&quot;Suzy&quot;&#125;&#125;)
</code></pre>
}<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">64.</span> User-<span class="hljs-function">defined conversions are considered only <span class="hljs-keyword">if</span> a call cannot be resolved without <span class="hljs-title">them</span> (<span class="hljs-params">i.e., <span class="hljs-keyword">using</span> only built-<span class="hljs-keyword">in</span> conversions</span>). For example:</span><br><span class="hljs-function"></span><br><span class="hljs-function">    - ```C++</span><br><span class="hljs-function">      <span class="hljs-keyword">class</span> XX</span>&#123;<span class="hljs-comment">/*...*/</span> XX(<span class="hljs-built_in">int</span>);&#125;;<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span>(<span class="hljs-params"><span class="hljs-built_in">double</span></span>)</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span>(<span class="hljs-params">XX</span>)</span>;<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">k2</span>()</span><br>      &#123;<br>          h(<span class="hljs-number">1</span>); <span class="hljs-comment">// h(double&#123;1&#125;) or h(XX&#123;1&#125;)? h(double&#123;1&#125;)!</span><br>      &#125;<br></code></pre></td></tr></table></figure></li>
<li>The call <code>h(1)</code> means <code>h(double(1))</code> because that alternative uses only a standard conversion rather than a user-defined conversion.</li>
</ul>
</li>
<li><p>The rules for conversion are neither the simplest to implement, nor the simplest to document, nor the most general that could be devised.</p>
<p>They are, however, considerably safer, and the resulting resolutions are typically less surprising than alternatives.</p>
<p>It is far easier to manually resolve an ambiguity than to find an error caused by an unsuspected conversion.</p>
</li>
<li><p>The insistence on strict bottom-up analysis implies that the return type is not used in overloading function. For example:</p>
<ul>
<li>```C++<br>class Quad{<br>public:<pre><code class="hljs">Quad(double);
// ...
</code></pre>
};Quad operator+(Quad,Quad); // the return type of + is Quadvoid f(double a1, double a2)<br>{<pre><code class="hljs">Quad r1 = a1+a2; // double-precision floating-point add (the return type Quad of + is not used.)
Quad r2 = Quad&#123;a1&#125;+a2; // force quad arithmetic
</code></pre>
}<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- The reason <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> design choice is partly that strict bottom-up analysis is more comprehensible <span class="hljs-keyword">and</span> partly that it is <span class="hljs-keyword">not</span> considered the compiler<span class="hljs-number">&#x27;</span>s job to decide which precision the programmer might want <span class="hljs-keyword">for</span> the addition.<br><br>Once the types of both sides of an initialization <span class="hljs-keyword">or</span> assignment have been determined, both types are used to resolve the initialization <span class="hljs-keyword">and</span> assignment. For example:<br><br>- ```C++<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Real</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-comment">// ...</span><br>  &#125;;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Real a)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-type">double</span> d = a; <span class="hljs-comment">// d = a.double();</span><br>      <span class="hljs-type">int</span> i = a; <span class="hljs-comment">// i = a.int();</span><br>  <br>      d = a; <span class="hljs-comment">// d = a.double();</span><br>      i = a; <span class="hljs-comment">// i = a.int();</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>In these cases, the type analysis is still bottom-up, with only a single operator and its argument types considered at any one time.</li>
</ul>
</li>
</ol>
<h3 id="18-5-Advice"><a href="#18-5-Advice" class="headerlink" title="18.5 Advice"></a>18.5 Advice</h3><ol>
<li>Define operators primarily to mimic conventional usage.</li>
<li>Redefine or prohibit copying if the default is not appropriate for a type.</li>
<li>For large operands, use <code>const</code> reference argument type.</li>
<li>For large results, use a move constructor.</li>
<li>Prefer member functions over nonmembers for operations that need access to the representation.</li>
<li>Prefer nonmember functions over members for operations that do not need access to the represention.</li>
<li>Use namespaces to associate helper functions with “their” class.</li>
<li>Use nonmember functions for symmetric operators.</li>
<li>Use member functions to express operators that require an lvalue as their left-hand operand.</li>
<li>Use user-defined literals to mimic conventional notation.</li>
<li>Provide “<code>set()</code> and <code>get()</code> functions” for a data member only if the fundamental semantics of a class require them.</li>
<li>Be cautious about introducing implicit conversions.</li>
<li>Avoid value-destroying (“narrowing”) conversions.</li>
<li>Do not define the same conversion as both a constructor and a conversion operator. (60)</li>
</ol>
<h2 id="Chapter-19-Special-Operators"><a href="#Chapter-19-Special-Operators" class="headerlink" title="Chapter 19. Special Operators"></a>Chapter 19. Special Operators</h2><ul>
<li>Introduction</li>
<li>Special Operators<ul>
<li>Subscripting</li>
<li>Function Call</li>
<li>Dereferencing</li>
<li>Increment and Decrement</li>
<li>Allocation and Deallocation</li>
<li>User-Defined Literals</li>
</ul>
</li>
<li>A String Class<ul>
<li>Essential Operations</li>
<li>Access to Charactors</li>
<li>Representation</li>
<li>Member Functions</li>
<li>Helper Functions</li>
<li>Using Our String</li>
</ul>
</li>
<li>Friends<ul>
<li>Finding Friends</li>
<li>Friends and Members</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="19-1-Introduction"><a href="#19-1-Introduction" class="headerlink" title="19.1 Introduction"></a>19.1 Introduction</h3><ol>
<li>Overloading is not just arithmetic and logical operations.<ul>
<li>In fact, operators are crucial in the design of:<ul>
<li>containers (e.g., <code>vector</code> and <code>map</code>)</li>
<li>“smart pointer”(e.g., <code>unique_ptr</code> and <code>shared_ptr</code>)</li>
<li>iterators</li>
<li>other classes concerned with resource management.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="19-2-Special-Operators"><a href="#19-2-Special-Operators" class="headerlink" title="19.2 Special Operators"></a>19.2 Special Operators</h3><ol start="2">
<li>Special operators <code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>++</code>, <code>--</code>, <code>new</code>, <code>delete</code> are special only in that the mapping from their use in the code to a programmer’s definition differs slightly from that used for conventional unary and binary operators, such as <code>+</code>, <code>&lt;</code>, and <code>~</code>.<ul>
<li>The <code>[]</code>(subscript) and <code>()</code>(call) operators are among the most useful user-defined operators.</li>
</ul>
</li>
</ol>
<h4 id="19-2-1-Subscripting"><a href="#19-2-1-Subscripting" class="headerlink" title="19.2.1 Subscripting"></a>19.2.1 Subscripting</h4><ol start="3">
<li><p>An <code>operator[]</code> function can be used to give subscripts a meaning for class objects.</p>
<p>The second argument (the subscript) of an <code>operator[]</code> function may be of any type.</p>
<p>This makes it possible to define <code>vector</code>s, associative arrats, etc.</p>
<ul>
<li><p>As an example, we can define a simple associative array type like this:</p>
</li>
<li><p>```C++<br>struct Assoc{</p>
<pre><code class="hljs">vector&lt;pair&lt;string,int&gt;&gt; vec; // vector of &#123;name,value&#125; pairs

const int&amp; operator[](const string &amp;) const; // return reference to const element
int&amp; operator[](const string&amp;); // return reference to element
</code></pre>
<p>};</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>  - An `Assoc` keeps a vector of `std::pair`s.<br>- The implementation uses the same trivial <span class="hljs-keyword">and</span> inefficient search method.<br>- ```C++<br>  <span class="hljs-type">int</span>&amp; Assoc::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> string&amp; s)<br>      <span class="hljs-comment">// search for s; return a reference to it value if found</span><br>      <span class="hljs-comment">// otherwise, make a new pair &#123;s,0&#125; and return a reference to its value</span><br>  &#123;<br>  	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : vec)<br>          <span class="hljs-keyword">if</span>(s == x.first) <span class="hljs-keyword">return</span> x.second;<br>  <br>      vec.<span class="hljs-built_in">push_back</span>(&#123;s,<span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// initial value:0</span><br>  <br>      <span class="hljs-keyword">return</span> vec.<span class="hljs-built_in">back</span>().second; <span class="hljs-comment">// return last element</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>We can use <code>Assoc</code> like this:</p>
</li>
<li><p>```C++<br>int main() // count the occurrences of each word on input<br>{</p>
<pre><code class="hljs">Assoc values;
string buf;
while(cin&gt;&gt;buf) ++values[buf];
for(auto x : values.vec)
    cout &lt;&lt; &quot;&#123;&quot; &lt;&lt; x.first &lt;&lt; &quot;,&quot; &lt;&lt; x.second &lt;&lt; &quot;&#125;\n&quot;;
</code></pre>
<p>}</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">   - The standard-library `map` <span class="hljs-keyword">and</span> `unordered_map` are further developments of the idea of an associative array <span class="hljs-keyword">with</span> less naive implementations.<br><span class="hljs-number">4.</span> An `<span class="hljs-keyword">operator</span>[]()` must be a non-<span class="hljs-keyword">static</span> member function.<br><br><span class="hljs-meta">#### 19.2.2 Function Call</span><br><br><span class="hljs-number">5.</span> Function call, that <span class="hljs-keyword">is</span> the notation ***expression(expression-list)***, can be interpreted <span class="hljs-keyword">as</span> a binary operation <span class="hljs-keyword">with</span> the ***expression*** <span class="hljs-keyword">as</span> the left-hand operand <span class="hljs-keyword">and</span> the ***expression-list*** <span class="hljs-keyword">as</span> the right-hand operand.<br><br>   <br><br><span class="hljs-number">6.</span> The call <span class="hljs-keyword">operator</span>, `()`, can be overloaded <span class="hljs-keyword">in</span> the same way <span class="hljs-keyword">as</span> other operators can. For example:<br><br>   ```C++<br>   <span class="hljs-keyword">struct</span> Action&#123;<br>       <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">operator</span>()(<span class="hljs-params"><span class="hljs-built_in">int</span></span>)</span>;<br>       <span class="hljs-function">pair&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">operator</span>()(<span class="hljs-params"><span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span></span>)</span>;<br>       <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">operator</span>()(<span class="hljs-params"><span class="hljs-built_in">double</span></span>)</span>;<br>       <span class="hljs-comment">// ...</span><br>   &#125;;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params">Action act</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> x = act(<span class="hljs-number">2</span>);<br>       auto y = act(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>       <span class="hljs-built_in">double</span> z = act(<span class="hljs-number">2.3</span>)<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>An argument list for an <code>operator()()</code> is evaluated and checked according to the usual argument-passing-rules.</p>
</li>
</ul>
<p>Overloading the function call operator seems to be useful primarily for defining types that have only a single operation and for types for which one operation is predominant.</p>
<p>The <em><strong>call operator</strong></em> is also known as the <em><strong>application operator</strong></em>.</p>
</li>
<li><p>The most obvious and also the most important, use of the <code>()</code> operator is to provide the usual function call syntax for objects that in some way behave like functions.</p>
<p>An object that acts like a function is often call a <em><strong>function-liker object</strong></em> or simply a <em><strong>function object</strong></em>.</p>
<ul>
<li><p>Such function objects allow us to write code that takes nontrivial operations as parameters.</p>
</li>
<li><p>In many cases, it is essential that function objects can hold data needed to perform their operation.</p>
</li>
<li><p>For example, we can define a class with an <code>operator()()</code> that adds a stored value to its argument:</p>
<ul>
<li><p>```C++<br>class Add{</p>
<pre><code class="hljs">complex val;
</code></pre>
<p>public:</p>
<pre><code class="hljs">Add(complex c) :val(c) &#123;&#125; // save a value
Add(double r, double i): val&#123;&#123;r,i&#125;&#125; &#123;&#125;

void operator()(complex&amp; c) const &#123;c += val;&#125; // add a value to argument
</code></pre>
<p>};</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- An <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">class</span> `Add` is initialized <span class="hljs-keyword">with</span> a complex number, <span class="hljs-keyword">and</span> <span class="hljs-keyword">when</span> invoked using `<span class="hljs-literal">()</span>`, it  adds that number <span class="hljs-keyword">to</span> its argument. For example:<br>- ```C++<br>  void h(vector&lt;complex&gt;&amp; vec, <span class="hljs-built_in">list</span>&lt;complex&gt;&amp; lst, complex z)<br>  &#123;<br>      <span class="hljs-keyword">for</span><span class="hljs-constructor">_each(<span class="hljs-params">vec</span>.<span class="hljs-params">begin</span>()</span>,vec.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,Add&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br>      <span class="hljs-keyword">for</span><span class="hljs-constructor">_each(<span class="hljs-params">lst</span>.<span class="hljs-params">begin</span>()</span>,lst.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,Add&#123;z&#125;)<br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>This will add <code>complex&#123;2,3&#125;</code> to every element of the <code>vector</code> and <code>z</code> to every element of the <code>list</code>.</p>
<ul>
<li>Note that Add{z} constructs an object that is used repeatedly by <code>for_each()</code>:  <code>Add&#123;z&#125;</code>‘s <code>operator()()</code> is called for each element of the sequence.</li>
</ul>
</li>
<li><p>This all works because <code>for_each</code> is a template that applies <code>()</code> to its third argument without caring exactly what that third argument really is:</p>
<ul>
<li>```C++<br>template&lt;typename Iter, typename Fct&gt;<br>Fct for_each(Iter b, Iter e, Fct f)<br>{<pre><code class="hljs">while(b != e) f(*b++);
return f;
</code></pre>
}<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">         - At <span class="hljs-built_in">first</span> glance, this technique may look esoteric, but it <span class="hljs-built_in">is</span> simple, efficient, <span class="hljs-keyword">and</span> extremely useful.<br><br><span class="hljs-number">8</span>. Note that a <span class="hljs-built_in">lambda</span> expression (section <span class="hljs-number">3.4</span><span class="hljs-number">.3</span>, section <span class="hljs-number">11.4</span>) <span class="hljs-built_in">is</span> basically a syntax <span class="hljs-keyword">for</span> defining a function object. For <span class="hljs-built_in">example</span>, we  could have written:<br><br>   ```C++<br>   void h2(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">complex</span>&gt;&amp; vec, list&lt;<span class="hljs-built_in">complex</span>&gt;&amp; lst, <span class="hljs-built_in">complex</span> z)<br>   &#123;<br>       for_each(vec.begin(),vec.end(),[](<span class="hljs-built_in">complex</span>&amp; a)&#123; a+=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;&#125;);<br>       for_each(lst.begin(),lst.end(),[](<span class="hljs-built_in">complex</span>&amp; a)&#123; a+=z;&#125;);<br>   &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>In this case, each of the lambda expressions generates the equivalent of the function object <code>Add</code>.</p>
</li>
</ul>
</li>
<li><p>Other popular uses of <code>operator()()</code> are as a substring operator and as a subscripting operator for multidimensional arrays.</p>
</li>
<li><p>An <code>operator()()</code> must be a non-<code>static</code> member function.</p>
</li>
<li><p>Function call operators are often templates.</p>
</li>
</ol>
<h4 id="19-2-3-Dereferencing"><a href="#19-2-3-Dereferencing" class="headerlink" title="19.2.3 Dereferencing"></a>19.2.3 Dereferencing</h4><ol start="12">
<li><p>The dereferencing operator, <code>-&gt;</code> (also known as the <em><strong>arrow</strong></em> operator), can be defined as a unary postfix operator. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ptr</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    X* <span class="hljs-keyword">operator</span>-&gt;();<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Objects of class <code>Ptr</code> can be used to access members of class <code>X</code> in a very similar manner to the way pointers are used. For example:</li>
<li>```C++<br>void f(Ptr p)<br>{<pre><code class="hljs">p-&gt;m = 7; // (p.operator-&gt;())-&gt;m = 7
</code></pre>
}<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl"><br>- T<span class="hljs-function"><span class="hljs-title">he</span> transformation of the object `p` into the pointer `p.operator-&gt;</span>()` does <span class="hljs-built_in">not</span> depend on the member `m` pointed to.<br>- T<span class="hljs-function"><span class="hljs-title">hat</span> <span class="hljs-keyword">is</span> the sense <span class="hljs-built_in">in</span> which `operator-&gt;</span>()` <span class="hljs-keyword">is</span> a unary <span class="hljs-keyword">postfix</span> operator.<br>- H<span class="hljs-function"><span class="hljs-title">owever</span>, there <span class="hljs-keyword">is</span> no new syntax introduced, so a member <span class="hljs-keyword">name</span> <span class="hljs-keyword">is</span> still required after the `-&gt;</span>`. For example:<br><br>  - ```C++<br>    void g(Ptr p)<br>    &#123;<br>        X* <span class="hljs-function"><span class="hljs-title">q1</span> = p-&gt;</span>; <span class="hljs-comment">// sytax error</span><br>        X* <span class="hljs-function"><span class="hljs-title">q2</span> = p.operator-&gt;</span>(); <span class="hljs-comment">// OK</span><br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Overloading <code>-&gt;</code> is primarily useful for creating “smart pointers,” that is, objects that act like pointers and in addition perform some action whenever an object is accessed through them.</p>
<ul>
<li>The standard-library “smart pointers” <code>unique_ptr</code> and <code>shared_ptr</code> provide operator <code>-&gt;</code>.</li>
</ul>
</li>
<li><p>As an example, we could define a class <code>Disk_ptr</code> for accessing objects stored on disk.</p>
<ul>
<li><code>Disk_ptr</code>‘s constructor takes a name that can be used to find the object on disk,</li>
<li><code>Disk_ptr::operator-&gt;()</code> brings the object into main memory when accessed through its <code>Disk_ptr</code>,</li>
<li>and <code>Disk_ptr</code>‘s destructor eventually writes the updated object back out to desk.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Disk_ptr</span>&#123;<br>    string identifier;<br>    T* in_core_address;<br>	<span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Disk_ptr</span>(<span class="hljs-type">const</span> string&amp; s) : identifier&#123;s&#125;, in_core_address&#123;<span class="hljs-literal">nullptr</span>&#125; &#123;&#125;<br>    ~<span class="hljs-built_in">Disk_ptr</span>()&#123; <span class="hljs-built_in">write_to_disk</span>(in_core_address,identifier);&#125;<br><br>    T* <span class="hljs-keyword">operator</span>-&gt;()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(in_core_address == <span class="hljs-literal">nullptr</span>)<br>            in_core_address = <span class="hljs-built_in">read_from_disk</span>(identitier);<br>        <span class="hljs-keyword">return</span> in_core_address;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>Disk_ptr</code> might be used like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rec</span>&#123;<br>    string name;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>    Disk_ptr&lt;Rec&gt; p&#123;s&#125;; <span class="hljs-comment">// get Disk_ptr for s</span><br><br>    p-&gt;name = <span class="hljs-string">&quot;Roscoe&quot;</span>; <span class="hljs-comment">// update s; if necessary, first retrieve from disk</span><br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-comment">// p&#x27;s destructor writes back to disk</span><br></code></pre></td></tr></table></figure>

<p>Naturally, a realistic program would contain error-handling code and use a less naive way of interacting with the disk.</p>
</li>
<li><p>For ordinary pointers, use of <code>-&gt;</code> is synonymous with some uses of unary <code>*</code> and <code>[]</code>.</p>
<p>Given a class <code>Y</code> for which <code>-&gt;</code>, <code>*</code> and <code>[]</code> have their default meaning and a <code>Y*</code> called <code>p</code>, then:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">p-&gt;m == (*p).m; <span class="hljs-comment">// is true</span><br>(*p).m == p[<span class="hljs-number">0</span>].m; <span class="hljs-comment">// is true</span><br>p-&gt;m == p[<span class="hljs-number">0</span>].m; <span class="hljs-comment">// is true</span><br></code></pre></td></tr></table></figure>

<ul>
<li>As usual, no such guarantee is provided for user-defined operators.</li>
</ul>
<p>The equivalence can be provided where desired:</p>
<ul>
<li><p>```C++<br>template<typename T><br>class Ptr{</p>
<pre><code class="hljs">Y* p;
</code></pre>
<p>public:</p>
<pre><code class="hljs">Y* operator-&gt;() &#123; return p;&#125; // dereference to access member
Y&amp; operator*() &#123; return *p;&#125; // dereference to access whole object
Y&amp; operator[](int i) &#123; return p[i];&#125; // dereference to access element
</code></pre>
<p>};</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>    If you provide more than one of these operators, it might be wise to provide the equivalence, just as it is wise to ensure that `++x` <span class="hljs-literal">and</span> `x+=<span class="hljs-number">1</span>` have the same effect as `x=x+<span class="hljs-number">1</span>` for a simple variable `x` of some class `X` is `++`, `+=`, `=`, <span class="hljs-literal">and</span> `+` are provided.<br><span class="hljs-number">16</span>. The overloading of `-&gt;` is important to a class of interesting programs <span class="hljs-literal">and</span> is <span class="hljs-literal">not</span> just a minor curiosity.<br><br>    The reason is that ***indirection*** is a key concept <span class="hljs-literal">and</span> that overloading `-&gt;` provides a clean, direct, <span class="hljs-literal">and</span> efficient way of representing indirection in a program.<br><br>    - Iterators (Chapter <span class="hljs-number">33</span>) provide an important example of this.<br><span class="hljs-number">17</span>. Operator `-&gt;` must be a non-`static` member function.<br><br>    If used, it <span class="hljs-keyword">return</span> type must be a pointer <span class="hljs-literal">or</span> an object of a class to which you can apply `-&gt;`.<br><br>    The body of a template class member function is only checked if the function is used (section <span class="hljs-number">26.2</span>.<span class="hljs-number">1</span>), so we can define `operator-&gt;()` without worrying about types, such as `Ptr&lt;int&gt;`, for which `-&gt;` does <span class="hljs-literal">not</span> make sense.<br><span class="hljs-number">18</span>. Despite the similarity between `-&gt;` <span class="hljs-literal">and</span> `.` (dot), there is no way of overloading operator `.` (dot).<br><br>#### <span class="hljs-number">19.2</span>.<span class="hljs-number">4</span> Increment <span class="hljs-literal">and</span> Decrement<br><br><span class="hljs-number">19</span>. Once people invent <span class="hljs-string">&quot;smart pointers,&quot;</span> they often decide to provide the increment operator `++` <span class="hljs-literal">and</span> the decrement operator   `--` to mirror these operators&#x27; use for built-in types.<br><br>    - This is especially obvious <span class="hljs-literal">and</span> necessary where the aim is to replace an ordinary pointer type with a <span class="hljs-string">&quot;smart pointer&quot;</span> type that has the same semantics, except that it adds a bit of run-time error checking.<br><span class="hljs-title">    - For example, consider a troublesome traditional program:</span><br><br>      - ```C++<br>        void f1(X a) // traditional use<br>        &#123;<br>            X v[<span class="hljs-number">200</span>]<span class="hljs-comment">;</span><br>            X* p = &amp;v[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br>            p--<span class="hljs-comment">;</span><br>            *p = a<span class="hljs-comment">; // oops: p out of range, uncaught</span><br>            ++p<span class="hljs-comment">;</span><br>            ++p = a<span class="hljs-comment">; // OK</span><br>        &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>Here, we might want to replace the <code>X*</code> with an object of a class <code>Ptr&lt;X&gt;</code> that can be dereferenced only if it actually points to an <code>X</code>.</p>
<p>We would also like to ensure that <code>p</code> can be incremented and decremented only if it points to an object with an array and  the increment and decrement operations yield an object within that array.</p>
</li>
<li><p>That is, we would like something like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(Ptr&lt;X&gt; a)</span> <span class="hljs-comment">// checked</span></span><br><span class="hljs-function"></span>&#123;<br>    X v[<span class="hljs-number">200</span>];<br>    <span class="hljs-function">Ptr&lt;X&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;v[<span class="hljs-number">0</span>],v)</span></span>;<br>    p--;<br>    *p = a; <span class="hljs-comment">// run-time error: p out of range</span><br>    ++p;<br>    *p = a; <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The increment and decrement operators are unique among C++ operators in that they can be used as both prefix and postfix operators.</p>
<p>Consequently, we must define prefix and postfix increment and decrement for <code>Ptr&lt;T&gt;</code>. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ptr</span>&#123;<br>    T* ptr;<br>    T* array;<br>    <span class="hljs-type">int</span> sz;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function">    	<span class="hljs-title">Ptr</span><span class="hljs-params">(T* p, T(&amp;a)[N])</span></span>; <span class="hljs-comment">// bind to array a, sz==N, initial value p</span><br>    <span class="hljs-built_in">Ptr</span>(T* p, T* a, <span class="hljs-type">int</span> s); <span class="hljs-comment">// bind to array a of size s, initial value p</span><br>    <span class="hljs-built_in">Ptr</span>(T* p); <span class="hljs-comment">// bind to single objectm, sz==0, initial value p</span><br><br>    Ptr&amp; <span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// prefix</span><br>    Ptr <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix</span><br><br>    Ptr&amp; <span class="hljs-keyword">operator</span>--(); <span class="hljs-comment">// prefix</span><br>    Ptr <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix</span><br><br>    T&amp; <span class="hljs-keyword">operator</span>*(); <span class="hljs-comment">// prefix</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>int</code> argument is used to indicate that the function is to be invoked for postfix application of <code>++</code>.<ul>
<li>This <code>int</code> is never used; the argument is simply a dummy used to distinguish between prefix and postfix application.</li>
<li>The way to remember which version of an <code>operator++</code> is prefix is to note that the version without the dummy argument is prefix, exactly like all the other unary arithmetic and logical operators.</li>
<li>The dummy argument is used only for the “odd” postfix <code>++</code> and <code>--</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Consider ommiting postfix <code>++</code> and <code>--</code> in a design. They are not only odd syntactically, they tend to be marginally harder to implement than the prefix versions, less efficient, and less frequently used.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Ptr&amp; Ptr&lt;T&gt;::<span class="hljs-keyword">operator</span>++() <span class="hljs-comment">// return current object after incrementing</span><br>&#123;<br>    <span class="hljs-comment">// ... check that ptr+1 can be pointed to ...</span><br>    <span class="hljs-keyword">return</span> *++ptr;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Ptr Ptr&lt;T&gt;::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <span class="hljs-comment">// increment and return a Ptr with the old value</span><br>&#123;<br>    <span class="hljs-comment">// ... check that ptr+1 can be pointed to ...</span><br>    Ptr&lt;T&gt; old&#123;ptr,array,sz&#125;;<br>    ++ptr;<br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The pre-increment operator can return a reference to its object.</li>
<li>The post-increment operator must make a new object to return.</li>
</ul>
</li>
<li><p>Using <code>Ptr</code>, the example is equivalent to:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(T a)</span> <span class="hljs-comment">// checked</span></span><br><span class="hljs-function"></span>&#123;<br>    T v[<span class="hljs-number">200</span>];<br>    <span class="hljs-function">Ptr&lt;T&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;v[<span class="hljs-number">0</span>],v,<span class="hljs-number">200</span>)</span></span>;<br>    p.<span class="hljs-keyword">operator</span>--(<span class="hljs-number">0</span>); <span class="hljs-comment">// suffix: p--</span><br>    p.<span class="hljs-keyword">operator</span>*() = a; <span class="hljs-comment">// run-time error: p out of range (prefix * --&gt; *p)</span><br>    p.<span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// prefix: ++p</span><br>    p.<span class="hljs-keyword">operator</span>*() = a; <span class="hljs-comment">// OK (prefix * --&gt; *p)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Completing class <code>Ptr</code> is left as an exercise.</p>
<p>A pointer template that behaves correctly with respect to inheritance is presented in section 27.2.2.</p>
</li>
</ol>
<h4 id="19-2-5-Allocation-and-Deallocation"><a href="#19-2-5-Allocation-and-Deallocation" class="headerlink" title="19.2.5 Allocation and Deallocation"></a>19.2.5 Allocation and Deallocation</h4><ol start="22">
<li><p>Operator <code>new</code> acquires its memory by calling an <code>operator new()</code>. Similarly, operator <code>delete</code> frees its memory by calling an <code>operator delete()</code>.</p>
<p>A user can redefine the global <code>operator new()</code> and <code>operator delete()</code> or define <code>operator new()</code> and <code>operator delete</code> for particular class.</p>
</li>
<li><p>Using the standard-library type alias <code>size_t</code> (section 6.2.8) for sizes, the declarations of the global versions look like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>; <span class="hljs-comment">// use for individual object</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>); <span class="hljs-comment">// use for array</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span></span>; <span class="hljs-comment">// use for individual object</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>); <span class="hljs-comment">// use for array</span><br><br><span class="hljs-comment">// for more versions, see section 11</span><br></code></pre></td></tr></table></figure>

<p>That is, when <code>new</code> needs memory on the free store for an object of type <code>X</code>, it calls <code>operator new(sizeof(X))</code>.</p>
<p>Similarly, when <code>new</code> needs memory on the free store for an array of <code>N</code> objects of type <code>X</code>, it calls <code>operator new[](N*sizeof(X))</code>.</p>
<p>A <code>new</code> expression may ask for more memory that is indicated by <code>N*sizeof(X)</code>, but it will always do so in terms of a number of characters (i.e., a number of bytes).</p>
</li>
<li><p>Replacing the global <code>operator new()</code> and <code>operator delete()</code> is not for the fainthearted and not recommended.</p>
<ul>
<li>After all, someone else might rely on some aspect of the default behavior or might even have supplied other versions of these function.</li>
</ul>
<p>A more selective, and often better, approach is to supply these operations for a specific class. This class might be the base for many derived classes.</p>
<ul>
<li><p>For example, we might like to have a class <code>Employee</code> provide a specialized allocator and deallocator for itself and all of its derived classes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span></span>;<br><br>    <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>);<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Member <code>operator new()</code>s and <code>operator delete()</code>s are implicitly <code>static</code> members.</p>
<ul>
<li>Consequently, they don’t have a <code>this</code> pointer and do not modify an object.</li>
<li>The provide storage that a constructor can initialize and a destructor can clean up.</li>
</ul>
</li>
<li><p>```C++<br>void* Employee::operator new(size_t s)<br>{</p>
<pre><code class="hljs">// allocate s bytes of memory and return a pointer to it
</code></pre>
<p>}</p>
<p>void Employee::operator delete(void* p, size_t s)<br>{</p>
<pre><code class="hljs">if(p)&#123; // delete only if p!=0; see section 11.2, section 11.2.3
    // assume p points to s bytes of memory allocated by Employee::operator new()
    // and free that memory for reuse
&#125;
</code></pre>
<p>}</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>    Deleting <span class="hljs-keyword">a</span> <span class="hljs-string">&quot;plain&quot;</span> `Employee` gives <span class="hljs-keyword">an</span> argument <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> `sizeof(Employee)`; deleting <span class="hljs-keyword">a</span> `Manager` derived <span class="hljs-built_in">from</span> `Employee` that does <span class="hljs-keyword">not</span> have its own `operator <span class="hljs-built_in">delete</span>()` gives <span class="hljs-keyword">an</span> argument <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> `sizeof(Manager)`.<br><br>    - This allows <span class="hljs-keyword">a</span> class-specific allocator <span class="hljs-built_in">to</span> avoid storing size information <span class="hljs-keyword">with</span> <span class="hljs-keyword">each</span> allocation.<br><br>    Naturally, <span class="hljs-keyword">a</span> class-specific allocator can store such information (<span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> general-purpose allocator must) <span class="hljs-keyword">and</span> ignore <span class="hljs-keyword">the</span> `size_t` argument <span class="hljs-built_in">to</span> `operator <span class="hljs-built_in">delete</span>()`.<br><br>    - However, doing so makes <span class="hljs-keyword">it</span> harder <span class="hljs-built_in">to</span> improve significantly <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">speed</span> <span class="hljs-title">and</span> <span class="hljs-title">memory</span> <span class="hljs-title">consumption</span> <span class="hljs-title">of</span> <span class="hljs-title">a</span> <span class="hljs-title">general-purpose</span> <span class="hljs-title">allocator</span>.<br><span class="hljs-number">26.</span> How does <span class="hljs-keyword">a</span> compiler know how <span class="hljs-built_in">to</span> supply <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> size <span class="hljs-built_in">to</span> `operator <span class="hljs-built_in">delete</span>()`?<br><br>    - The type specified <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> `<span class="hljs-built_in">delete</span>` operation matches <span class="hljs-keyword">the</span> type <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> object being `<span class="hljs-built_in">delete</span>`d.<br><br>    If we `<span class="hljs-built_in">delete</span>` <span class="hljs-keyword">an</span> object through <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> base class, that base class must have <span class="hljs-keyword">a</span> `virtual` destructor (section <span class="hljs-number">17.2</span><span class="hljs-number">.5</span>) <span class="hljs-keyword">for</span> correct size <span class="hljs-built_in">to</span> be given:<br><br>    ```C++<br>    Employee* p = <span class="hljs-built_in">new</span> Manager;<span class="hljs-comment"> // potential trouble (the exact type is lost)</span><br>   <span class="hljs-comment"> // ... </span><br>    <span class="hljs-built_in">delete</span> p;<span class="hljs-comment"> // hope Employee has a virtual destructor</span><br></code></pre></td></tr></table></figure>

<p>In principle, deallocation is then done by the destructor (which knows the sizes of its class).</p>
</li>
</ol>
<h4 id="19-2-6-User-defined-Literals"><a href="#19-2-6-User-defined-Literals" class="headerlink" title="19.2.6 User-defined Literals"></a>19.2.6 User-defined Literals</h4><ol start="27">
<li><p>C++ provides literals for a variety of built-in types (section 6.2.6):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">123</span>; <span class="hljs-comment">// int</span><br><span class="hljs-number">1.2</span>; <span class="hljs-comment">// double</span><br><span class="hljs-number">1.2F</span>; <span class="hljs-comment">// float</span><br><span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// char</span><br><span class="hljs-number">1ULL</span>; <span class="hljs-comment">// unsigned long long</span><br><span class="hljs-number">0xD0</span>; <span class="hljs-comment">// hexadecimal</span><br><span class="hljs-string">&quot;as&quot;</span>; <span class="hljs-comment">// C-style string (const char[3])</span><br></code></pre></td></tr></table></figure>

<p>In addition, we can define literals for user-defined types and new forms of literals for built-in types.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;Hi!&quot;</span>s; <span class="hljs-comment">// string, not &quot;zero-terminated array of char&quot;</span><br><span class="hljs-number">1.2</span>i; <span class="hljs-comment">// imaginary</span><br><span class="hljs-number">101010111000101b</span>; <span class="hljs-comment">// binary</span><br><span class="hljs-number">123</span>s; <span class="hljs-comment">//seconds</span><br><span class="hljs-number">123.56</span>km; <span class="hljs-comment">// not miles!(units)</span><br><span class="hljs-number">123456789012345678901234567890123456789</span>x; <span class="hljs-comment">//extended-precision</span><br></code></pre></td></tr></table></figure>

<p>Such <em><strong>user-defined literals</strong></em> are supported through the notion of <em><strong>literal operators</strong></em> that map literals with a given suffix into a desired type.</p>
<p>The name of a literal operator is <code>operator&quot;&quot;</code> followed by the suffix. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">i</span>(<span class="hljs-type">long</span> <span class="hljs-type">double</span> d) <span class="hljs-comment">// imaginary literal</span><br>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,d&#125;; <span class="hljs-comment">// complex is a literal type</span><br>&#125;<br><br>std::string <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">s</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">size_t</span> n) <span class="hljs-comment">// std::string literal</span><br>&#123;<br>    <span class="hljs-keyword">return</span> string&#123;p,n&#125;; <span class="hljs-comment">// requires free-store allocation </span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>These two operators define suffixes <code>i</code> and <code>s</code>, respectively.</li>
<li>I use <code>constexpr</code> to enable compile-time evaluation.</li>
</ul>
</li>
<li><p>Given those, we can write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// pass pointer to char* </span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Hello&quot;</span>s); <span class="hljs-comment">// pass (five-character) string object</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>s); <span class="hljs-comment">// pass (six-character) string object</span><br><br>    <span class="hljs-keyword">auto</span> z = <span class="hljs-number">2</span>+<span class="hljs-number">1</span>i; <span class="hljs-comment">// complex&#123;2,1&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The basic (implementation) idea is that after parsing what could be a literal, the compiler always checks for a suffix.</p>
<p>The user-defined literal mechanism simply allows the user to specify a new suffix and define what is to be done with the literal before it.</p>
<p>It is not possible to redefine the meaning of a built-in literal suffix or augment the syntax of literals.</p>
</li>
<li><p>There are four kinds of literals that can be suffixed to make a user-defined literal:</p>
<ul>
<li><p>An integer literal (section 6.2.4.1):</p>
<ul>
<li>accepted by a literal operator taking an <code>unsigned long long</code> or</li>
<li><code>const char*</code> argument or</li>
<li>by a template literal operator,</li>
</ul>
<p>for example, <code>123m</code> or <code>12345678901234567890X</code></p>
</li>
<li><p>A floating-point literal (section 6.2.5.1):</p>
<ul>
<li>accepted by a literal operator taking a <code>long double</code> or</li>
<li>a <code>const char*</code> argument or</li>
<li>by a template literal operator,</li>
</ul>
<p>for example, <code>12345678901234567890.976543210x</code> or <code>3.99s</code></p>
</li>
<li><p>A string literal (section 7.3.2):</p>
<ul>
<li>accepted by a literal operator taking a (<code>const char*</code>, <code>size_t</code>) pair of argument,</li>
</ul>
<p>for example, <code>&quot;string&quot;s</code> and <code>R&quot;(Foo\bar)&quot;_path</code></p>
</li>
<li><p>A charactor literal (section 6.2.3.2):</p>
<ul>
<li>accepted by a literal operator taking a character argument of type <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>,</li>
</ul>
<p>for example, <code>&#39;f&#39;_runic</code> or <code>u&#39;BEEF&#39;_w</code>.</p>
</li>
</ul>
<p>For example, we could define a literal operator to collect digits for integer values that cannot be represented in any of the built-in integer types:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">Bignum <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">x</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*p) <span class="hljs-comment">// require a C-style string for my operator</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Bignum</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Bignum)</span></span>;<br><br><span class="hljs-built_in">f</span>(<span class="hljs-number">123456789012345678901234567890123456789012345</span>x); <span class="hljs-comment">// did not put those digits in double quotes.</span><br><span class="hljs-comment">// the compiler derived a C-style string from the digits provided</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Here, the C-style string <code>&quot;123456789012345678901234567890123456789012345&quot;</code> is passed to <code>operator&quot;&quot; x()</code>.</li>
<li>Note that I did not put those digits in double quotes.<ul>
<li>I required a C-style string for my operator, and the compiler delivered it from the digits provided.</li>
</ul>
</li>
</ul>
</li>
<li><p>To get a C-style string from the program souce text into a literal operator, we request both the string and its number of  characters. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">string <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">s</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">size_t</span> n);<br><br>string s12 = <span class="hljs-string">&quot;one two&quot;</span>s; <span class="hljs-comment">// call operator &quot;&quot;(&quot;one two&quot;,7)</span><br>string s22 = <span class="hljs-string">&quot;two\ntwo&quot;</span>s; <span class="hljs-comment">// call operator &quot;&quot;(&quot;two\ntwo&quot;,7)</span><br>string sxx = R<span class="hljs-string">&quot;two\ntwo&quot;</span>s; <span class="hljs-comment">// call operator &quot;&quot;(&quot;two\ntwo&quot;,8)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>In the raw string (section 7.3.2.1), <code>&quot;\n&quot;</code> represents the two characters <code>&#39;\&#39;</code> and <code>n</code>.</li>
</ul>
<p>The rationale for requiring the number of character is that if we want to have “a different kind of string,” we almost always want to know the number of characters anyway.</p>
</li>
<li><p>A literal operator that takes just a <code>const char*</code> argument (and no size) can be applied to integer and floating-point literals.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">string <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">SS</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p); <span class="hljs-comment">// warning: this will not work as expected</span><br><br>string s12 = <span class="hljs-string">&quot;one two&quot;</span>SS; <span class="hljs-comment">// error: no applicable literal operator</span><br>string s13 = <span class="hljs-number">13</span>SS; <span class="hljs-comment">// OK, but why would anyone do that?</span><br></code></pre></td></tr></table></figure>

<p>A literal operator converting numberical values to strings could be quite confusing.</p>
</li>
<li><p>A <em><strong>template literal operator</strong></em> is a literal operator that takes its argument as a template parameter pack, rather than as a function argument. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span>...&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _b3(); <span class="hljs-comment">// base 3, i.e., ternary</span><br></code></pre></td></tr></table></figure>

<p>Given that, we get:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">201</span>_b3; <span class="hljs-comment">// means operator &quot;&quot; b3&lt;&#x27;2&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&gt;(); so 9*2+3*0+1 == 19</span><br><span class="hljs-number">241</span>_b3; <span class="hljs-comment">// means operator &quot;&quot; b3&lt;&#x27;2&#x27;,&#x27;4&#x27;,&#x27;1&#x27;&gt;(); so error: 4 isn&#x27;t a ternary digit</span><br></code></pre></td></tr></table></figure>

<p>The variadic template techniques (section 3.4.4, section 28.6) can be disconcerting, but it is the only way of assigning nonstandard meanings to digits at compile time.</p>
</li>
<li><p>To define <code>operator&quot;&quot; _b3()</code>, we need some helper functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">ipow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// x to the nth power for n&gt;=0</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (n&gt;<span class="hljs-number">0</span>) ? x*<span class="hljs-built_in">ipow</span>(x,n<span class="hljs-number">-1</span>) : <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span> c&gt; <span class="hljs-comment">// handle the single ternary digit case</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">b3_helper</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(c&lt;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;not a ternary digit&quot;</span>);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span> c,<span class="hljs-type">char</span>... tail&gt; <span class="hljs-comment">// peel off one ternary digit (variadic template; section 3.4.4)</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">b3_helper</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(c&lt;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;not a ternary digit&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ipow</span>(<span class="hljs-number">3</span>,<span class="hljs-keyword">sizeof</span>...(tail))*(c-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-built_in">b3_helper</span>(tail...);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Given that, we can define our base 3 literal operator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span>... chars&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _b3() <span class="hljs-comment">// base 3, i.e., ternary</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">b3_helper</span>(chars...)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Many suffixes will be short (e.g., <code>s</code> for <code>std::string</code>, <code>i</code> for imaginary, <code>m</code> for meter (section 28.7.3), and <code>x</code> for extended), so different uses could easily clash.</p>
<p>Use namespace to prevent clashes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> Numerics&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bignum</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br><br>    <span class="hljs-keyword">namespace</span> literals&#123;<br>        Bignum <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">x</span>(<span class="hljs-type">char</span> <span class="hljs-type">const</span>*);<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Numerics::literals<br></code></pre></td></tr></table></figure></li>
<li><p>The standard library reserves all suffixs not starting with an initial underscore, so define your suffixes starting with an underscore or risk your code breaking in the future:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">123</span>km; <span class="hljs-comment">// reserved by the standard library</span><br><span class="hljs-number">123</span>_km; <span class="hljs-comment">// available for your use</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-3-A-String-Class"><a href="#19-3-A-String-Class" class="headerlink" title="19.3 A String Class"></a>19.3 A String Class</h3><ol start="36">
<li><p>The relatively simple string class presented in this section illustrates several techniques that are useful for the design and implementation of classes using conventionally defined operators.</p>
<ul>
<li>This <code>String</code> is a simplified version of the standard-library <code>string</code> (section 4.2, Chapter 36).</li>
<li><code>String</code> provides value semantics, checked and unchecked access to characters, stream I/O, support for range-<code>for</code> loops, equality operations, and concatenation operators.</li>
<li>I also added a <code>String</code> literal, which <code>std::string</code> does not (yet) have.</li>
</ul>
</li>
<li><p>To allow simple interoperability with C-style strings (including string literal (section 7.3.2)), I represent strings as zero-terminated arrays of characters.</p>
<ul>
<li>For realism, I implement the <em><strong>short string optimization</strong></em>. That is, a <code>String</code> with only a few characters stores those characters in the class object itself, rather than on the free store.<ul>
<li>This optimizas string usage for small strings.</li>
<li>Experience shows that for a huge number of applications most strings are short.</li>
<li>This optimization is particularly important in multi-threaded systems where sharing through pointers (or reference) is infeasible and free-store allocation and deallocation relatively expensive.</li>
</ul>
</li>
</ul>
<p>To allow <code>String</code>s to efficiently “grow” by adding character at the end, I implement a scheme for keeping extra space for such growth similar to the one used for <code>vector</code> (section 13.6.1).</p>
<ul>
<li>This makes <code>String</code> a suitable target for various forms of input.</li>
</ul>
</li>
<li><p>Writing a better string class and/or one that provides more facilities is a good exercise.</p>
<p>That done, we can throw away our exercises and use <code>std::string</code>.</p>
</li>
</ol>
<h4 id="19-3-1-Essential-Operations"><a href="#19-3-1-Essential-Operations" class="headerlink" title="19.3.1 Essential Operations"></a>19.3.1 Essential Operations</h4><ol start="39">
<li><p>Class <code>String</code> provides the usual set of constructors, a destructor, and assignment operation (section 17.1):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>(); <span class="hljs-comment">// default constructor: x&#123;&quot;&quot;&#125;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p)</span></span>; <span class="hljs-comment">// constructor from C-style string: x&#123;&quot;Euler&quot;&#125;</span><br><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp;); <span class="hljs-comment">// copy constructor</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp;); <span class="hljs-comment">// copy assignment</span><br><br>    <span class="hljs-built_in">String</span>(String&amp;&amp; x); <span class="hljs-comment">// move constructor</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(String&amp;&amp; x); <span class="hljs-comment">// move assignment</span><br><br>    ~<span class="hljs-built_in">String</span>() &#123; <span class="hljs-keyword">if</span>(short_max&lt;sz) <span class="hljs-keyword">delete</span>[] ptr;&#125; <span class="hljs-comment">// destructor</span><br><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>This <code>String</code> has value semantics.</p>
<ul>
<li>That is, after an assignment <code>s1=s2</code>, the two strings <code>s1</code> and <code>s2</code> are fully distinct, and subsequent changes to one have no effect on the other.</li>
</ul>
<p>The alternative would be to give <code>String</code> pointer semantics.</p>
<ul>
<li>That would be to let changes to <code>s2</code> after <code>s1=s2</code> also affect the value of <code>s1</code>.</li>
</ul>
<p>Where it makes sense, I prefer value semantics;</p>
<ul>
<li>examples are <code>complex</code>, <code>vector</code>, <code>Matrix</code>, and <code>string</code>.</li>
</ul>
<p>However, for value semantics to be affordable, we need to pass <code>String</code>s by reference when we don’t need copies and to implement move semantics (section 3.3.2, section 17.5.2) to optimize <code>return</code>s.</p>
<p>The slightly nontrivial representation of <code>String</code> is presentedin section 19.3.3.</p>
<ul>
<li>Note that it requires user-defined versions of the copy and move operations.</li>
</ul>
</li>
</ol>
<h4 id="19-3-2-Access-to-Characters"><a href="#19-3-2-Access-to-Characters" class="headerlink" title="19.3.2 Access to Characters"></a>19.3.2 Access to Characters</h4><ol start="40">
<li><p>The design of access operators for a string is a difficult topic because ideally access is by conventional notation (that is, using <code>[]</code>), maximally efficient, and range checked.</p>
<p>Unfortunately, you cannot have all of these properties simultaneously.</p>
<p>Here, I follow the standard library by providing efficient unchecked operations with the conventional <code>[]</code> subscript notation plus range-checked <code>at()</code> operations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> ptr[n];&#125; <span class="hljs-comment">// unchecked element access</span><br>    <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr[n];&#125; <span class="hljs-comment">// const version for const</span><br><br>    <span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-built_in">check</span>(n); <span class="hljs-keyword">return</span> ptr[n];&#125; <span class="hljs-comment">// range-checked element access</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">check</span>(n); <span class="hljs-keyword">return</span> ptr[n];&#125;<br><br>    String&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> c); <span class="hljs-comment">// add c at end</span><br><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> ptr;&#125; <span class="hljs-comment">// C-style string access</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sz;&#125; <span class="hljs-comment">// number of elements</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// elements plus available space</span></span><br><span class="hljs-function">    	</span>&#123; <span class="hljs-keyword">return</span> (sz&lt;short_max) ? short_max : sz+space;&#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>I provide <code>const</code> and non-<code>const</code> versions of the access functions to allow them to be used for <code>const</code> as well as other objects.</li>
</ul>
</li>
<li><p>The idea is to use <code>[]</code> for ordinary use. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> h&#123;s[<span class="hljs-number">0</span>]&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i&#123;<span class="hljs-number">1</span>&#125;; i!=s.<span class="hljs-built_in">size</span>(); i++) h ^= s[i]&gt;&gt;<span class="hljs-number">1</span>; <span class="hljs-comment">// unchecked access to s</span><br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Here, using the checked <code>at()</code> would be redundant because we correctly access <code>s</code> only from <code>0</code> to <code>s.size()-</code>.</li>
</ul>
</li>
<li><p>We can use <code>at()</code> where we see a possibility of mistakes. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_in_order</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; s, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (x : index) cout &lt;&lt; s.<span class="hljs-built_in">at</span>(x) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Unfortunately, assuming that people will use <code>at()</code> consistently where mistakes can be made is overly optimistic, so some implementations of <code>std::string</code> (from which the <code>[]</code>/<code>at()</code> convention is borrowed) also check <code>[]</code>.</li>
<li>I personally prefer ta checked <code>[]</code> at least during development.</li>
<li>However, for serious string manipulation tasks, a range check on each character access could impose quite noticeable overhead.</li>
</ul>
</li>
</ol>
<h4 id="19-3-3-Representation"><a href="#19-3-3-Representation" class="headerlink" title="19.3.3 Representation"></a>19.3.3 Representation</h4><ol start="43">
<li><p>The representation for <code>String</code> was chosen to meet three goals:</p>
<ul>
<li>To make it easy to convert a C-style string (e.g., a string literal) to a <code>String</code> and to allow easy access to the characters of a <code>String</code> as a C-style string</li>
<li>To minimize the use of the free store</li>
<li>To make adding characters to the end of a <code>String</code> efficient</li>
</ul>
<p>The result is clearly messier than a simple {pointer,size} representation, but much more realistic:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	A simple string that implements the short string optimization</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	size()==sz is the number of elements</span><br><span class="hljs-comment">	if size()&lt;=short_max, the characters are held in the String object itself;</span><br><span class="hljs-comment">	otherwise the free store is used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	ptr points to the start of the character sequence</span><br><span class="hljs-comment">	the character sequence is kept zero-terminated: ptr[size()]==0;</span><br><span class="hljs-comment">	this allows us to use C library string functions and to easily return a C-style string: c_str()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	To allow efficient addition of characters at end, String grows by doubling its allocation;</span><br><span class="hljs-comment">	capacity() is the  amount of space available for characters</span><br><span class="hljs-comment">	(excluding the terminating 0): sz+space</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> short_max = <span class="hljs-number">15</span>;<br>    <span class="hljs-type">int</span> sz; <span class="hljs-comment">// number of characters</span><br>    <span class="hljs-type">char</span>* ptr; <span class="hljs-comment">// string of characters</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-type">int</span> space; <span class="hljs-comment">// unused allocated space</span><br>        <span class="hljs-type">char</span> ch[short_max+<span class="hljs-number">1</span>]; <span class="hljs-comment">// leave space to terminating 0</span><br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// range check</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">0</span> || sz&lt;=n)<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;String::at()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ancillary member functions</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_from</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move_from</span><span class="hljs-params">(String&amp; x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This supports what is known as <em><strong>short string optimization</strong></em> by using two string representations:<ul>
<li>If <code>sz&lt;=short_max</code>, the characters are stored in the <code>String</code> object itself, in the array named <code>ch</code>.</li>
<li>If <code>!(sz&lt;=short_max)</code>, the characters are stored on the free store and we may allocate extra space for expansion. The member named <code>space</code> is the number of such characters.</li>
</ul>
</li>
<li>In both cases, the number of elements is kept in <code>sz</code> and we look at <code>sz</code>, to determine which implementation scheme is used for a given string.</li>
<li>In both cases, <code>ptr</code> points to the elements.<ul>
<li>This is essential for performance:<ul>
<li>the access functions do not need to test which representation is used; they simply use <code>ptr</code>.</li>
<li>Only the constructor, assignments, moves, and the destructor (section 19.3.4) must care about the two alternatives.</li>
</ul>
</li>
</ul>
</li>
<li>We use the array <code>ch</code> only if <code>sz&lt;=short_max</code> and the integer <code>space</code> only if <code>!(sz&lt;=short_max)</code>.<ul>
<li>Consequently, it would be a waste to allocate space for both <code>ch</code> and <code>space</code> in a <code>String</code> object.<ul>
<li>To avoid such waste, I use a <code>union</code> (section 8.3).</li>
<li>In particular, I used a form of <code>union</code> called an <em><strong>anonymous union</strong></em> (section 8.3.2), which is specially designed to allow a class to manage alternative representations of objects.<ul>
<li>All members of an anonymous union are allocated in the same memory, starting at the same address.</li>
<li>Only one member may be used at any one time, but otherwise they are accessed and used exactly as if they were separate members of the scope surrounding the anonymous union.</li>
<li>It is the programmer’s job to make sure that they are never misused.<ul>
<li>For example, all member functions of <code>String</code> that use <code>space</code> must make sure that it really was <code>space</code> that was set and not <code>ch</code>.</li>
<li>That is done by looking at <code>sz&lt;=short_max</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="19-3-3-1-Ancillary-Functions"><a href="#19-3-3-1-Ancillary-Functions" class="headerlink" title="19.3.3.1 Ancillary Functions"></a>19.3.3.1 Ancillary Functions</h5><ol start="44">
<li><p>In addition to functions intended for general use, I found that my code become cleaner when I provided three ancillary functions as “building blocks” to help me with somewhat triky representation and to minimize code replication.</p>
<ul>
<li>Two of those need to access the representation of <code>String</code>, so I made them members.</li>
</ul>
<p>However, I made them <code>private</code> members because they don’t represent operations that are generally useful and safe to use.</p>
<p>For many interesting classes, the implementation is not just the representation plus the <code>public</code> functions.</p>
<p>Ancillary functions can lead to less duplication of code, better design, and improved maintainability.</p>
</li>
<li><p>The first such function moves characters into newly allocated memory:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr, <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// expand into free store</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>    <span class="hljs-built_in">strcpy</span>(p,ptr); <span class="hljs-comment">// section 43.4</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This function does not access the <code>String</code> representation, so I did not make it a member.</li>
</ul>
<p>The second implementation function is used by copy operations to give a <code>String</code> a copy of the members of another:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::copy_from</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// make *this a copy of x</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x.sz&lt;=short_max) &#123; <span class="hljs-comment">// copy *this</span><br>        <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>,&amp;x,<span class="hljs-built_in">sizeof</span>(x)); <span class="hljs-comment">// section 43.5</span><br>        ptr = ch;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// copy the elements</span><br>        ptr = <span class="hljs-built_in">expand</span>(x.ptr,x.sz+<span class="hljs-number">1</span>); <span class="hljs-comment">// zero-terminated</span><br>        sz = x.sz;<br>        space = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Any necessary cleanup of the target <code>String</code> is the task of callers of <code>copy_from()</code>;<ul>
<li><code>copy_from()</code> unconditionally overwrites its target.</li>
</ul>
</li>
<li>I use the standard-library <code>memcpy()</code> (section 43.5) to copy the bytes of the source into the target.<ul>
<li>That’s a low level and sometimes pretty nasty function.</li>
<li>It should be used only where there are no objects with constructors or destructors in the copied memory because <code>memcpy()</code> knows nothing about types.</li>
</ul>
</li>
<li>Both <code>String</code> copy operations use <code>copy_from()</code> (i.e., copy constructor and copy assignment).</li>
</ul>
<p>The corresponding function for move operation is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::move_from</span><span class="hljs-params">(String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x.sz&lt;=short_max) &#123; <span class="hljs-comment">// copy *this</span><br>        <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>,&amp;x,<span class="hljs-built_in">sizeof</span>(x)); <span class="hljs-comment">// section 43.5</span><br>        ptr = ch;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// grab the elements</span><br>        ptr = x.ptr;<br>        sz = x.sz;<br>        space = x.space;<br>        x.ptr = x.ch; <span class="hljs-comment">// x = &quot;&quot;</span><br>        x.sz = <span class="hljs-number">0</span>;<br>        x.ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>It too unconditionally makes its target a copy of its argument.<ul>
<li>However, it does not leave its argument owning any free store.</li>
</ul>
</li>
<li>I could also have used <code>memcpy()</code> in the long string case (<code>!(x.sz&lt;=short_max)</code>), but since a long string representation uses only part of <code>String</code>‘s representation, I decidied to copy the used members individually/</li>
</ul>
</li>
</ol>
<h4 id="19-3-4-Member-Functions"><a href="#19-3-4-Member-Functions" class="headerlink" title="19.3.4 Member Functions"></a>19.3.4 Member Functions</h4><ol start="46">
<li><p>The default constructor defines a <code>String</code> to be empty:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>() <span class="hljs-comment">// default constructor: x&#123;&quot;&quot;&#125;</span><br>    : sz&#123;<span class="hljs-number">0</span>&#125;, ptr&#123;ch&#125; <span class="hljs-comment">// ptr points to elements, ch is an initial location (section 19.3.3)</span><br>&#123;<br>    ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// terminating 0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Given <code>copy_from()</code> and <code>move_from()</code>, the constructors, movesm and assignments are fairly simple to implement.</p>
<p>The constructor that takes a C-style string argument must determine the number of characters and store them appropriately:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p)<br>    : sz&#123;<span class="hljs-built_in">strlen</span>(p)&#125;,<br>	  ptr&#123;(sz&lt;=short_max) ? ch : <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[sz+<span class="hljs-number">1</span>]&#125;,<br>	  space&#123;<span class="hljs-number">0</span>&#125;<br>&#123;<br>    <span class="hljs-built_in">strcpy</span>(ptr,p); <span class="hljs-comment">// copy characters into ptr from p</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>If the argument is a short string, <code>ptr</code> is set to point to <code>ch</code>; otherwise, space is allocated on the free store.</li>
<li>In either case, the characters are copied from the argument string into the memory managed by <code>String</code>.</li>
</ul>
<p>The copy constructor simply copies the representation of its argument:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; x) <span class="hljs-comment">// copy constructor</span><br>&#123;<br>    <span class="hljs-built_in">copy_from</span>(x); <span class="hljs-comment">// copy representaion from x</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>I didn’t bother trying to optimize the case where the size of the source equals the size of the target (as was done for <code>vector</code>; section 13.6.3). I didn’t know if that would be worthwhile.</li>
</ul>
<p>Similarly, the move constructor moves the representation from its source (and possibly sets it argument to be the empty string):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>(String&amp;&amp; x) <span class="hljs-comment">// move constructor</span><br>&#123;<br>    <span class="hljs-built_in">move_from</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Like the copy constructor, the <strong>copy assignment</strong> uses <code>copy_from()</code> to clone its argument’s representation.</p>
<p>In addition, it has to <code>delete</code> any free store owned by the target and make sure it does not get into trouble with self-assignment (e.g., <code>s=s</code>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; x)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;x) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// deal with self-assignment</span><br>    <span class="hljs-type">char</span>* p = (short_max&lt;sz) ? ptr : <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">copy_from</span>(x);<br>    <span class="hljs-keyword">delete</span>[] p;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The <code>String</code> move assignment deletes its target’s free store (if there is any) and then moves:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; String::<span class="hljs-keyword">operator</span>=(String&amp;&amp; x)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;x) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// deal with self-assignment (x = move(x) is insanity)</span><br>    <span class="hljs-keyword">if</span>(short_max&lt;sz) <span class="hljs-keyword">delete</span>[] ptr; <span class="hljs-comment">// delete target</span><br>    <span class="hljs-built_in">move_from</span>(x); <span class="hljs-comment">// does not throw</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>It is logically possible to move a source into itself (e.g., <code>s=std::move(s)</code>), so again we have to protect against self-assignment (however unlikely).</li>
</ul>
</li>
<li><p>The logically most complicated <code>String</code> operation is <code>+=</code>, which adds a character to the end of the string, increasing its size of by one:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; String::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> c)<br>&#123;<br>    <span class="hljs-keyword">if</span>(sz==short_max) &#123; <span class="hljs-comment">// expand to long string</span><br>        <span class="hljs-type">int</span> n = sz+sz+<span class="hljs-number">2</span>; <span class="hljs-comment">// double the allocation (+2 because of the terminating 0)</span><br>        ptr = <span class="hljs-built_in">expand</span>(ptr,n);<br>        space = n-sz<span class="hljs-number">-2</span>; <span class="hljs-comment">// n - 1 - (sz + 1)</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(short_max&lt;sz) &#123;<br>        <span class="hljs-keyword">if</span>(space==<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// expand in free store</span><br>            <span class="hljs-type">int</span> n = sz+sz+<span class="hljs-number">2</span>; <span class="hljs-comment">// double the allocation (+2 because of the terminating 0)</span><br>            <span class="hljs-type">char</span>* p = <span class="hljs-built_in">expand</span>(ptr,n);<br>            <span class="hljs-keyword">delete</span>[] ptr;<br>            ptr = p;<br>            space = n-sz<span class="hljs-number">-2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            --space;<br>    &#125;<br>    ptr[sz] = c; <span class="hljs-comment">// add c at end</span><br>    ptr[++sz] = <span class="hljs-number">0</span>; <span class="hljs-comment">// increase size and set terminator</span><br><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>There is a lot going on here:<ul>
<li><code>operator+=()</code> has to keep track of which representation (short or long) is used and whether there is extra space available to expand into.<ul>
<li>If more space is needed, <code>expand()</code> is called to allocate that space and move the old characters into the new space.</li>
<li>If there was an old allocation that needs deleting, it is returned, so that <code>+=</code> can delete it.</li>
</ul>
</li>
<li>Once enough space is available, it is trivial to put the new character <code>c</code> into it and to add the terminating <code>0</code>.</li>
</ul>
</li>
<li>Note the calculation of available memory for space.<ul>
<li>Of all the String implementation that took the longest to get right:<ul>
<li>its a messy little calculation prone to off-by-one errors.</li>
</ul>
</li>
<li>That repeated constant <code>2</code> feels awfully like a ‘‘magic constant.’’</li>
</ul>
</li>
</ul>
<p>All <code>String</code> members take care not to modify a new representation before they are certain that a new one can be put in place.</p>
<ul>
<li>In particular, they don’t <code>delete</code> until after any possible <code>new</code> operations have been done.</li>
<li>In fact, the <code>String</code> members provides the strong exception guarantee (section 13.2).</li>
</ul>
</li>
<li><p>If you don’t like the kind of fiddly code presented as part of the implementation of <code>String</code>, simply use <code>std::string</code>.</p>
<p>To a large extent, the standard-library facilities exist to save us from programming at this low level most of the time.</p>
<p>Stronger: writing a string class, a vector class, or a map is an excellent exercise.</p>
<ul>
<li>However, once the exercise is done, one outcome should be an appreciation of what the standard offers and a desire not to maintain your own version.</li>
</ul>
</li>
</ol>
<h4 id="19-3-5-Helper-Functions"><a href="#19-3-5-Helper-Functions" class="headerlink" title="19.3.5 Helper Functions"></a>19.3.5 Helper Functions</h4><ol start="50">
<li><p>To complete class <code>String</code>, I provide a set of useful functions, stream I/O, support for range-<code>for</code> loops, comparison, and concatenation.</p>
<ul>
<li>These all mirror the design choices used for <code>std::string</code>.</li>
</ul>
</li>
<li><p>In particular, <code>&lt;&lt;</code> just prints the characters without added formatting, and <code>&gt;&gt;</code> skips initial whitespace before reading until it finds terminating whitespace (or the end of the stream):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> String&amp; s)<br>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; s.<span class="hljs-built_in">c_str</span>(); <span class="hljs-comment">// section 36.3.3</span><br>&#125;<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, String&amp; s)<br>&#123;<br>    s = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// clear the target string</span><br>    is&gt;&gt;ws; <span class="hljs-comment">// skip whitespace (section 38.4.5.1)</span><br>    <span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;&#x27;;</span><br><span class="hljs-string">    while(is.get(ch) &amp;&amp; !isspace(ch))</span><br><span class="hljs-string">        s += ch;</span><br><span class="hljs-string">    return is;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure></li>
<li><p>I provide <code>==</code> and <code>!=</code> for comparison:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; a, <span class="hljs-type">const</span> String&amp; b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i!=a.<span class="hljs-built_in">size</span>(); ++i)<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> String&amp; a, <span class="hljs-type">const</span> String&amp; b)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(a==b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Adding <code>&lt;</code>, etc., would be trivial.</p>
</li>
<li><p>To support the range-<code>for</code> loop, we need <code>begin()</code> and <code>end()</code> (section 9.5.1).</p>
<p>Again, we can provide those as freestanding (nonmember) functions without direct access to the <code>String</code> implementation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">(String&amp; x)</span> <span class="hljs-comment">// C-string-style access</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">(String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>()+x.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>()+x.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Given the member function <code>-=</code> that adds a character at the end, concatenation operator are easily provided as nonmember functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; <span class="hljs-keyword">operator</span>+=(Strng&amp; a, <span class="hljs-type">const</span> String&amp; b) <span class="hljs-comment">// concatenation</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : b)<br>        a+=x;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>String&amp; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; a, <span class="hljs-type">const</span> String&amp; b) <span class="hljs-comment">// concatenation</span><br>&#123;<br>    String res&#123;a&#125;;<br>    res += b;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>I feel that I may have slight “cheated” here.</p>
<ul>
<li><p>Should I have provided a member <code>+=</code> that added a C-style string to the end?</p>
<ul>
<li><p>The standard-library <code>string</code> does, but without it, concatenation with a C-style string still works.</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">String s = <span class="hljs-string">&quot;Njal&quot;</span>;<br>s += <span class="hljs-string">&quot;Gunnar&quot;</span>; <span class="hljs-comment">// concatenate: add to the end of s</span><br></code></pre></td></tr></table></figure>

<ul>
<li>This use of <code>+=</code> is interpreted as <code>operator+=(s,String(&quot;Gunnar&quot;))</code>.</li>
</ul>
</li>
<li><p>My guess is that I could provide a more efficient <code>String::operator+=(const char*)</code>, but I have no idea if the added performance would be worthwhile in real-world code.</p>
</li>
<li><p>In such cases, I try to be conservative and deliver the minimal design.</p>
</li>
<li><p>Being able to do something is not by itself a good reason for doing it.</p>
</li>
</ul>
</li>
<li><p>Similarly, I do not try to optimize <code>+=</code> by taking the size of a source string into account.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Adding <code>_s</code> as a string literal suffix meaning <code>String</code> is trivial:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">String <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _s(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">size_t</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> String&#123;p&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>We can now write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; <span class="hljs-comment">// C-style string</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp;)</span></span>; <span class="hljs-comment">// our string</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Madden&#x27;s&quot;</span>); <span class="hljs-comment">// f(const char*)</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Christopher&#x27;s&quot;</span>_s); <span class="hljs-comment">// f(const String&amp;)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="19-3-6-Using-Our-String"><a href="#19-3-6-Using-Our-String" class="headerlink" title="19.3.6 Using Our String"></a>19.3.6 Using Our String</h4><ol start="56">
<li><p>The main program simply exercises the <code>String</code> operators a bit:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;abcdefghij&quot;</span>)</span></span>;<br>    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;k&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;l&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;m&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;n&#x27;</span>;<br>    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    String s2 = <span class="hljs-string">&quot;Hell&quot;</span>;<br>    s2 += <span class="hljs-string">&quot; and high water&quot;</span>;<br>    cout &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    String s3 = <span class="hljs-string">&quot;qwerty&quot;</span>;<br>    s3 = s3;<br>    String s4 = <span class="hljs-string">&quot;the quick brown fox jumped over the lazy dog&quot;</span>;<br>    s4 = s4;<br>    cout &lt;&lt; s3 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cout &lt;&lt; s + <span class="hljs-string">&quot;. &quot;</span> + s3 + <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;. &quot;</span>) + <span class="hljs-string">&quot;Horsefeathers\n&quot;</span>;<br><br>    String buf;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;buf &amp;&amp; buf!=<span class="hljs-string">&quot;quit&quot;</span>)<br>        cout &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; buf.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; buf.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The <code>String</code> lacks many features that you might consider important or even essential.</p>
<p>However, for what it does it closely resembles <code>std::string</code> (Chapter 36) and illustrates techniques used for the implementation of the standard-library <code>string</code>.</p>
</li>
</ol>
<h3 id="19-4-Friends"><a href="#19-4-Friends" class="headerlink" title="19.4 Friends"></a>19.4 Friends</h3><ol start="58">
<li><p><strong>An ordinary member function declaration specifies three logically distinct things</strong>:</p>
<ul>
<li>The function can access the private part of the class declaration.</li>
<li>The function is in the scope of the class.</li>
<li>The function must be invoked on an object (has a <code>this</code> pointer).</li>
</ul>
<p>By declaring a member function <code>static</code> (section 16.2.12), we can give it the first two properties only.</p>
<p>By declaring a nonmember function a <code>friend</code>, we can give it the first property only.</p>
<ul>
<li><p>That is, a function declared <code>friend</code> is granted access to the implementation of a class just like a member function but is otherwise independent of that class.</p>
</li>
<li><p>For example, we could define an operator that multiplies a <code>Matric</code> by a <code>Vector</code>.</p>
<ul>
<li><p>Naturally, <code>Vector</code> and <code>Matrix</code> hide their repective representations and provide a complete set of operations for manipulating objects of their type.</p>
</li>
<li><p>However, our multiplication routine cannot be a member of both.</p>
</li>
<li><p>Also, we don’t really want to provide low-level access functions to allow every user to both read and write the complete representation of both <code>Matrix</code> and <code>Vector</code>.</p>
</li>
<li><p>To avoid this, we declare the <code>operator*</code> a <code>friend</code> of both:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> rc_max&#123;<span class="hljs-number">4</span>&#125;; <span class="hljs-comment">// row and column size</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br>    <span class="hljs-type">float</span> v[rc_max];<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">friend</span> Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp;, <span class="hljs-type">const</span> Vector&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span> &#123;<br>	Vector v[rc_max];<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">friend</span> Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp;, <span class="hljs-type">const</span> Vector&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Now <code>operator*()</code> can reach into the implementation of both <code>Vector</code> and <code>Matrix</code>. That would allow sophisticated implementation techniques, but a simple implementation would be:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp; m, <span class="hljs-type">const</span> Vector&amp; v)<br>&#123;<br>    Vector r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i!=rc_max; i++) &#123; <span class="hljs-comment">// r[i] = m[i] * v</span><br>        r.v[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j!=rc_max; j++)<br>            r.v[i] += m.v[i].v[j] * v.v[j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="59">
<li><p>A <code>friend</code> declaration can be placed in either the <code>private</code> or the <code>public</code> part of a class declaration; it does not matter where.</p>
<p>Like a member function, a <code>friend</code> function is explicitly declared in the declaration of the class of which it is a friend.</p>
<ul>
<li>It is therefore as much a part of that interface as is a member function. (既是接口也是成员函数)</li>
</ul>
</li>
</ol>
<ol start="60">
<li><p>A member function of one class can be the friend of another. </p>
<ul>
<li>For example:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">List_iterator</span> &#123;<br>	<span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span>* <span class="hljs-title">List_iterator::next</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>There is a shorthand for making all functions of one class friends of another.</p>
<ul>
<li>For example:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List_iterator</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This <code>friend</code> declaration makes all of <code>List_iterator</code>‘s member function friends of <code>List</code>.</li>
</ul>
<p>Declaring a class a <code>friend</code> grants access to every function of that class.</p>
<ul>
<li>That implies that we can not know the set of functions that can access the granting class’s representation just by looking at the class itself.</li>
<li>In this, a friend class declaration differs from the declaration of member function and a friend function.</li>
<li>Clearly, friend classes should be used with caution and only to express closely connected concepts.</li>
</ul>
</li>
</ol>
<ol start="61">
<li><p>It is possible to make a template argument a <code>friend</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-keyword">friend</span> T;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>; <span class="hljs-comment">// redundant &quot;class&quot;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Often, there is a choice between making a class a member (a nested class) or a nonmember friend (section 18.3.1)</p>
</li>
</ol>
<h4 id="19-4-1-Finding-Friends"><a href="#19-4-1-Finding-Friends" class="headerlink" title="19.4.1 Finding Friends"></a>19.4.1 Finding Friends</h4><ol start="62">
<li><p>A friend must be previously declared in an enclosing scope or defined in the non-class scope immediately enclosing the class that is declaring it to be a <code>friend</code>.</p>
<p>Scopes outside the innermost enclosing namespace scope are not considered for a name first declared as a <code>friend</code>.</p>
<p>Consider a technical example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span> &#123;&#125;; <span class="hljs-comment">// will become friend of N::C</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// will become friend of N::C</span><br><br><span class="hljs-keyword">namespace</span> N &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span> &#123;&#125;; <span class="hljs-comment">// will become friend of C</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// will become friend of C</span><br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>        <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>; <span class="hljs-comment">// OK (previously defined)</span><br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C3</span>; <span class="hljs-comment">// OK (defined in enclosing namespace)</span><br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C4</span>; <span class="hljs-comment">// First declared in N and assumed to be in N (but actually not)</span><br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span></span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C3</span> &#123;&#125;; <span class="hljs-comment">// friend of C</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> </span>&#123; C x; x.x = <span class="hljs-number">1</span>;&#125; <span class="hljs-comment">// OK: friend of C</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C4</span> &#123;&#125;; <span class="hljs-comment">// not friend of N::C</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> </span>&#123; N::C x; x.x = <span class="hljs-number">1</span>;&#125; <span class="hljs-comment">// Error: x is private and f4() is not a friend of N::C</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="63">
<li><p>A friend function can be found through its argument (section 14.2.4) even if it was not declared in the immediately enclosing scope. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Matrix&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">invert</span>(m); <span class="hljs-comment">// Matrix&#x27;s friend invert()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Thus, a friend function should be explicitly declared in an enclosing scope or take an argument of its class or a class derived from that.</p>
<p>If not, the friend cannot be called.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// no f() in this scope</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// useless</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp;)</span></span>; <span class="hljs-comment">// can be found through its argument</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// no f() in scope</span><br>    <span class="hljs-built_in">h</span>(x); <span class="hljs-comment">// X&#x27;s friend h() (X&#x27;s friend h(const X&amp;) can be found through its argument)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="19-4-2-Friends-and-Members"><a href="#19-4-2-Friends-and-Members" class="headerlink" title="19.4.2 Friends and Members"></a>19.4.2 Friends and Members</h4><ol start="64">
<li><p>When should we use a friend function, and when is a member function the better choice for specifying an operation?</p>
<ul>
<li>First, we try to minimize the number of functions that access the representation of a class and try to make the set of access function as appropriate as possible.<ul>
<li>Therefore, the first question is not “Should it be a member, a <code>static</code> member, or a friend?” but rather “Does it really nedd access?”</li>
</ul>
</li>
<li>Typically, the set of functions that need access is smaller that we are willing to believe at first.</li>
<li>Some operations must be members.<ul>
<li>For example, constructors, destructors, and virtual functions (section 3.2.3, section 17.2.5)</li>
<li>But typically there is a choice.</li>
<li>Because member names are local to the class, a function that requires direct access to the representation should be a member unless there is a specific reason for it to be a nonmember.</li>
</ul>
</li>
</ul>
<p>Consider a class <code>X</code> supplying alternative ways of presenting an operation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span>);<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// member\</span><br><span class="hljs-comment">    int m2() const;</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">(X&amp;)</span></span>; <span class="hljs-comment">// friend, not member (no implicit conversion)</span><br>    <span class="hljs-function">firned <span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp;)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">f3</span><span class="hljs-params">(X)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Member functions can be invoked for objects of their class only; no user-defined conversions are applied to the leftmost operand of a <code>.</code> and <code>-&gt;</code> (but see section 19.2.3). For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-number">99.</span><span class="hljs-built_in">m1</span>(); <span class="hljs-comment">// error: X(99).m1() not tried</span><br>    <span class="hljs-number">99.</span><span class="hljs-built_in">m2</span>(); <span class="hljs-comment">// error: X(99).m2() not tried</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The global function <code>f1()</code> has a similar property because <strong>implicit conversions are not used for non-<code>const</code> reference arguments</strong> (section 7.7).</p>
<p>However, conversions may be applied to the argument of <code>f2()</code> and <code>f3()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f1</span>(<span class="hljs-number">99</span>); <span class="hljs-comment">// error: f1(X(99)) not tried: non-const X&amp; argument</span><br>    <span class="hljs-built_in">f2</span>(<span class="hljs-number">99</span>); <span class="hljs-comment">// OK: f2(X(99)); const X&amp; argument</span><br>    <span class="hljs-built_in">f3</span>(<span class="hljs-number">99</span>); <span class="hljs-comment">// OK: f3(X(99)); X argument</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="65">
<li><p>An operation modifying the state of a class object should therefore be a member or a function taking a non-<code>const</code> reference argument (or a non-<code>const</code> pointer argument).</p>
<p>Operators that modify an operand (e.g., <code>=</code>, <code>*=</code>, and <code>++</code>) are most naturally defined as members for user-defined types.</p>
<p>Conversely, if implicit type conversion is desired for all operands of an operation, the function implementing it must be a nonmember function taking a <code>const</code> reference argument or a non-reference argument.</p>
<ul>
<li>This is often the case for the functions implementing operators that do not require lvalue operands when applied to fundamental types (e.g., <code>+</code>, <code>-</code>, and <code>||</code>)</li>
<li>However, such operators often need access to the representations of their operand class.</li>
<li>Consequently, binary operators are the most common source of friend function.</li>
</ul>
</li>
</ol>
<ol start="66">
<li><p>Unless type conversions are defined, there appears to be no compelling reason to choose a member over a friend taking reference argument, or vice versa.</p>
<p>In some cases, the programmer may have a preference for one call syntax over another.</p>
<ul>
<li>For example, most people seem to prefer the notion <code>m2=inv(m)</code> for producing a inverted <code>Matrix</code> from <code>m</code> to the alternative <code>m2=m.inv()</code>.</li>
<li>On the other hand, if <code>inv()</code> inverts <code>m</code> itself, rather than producing a new <code>Matrix</code> that is the inverse of <code>m</code>, it should be a member.</li>
</ul>
<p>All other things considered equal, implement operations that need direct access to a representation as member function:</p>
<ul>
<li><p>It is not possible to know if someone someday will define a conversion operator.</p>
</li>
<li><p>The member function call syntax makes it clear to the user that the object may be modified; a reference argument is far less obvious.</p>
</li>
<li><p>Expressions in the body of a member can be noticeably shorter than the equivalent expressions in a global function.</p>
<p>A nonmember function must use an explicit argument, whereas the member can use <code>this</code> implicitly.</p>
</li>
<li><p>Member names are local to a class, so they tend to be shorter than the names of nonmember functions.</p>
</li>
<li><p>If we have defined a member <code>f()</code> and we later feel the need for a nonmember <code>f()</code>, we can simply define it to mean <code>x.f()</code>.</p>
</li>
</ul>
<p>Conversely, operations that do not need direct access to a representation are often best represented as nonmember functions, possibly in a namespace that makes their relationship with the class explicit (section 18.3.6).</p>
</li>
</ol>
<h3 id="19-5-Advice"><a href="#19-5-Advice" class="headerlink" title="19.5 Advice"></a>19.5 Advice</h3><ul>
<li>Use <code>operator[]()</code> for subscripting and for selection based on a single value; section 19.2.1.</li>
<li>User <code>operator()()</code> for call semantices, for subscripting, and for selection based on multiple values; section 19.2.2.</li>
<li>User <code>operator-&gt;()</code> to dereference “smart pointer”; section 19.2.3.</li>
<li>Prefer prefix <code>++</code> over suffix <code>++</code>; section 19.2.4</li>
<li>Define the global <code>operator new()</code> and <code>operator delete()</code> only if you really have to; section 19.2.5.</li>
<li>Define member <code>operator new()</code> and member <code>operator delete()</code> to control allocation and deallocation of objects of a specific class or hierarchy of classes; section 19.2.5. </li>
<li>Use user-defined literals to mimic conventional notation; section 19.2.6.</li>
<li>Place literal operators in separate namespaces to allow selective use; section 19.2.6.</li>
<li>For nonspecialize uses, prefer the standard <code>string</code> (Chapter 36) to the result of your own exercises; 19.3.</li>
<li>Use a friend function if you need a nonmember function to have access to the representation of a class. (e.g., to improve notation or to access the representation of two classes); section 19.4</li>
<li>Prefer member functions to friend functions for granting access to the implementation of a class; section 19.4.2.</li>
</ul>
<h2 id="Chapter-20-Derived-Classes"><a href="#Chapter-20-Derived-Classes" class="headerlink" title="Chapter 20. Derived Classes"></a>Chapter 20. Derived Classes</h2><ul>
<li>Introduction</li>
<li>Derived Classes<ul>
<li> Member Functions</li>
<li>Constructors and Destructors</li>
</ul>
</li>
<li>Class Hierarchies<ul>
<li>Type Field</li>
<li>Virtual Functions</li>
<li>Explicit Qualification</li>
<li>Override Control</li>
<li><code>using</code> Base Members</li>
<li>Return Type Relaxation</li>
</ul>
</li>
<li>Abstract Classes</li>
<li>Access Control<ul>
<li><code>protected</code> Members</li>
<li>Access to Base Classes</li>
<li><code>using</code>-Declarations and Access Control</li>
</ul>
</li>
<li>Pointers to Members<ul>
<li>Pointers to Function Members</li>
<li>Pointers to Data Members</li>
<li>Base and Derived Members</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="20-1-Introduction"><a href="#20-1-Introduction" class="headerlink" title="20.1 Introduction"></a>20.1 Introduction</h3><ol>
<li><p>From [Simula](<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Simula">Simula - Wikipedia</a>), C++ borrowed the ideas of classes and class hierarchies.</p>
<p>In addition, it borrowed the design idea that classes should be used to model concepts in the progrmmer’s and the application’s world.</p>
<ul>
<li>C++ provides language constructs that directly support these design notions.</li>
<li>Conversely, using the language features in support of design ideas distinguishes effective use of C++. Using language constructs as just notional props for traditional types of programming is to miss key strength of C++.</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>A concept (idea, notion, etc.) does not exist in isolation. </p>
<p>It coexists with realed concepts and derives much of its power from relationships with other concepts.</p>
<ul>
<li>For example, try to explain what a car is. Soon you’ll have introduced the notions of wheels, engines, drivers, pedestrains, trucks, ambulances, roads, oil, sppeding tickets, motels, etc.</li>
</ul>
<p>Since we uses classes to represent concepts, the issue becomes how to represent relationships among concepts.</p>
<p>However, we can’t express arbitrary relationships directly in a programming language.</p>
<ul>
<li>Even if we could, we wouldn’t want to.</li>
<li>To be useful, our classes should be more narrowly defined that our everyday concepts – and more precise.</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>The notion of a derived class and its associated language mechanisms are provided to express hierachical relationships, that is, to express commonality between classes.</p>
<ul>
<li>For example, the concepts of a circle and a triangle are related in that they are both shapes; that is, they have the concept of a shape in common.<ul>
<li>Thus, we explicitly define class <code>Circle</code> and class <code>Triangle</code> to have class <code>Shape</code> in common.</li>
<li>In that case, the common class, here <code>Shape</code>, is refered to as the <em><strong>base</strong></em> class or <em><strong>superclasses</strong></em> and classes derived from that, here <code>Circle</code> and <code>Triangle</code>, are refered to as <em><strong>derived</strong></em> classes or <em><strong>subclasses</strong></em>.</li>
<li>Representing a circle and a triangle in a program without involving the notion of a shape would be to miss something essential.</li>
</ul>
</li>
</ul>
<p>This chapter is an exploration of the implications of this simple idea, which is the basis for what is commonly called <em><strong>object-oriented programming</strong></em>.</p>
<p>The language features support building new classes from existing ones:</p>
<ul>
<li><em><strong>implementation inheritance</strong></em>: to save implementation effort by sharing facilities provided by a base class.</li>
<li><em><strong>Interface inheritance</strong></em>: to allow different derived classes to be used interchangeably through the interface provided by a common base class.</li>
</ul>
<p>Interface inheritance is often refered to as <em><strong>run-time polymorphism</strong></em> (or <em><strong>dynamic polymorphism</strong></em>).</p>
<p>In contrast, the uniform use of classes not related by inheritance provided by templates (section 3.4, Chapter 23) is often reffered to as <em><strong>compile-time polymorphism</strong></em> (or <em><strong>static polymorphism</strong></em>).</p>
</li>
</ol>
<ol start="4">
<li>The discussion of class hierarchies is organized into three chapters:<ul>
<li><em><strong>Derived Classes</strong></em> (Chapter 20): <ul>
<li>This chapter introduces the basic languge features supporting object-oriented programming.</li>
<li>Base and derived classes, virtual functionsm and access control are covered.</li>
</ul>
</li>
<li><em><strong>Class Hierarchies</strong></em> (Chapter 21):<ul>
<li>This chapter focuses on the use of base and derived classes to effectively organize code around the notion of class hierarchies.</li>
<li>Most of this chapter is devoted to discussion of programming techniques, but technical aspects of multiple inheritance (classes with more than one base class) are also covered.</li>
</ul>
</li>
<li><em><strong>Run-time Type Identification</strong></em> (Chapter 22):<ul>
<li>This chapter describes the techniques for explicitly navigating class hierarchies.</li>
<li>In particular, the type conversion operations <code>dynamic_cast</code> and <code>static_cast</code> are presented, as is the operation for determining the type of an object given one of its base classes (<code>typeid</code>).</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>A brief introduction to the basic idea of hierarchical organization of types can be found in Chapter 3: base and derived classes (section 3.2.2) and virtual functions (section 3.2.3).</p>
<p>These chapters (Chapter 20,21,22) examine these fundamental features and their associated programming and design techniques in greater detail.</p>
</li>
</ol>
<h3 id="20-2-Derived-Classes"><a href="#20-2-Derived-Classes" class="headerlink" title="20.2 Derived Classes"></a>20.2 Derived Classes</h3><ol start="6">
<li><p>Cosider building a program dealing with people employed by a firm.</p>
<ul>
<li><p>Such a program might have a data structure like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Employee</span> &#123;<br>    string first_name, family_name;<br>    <span class="hljs-type">char</span> middle_initial;<br>    Data hiring_date;<br>    <span class="hljs-type">short</span> department;<br>    /<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Next, we might try to define a manager:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Manager</span> &#123;<br>    Employee emp; <span class="hljs-comment">// manager&#x27;s empoyee record</span><br>    list&lt;Emplotee*&gt; group; <span class="hljs-comment">// people managed</span><br>    <span class="hljs-type">short</span> level;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>A manager is also an employee; the <code>Employee</code> data is stored in the <code>emp</code> member of a <code>Manager</code> object.</p>
<ul>
<li>This may be obvious to a human reader – especially a careful reader – but there is nothing that tells the compiler and other tools that <code>Manager</code> is also an <code>Employee</code>.</li>
</ul>
</li>
<li><p>A <code>Manager*</code> is not an <code>Employee*</code>, so one cannot simply use one where the other is required.</p>
<ul>
<li>In particular, one cannot put a <code>Manger</code> onto a list of <code>Employee</code>s without writing special code.</li>
<li>We could either use explicit type conversion on a <code>Manager*</code> or put the address of the <code>emp</code> member onto a list of <code>employee</code>s.</li>
<li>However, both solutions are inelegant and can be quite obscure.</li>
</ul>
</li>
<li><p>The correct approach is to explicitly state that a <code>Manager</code> is an <code>Employee</code>, with a few pieces of information added.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br>    list&lt;Employee*&gt; group;<br>    <span class="hljs-type">short</span> level;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>Manager</code> is <em><strong>derived</strong></em> from <code>Employee</code>, and conversely, <code>Employee</code> is a <em><strong>base class</strong></em> for <code>Manager</code>.</li>
<li>The class <code>Manager</code> has the members of class <code>Employee</code> (<code>first_name</code>, <code>department</code>, etc.) in addition to its own members (<code>group</code>, <code>level</code>, etc.).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="7">
<li><p>Derivation is often represented graphically by a pointer from the derived class to its base class indicating that the derived class refers to its base (rather than other way around):</p>
<ul>
<li><img src="image-20230129145841357.png" srcset="/img/loading.gif" lazyload alt="image-20230129145841357"></li>
</ul>
<p>A derived class is often said to inherit properties from its base, so the relationship is also called <em><strong>inheritance</strong></em>.</p>
<p>A base class is sometimes called a <em><strong>superclass</strong></em> and a derived class a <em><strong>subclass</strong></em>. </p>
<ul>
<li>This terminology, however, is confusing to people who observe that the data in a derived class object is a superset of the data of an object of its base class.</li>
</ul>
<p>A derived class is typically larger (and never smaller) than its base class in the sense that it holds more data and provides more functions.</p>
</li>
</ol>
<ol start="8">
<li><p><strong>A popular and efficient implementation of the notion of derived classes has an object of the derived class represented as an object of the base class, with the infomation belonging specifically to the derived classes added at the end</strong>.</p>
<p>For example:</p>
<ul>
<li><img src="image-20230129221203091.png" srcset="/img/loading.gif" lazyload alt="image-20230129221203091"></li>
</ul>
<p>No memory overhead is implied by deriving a class. </p>
<ul>
<li>The space required is just the space required by the members.</li>
</ul>
<p>Deriving <code>Manager</code> from <code>Employee</code> in this way makes <code>Manager</code> a subtype of <code>Employee</code>, so that a <code>Manager</code> can be used wherever an <code>Employee</code> is acceptable.</p>
<ul>
<li><p>For example, we can now create a list of <code>Empoyee</code>s, some of whom are <code>Manager</code>s:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Manager m1, Employee e1)</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;Employee*&gt; elist&#123;&amp;m1,&amp;e1&#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>A <code>Manager</code> is (also) an <code>Employee</code>, so a <code>Manager*</code> can be used as an <code>Employee*</code>.</p>
<p>Similarly, a <code>Manager&amp;</code> can be used as an <code>Employee&amp;</code>.</p>
</li>
<li><p>However, an <code>Employee</code> is not necessarily a <code>Manager</code>, so an <code>Employee*</code> cannot be used as a <code>Manager*</code>.</p>
</li>
</ul>
</li>
</ul>
<p>In general, <strong>if a class <code>Derived</code> has a public base class (section 20.5) <code>Base</code>, then a <code>Derived*</code> can be assigned to a variable of type <code>Base*</code> without the use of explicit type conversion</strong>.</p>
<p><strong>The opposite conversion, from <code>Base*</code> to <code>Derived*</code>, must be explicit</strong>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Manager mm, Employee ee)</span></span><br><span class="hljs-function"></span>&#123;<br>    Employee* pe = &amp;mm; <span class="hljs-comment">// OK every manager is an Employee</span><br>    Manager* pm = &amp;ee; <span class="hljs-comment">// Error: not every Employee is a Manager</span><br>    <br>    pm-&gt;level = <span class="hljs-number">2</span>; <span class="hljs-comment">// disaster: ee doesn&#x27;t have a level (only Manger has level member)</span><br>    <br>    pm = <span class="hljs-built_in">static_cast</span>&lt;Manager*&gt;(pe); <span class="hljs-comment">// brute force: works because pe points to the Manager mm</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>In other words, an object of a derived class can be treated as an object of its base class when manipulated through pointers and references. </p>
</li>
<li><p>The opposite is not true.</p>
</li>
</ul>
<p>The use of <code>static_cast</code> and <code>dynamic_cast</code> is discussed in section 22.2.</p>
</li>
</ol>
<ol start="9">
<li><p>Using a class as base is equivalent to defining an (unnamed) object of that class.</p>
<p>Consequently, a class must be defined in order to be used as a base (section 8.2.2-&gt;2):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>; <span class="hljs-comment">// declaration only, no definition</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123; <span class="hljs-comment">// Error : Employee not defined section 8.2.2-&gt;2: </span><br>    							  <span class="hljs-comment">//         the name of members and the size of Employee unknown </span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="20-2-1-Member-Functions"><a href="#20-2-1-Member-Functions" class="headerlink" title="20.2.1 Member Functions"></a>20.2.1 Member Functions</h4><ol start="10">
<li><p>Simple data structures, such as <code>Employee</code> and <code> Manger</code>, are  really not that interesting and often not particularly useful.</p>
<p>We need provide a proper type with a suitable set of operations, and we need to do so without being tied to the details of a particualr representation. </p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">string <span class="hljs-title">full_name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> first_name + <span class="hljs-string">&#x27; &#x27;</span> + middle_initial + <span class="hljs-string">&#x27; &#x27;</span> + family_name;&#125;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    string first_name, family_name;<br>    <span class="hljs-type">char</span> middle_initial;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>A member of a derived class can be use the <strong>public</strong> – and <strong>protected</strong> (section 20.5) – <strong>members of a base class</strong> as if they were declared in the derived class itself.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Manager::print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name is &quot;</span> &lt;&lt; <span class="hljs-built_in">full_name</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// full_name() from base class Employee</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>However, a derived class cannot access <strong>private members of a base class:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Manager::print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name is &quot;</span> &lt;&lt; first_name &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// Error: first_name is a private member of base Employee</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The second version of <code>Manager::print</code> will not compile because <code>family_name</code> is not access to <code>Manager::print()</code>.</li>
</ul>
<p>This comes as a surprise to some, but consider the alternative: that a member function of a derived class could access the private members of its base class.</p>
<ul>
<li>The concept of a private member would be rendered meaningless by allowing a programmer to gain access to private part of a class simply by deriving a new class from it.</li>
<li>Furthermore, one would no longer find all uses of a private name by looking at the functions declared as members and friends of that class.<ul>
<li>One would have to examine every source file of the complete program for derived classes, then examine every function of those classes, then find every class derived from those classes, etc.</li>
<li>That is, at best, tedious and often impractical.</li>
</ul>
</li>
<li>Where it is acceptable, <strong>proteced</strong> – rather than <strong>private</strong> members can be used (section 20.5).</li>
</ul>
</li>
</ol>
<ol start="11">
<li><p>Typically, the cleanest solution is for the derived class to use only the public members of its base class.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Manager::print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// :: must be used</span></span><br><span class="hljs-function"></span>&#123;<br>    Employee::<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// print Employee information (:: must be used)</span><br>    cout &lt;&lt; level; <span class="hljs-comment">// print Manager-specific information</span><br>  	<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li></li>
<li><p>Note that <code>::</code> must be used because <code>print()</code> has beed redefined in <code>Manager</code>.</p>
<p>Such reuse of names if typical.</p>
</li>
<li><p>The unwary might write this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Manager::print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">print</span>(); <span class="hljs-comment">// oops!</span><br>    <span class="hljs-comment">// print Manager-specific information</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The result is a sequence of recursive calls ending with some form of program crash.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="20-2-2-Constructors-and-Destructors"><a href="#20-2-2-Constructors-and-Destructors" class="headerlink" title="20.2.2 Constructors and Destructors"></a>20.2.2 Constructors and Destructors</h4><ol start="12">
<li><p>As usual, constructors and destructors are as essential:</p>
<ul>
<li><p><strong>Objects are constructed from the bottom up</strong> (<strong>base before member and member before derived</strong>) </p>
<p>and <strong>destroyed top-bottem</strong> (<strong>derived before member and member before base</strong>); section 17.2.3</p>
</li>
<li><p>Each class can initialize its members and bases (but not directly members or bases of its bases); section 17.4.1</p>
</li>
<li><p>Typically, destructors in a hierarchy need to be <code>virtual</code>; section 17.2.5</p>
</li>
<li><p>Copy constructors of classes in a hierarchy should be used with care (if at all) to avoid slicing; section 17.5.1.4</p>
</li>
<li><p>The resolution of a virtual function call, a <code>dynamic_cast</code>, or a <code>typeid()</code> in a constructor or destructor reflects the stage of construction and destruction (rather than the type of the yet-to-be-completed object); section 22.4</p>
</li>
</ul>
</li>
</ol>
<ol start="13">
<li><p>In computer science “up” and “down” can get very confused.</p>
<p>In source text, definitions of base classes must occur before the definitions of their derived classes.</p>
<ul>
<li>This implies that for small examples, the bases appears above the derived classes on a screen.</li>
</ul>
<p>Furthermore, we tend to draw trees with the root on top.</p>
<p>However, when I talk about constructing objects from the bottem up, I mean starting with the most fundamental (e.g., base classes) and building what depends on that (e.g., derived classes) later.</p>
<p>We build from the roots (base classes) toward the leaves (dericed classes).</p>
</li>
</ol>
<h3 id="20-3-Class-Hierarchies"><a href="#20-3-Class-Hierarchies" class="headerlink" title="20.3 Class Hierarchies"></a>20.3 Class Hierarchies</h3><ol start="14">
<li><p>A derived class can itself be a base class.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> : <span class="hljs-keyword">public</span> Manager &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Such a set of related classes is traditionally called a <em><strong>class hierarchy</strong></em>.</p>
<p>Such a hierarchy is most often a tree, but it can also be a more general graph structure.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Temporary</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Assistant</span> : <span class="hljs-keyword">public</span> Employee &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Temp</span> : <span class="hljs-keyword">public</span> Temporary, <span class="hljs-keyword">public</span> Assistant &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consultant</span> : <span class="hljs-keyword">public</span> Temporary, <span class="hljs-keyword">public</span> Manager &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230203201357089.png" srcset="/img/loading.gif" lazyload alt="image-20230203201357089"></p>
</li>
</ul>
<p>Thus, as is explained in detail in section 21.3, C++ can express a directed acyclic graph of classes.</p>
</li>
</ol>
<h4 id="20-3-1-Type-Fields"><a href="#20-3-1-Type-Fields" class="headerlink" title="20.3.1 Type Fields"></a>20.3.1 Type Fields</h4><ol start="15">
<li><p>To use derived classes as more than a convenient shorthand in declarations, we must solve the following probem:</p>
<ul>
<li>Given a pointer of type <code>Base*</code>, to which derived type does the object pointed to really belong?</li>
</ul>
<p>There are four fundamental solutions:</p>
<ul>
<li>Ensure that only objects of a single type are pointed to (section 3.4, Chapter 23)</li>
<li>Place a type field in the base class for the functions to inspect.</li>
<li>Use <code>dynamic_cast</code> (section 22.2, section 22.6)</li>
<li>Use virtual functions (section 3.2.3, section 20.3.2).</li>
</ul>
<p>Unless you have used <code>final</code> (section 20.3.4.2), solution 1 relies on more knowledge about the types involved than is available to the compiler.</p>
<ul>
<li>In general, it is not a good idea to try to be smarter than the type system, but (especially in combination with the use of templates) it can be used to implement homogeneous containers (e.g., the standard-library <code>vector</code> and <code>map</code>) with unsurpassed performance.</li>
</ul>
<p>Solutions 2, 3, and 4 can be used to build hetergeneous lists, that is, lists of (pointers to) objects of several different types.</p>
<ul>
<li>Solution 3 is a language-supported variant of solution 2.</li>
<li>Solution 4 is a special type-safe variant of solution 2.</li>
</ul>
<p>Combinations of solution 1 and 4 are particularly interesting and powerful; in almost all situations, they yield cleaner code than do solutions 2 and 3.</p>
</li>
<li><p>Let us first examine the simple type-filed solution to see why it is typically best avoided.</p>
<ul>
<li><p>The manager/employee example could be redefined like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Empl_type</span> &#123;man, empl&#125;;<br>    Empl_type type; <span class="hljs-comment">// type field</span><br>    <br>    <span class="hljs-built_in">Employee</span>() : type&#123;empl&#125; &#123;&#125;<br>    <br>    string first_name, family_name;<br>    <span class="hljs-type">char</span> middle_initial;<br>    <br>    Date hiring_date;<br>    <span class="hljs-type">short</span> department;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br>    <span class="hljs-built_in">Manager</span>() &#123; type = man;&#125;<br>    <br>    list&lt;Employee*&gt; group; <span class="hljs-comment">// people managed</span><br>    <span class="hljs-type">short</span> level;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Given this, we can now write a function that prints information about each <code>Employee</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_employee</span><span class="hljs-params">(<span class="hljs-type">const</span> Employee* e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (e-&gt;type) &#123;<br>        <span class="hljs-keyword">case</span> Employee::empl:<br>            cout &lt;&lt; e-&gt;family_name &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; e-&gt;department &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> Employee::man:<br>            cout &lt;&lt; e-&gt;family_name &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; e-&gt;department &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-type">const</span> Manager* p = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> Manager*&gt;(e);<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>and use it to print a list of <code>Employee</code>s, like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;Employee*&gt;&amp; elist)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : elist)<br>        <span class="hljs-built_in">print_employee</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>This works fine, especially in a small program maintained by a single person.</p>
</li>
<li><p>However, it has a fundamental weakness in that it depends on the programmer manipulating types in a way that cannot be checked by the compiler.</p>
<p>This problem is usally made worse because functions such as <code>print_employee()</code> are often organized to take advantage of commonality of class involved.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_employee</span><span class="hljs-params">(<span class="hljs-type">const</span> Employee* e)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; e-&gt;family_name &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; e-&gt;department &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (e-&gt;type == Employee::man) &#123;<br>        <span class="hljs-type">const</span> Manager* p = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> Manager*&gt;(e);<br>        cout &lt;&lt; <span class="hljs-string">&quot; level &quot;</span> &lt;&lt; p-&gt;level &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Finding all such tests on the type field buried in a large function that handles many derived classes can be difficult.</p>
<p>Even when they have been found, understanding what is going on can be difficult.</p>
<p>Furthermore, any addition of a new kind of <code>Employee</code> involves a change to all the key functions in a system – the ones containing the tests on the type field.</p>
</li>
<li><p>The programmer must consider every function that could conceivably need a test on the type field after a change.</p>
<p>This implies the need to access critical source code and the resulting necessary overhead of testing the affected code.</p>
</li>
<li><p>The use of an explicit type conversion is a strong hint that improvement is possible.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In other words, use of a type field is an error-prone technique that leads to maintenance problems.</p>
<ul>
<li><p>The problems increase in severity as the size of the program increase because the use of a type field causes a violation of the ideals of modularity and data hiding.</p>
</li>
<li><p>Each function using a type field must know about the representation and other details of the implementation of every class derived from the one containing the type field.</p>
</li>
</ul>
<p>It also seems that any common data accessible from every derived class, such as a type field, tempts people to add more such data.</p>
<ul>
<li><p>The common base thus becomes the repository of all kinds of “useful information.”</p>
<p>This, in turn, gets the implementation of the base and derived classes interwined in that are most undesirable.</p>
</li>
<li><p>In a large class hierarchy, accessible (not <code>private</code>) data in a common base class becomes the “global variables” of the hierarchy.</p>
</li>
<li><p>For clean design and simpler maintenance, we want to keep separate issues separate and avoid mutual dependencies.</p>
</li>
</ul>
</li>
</ol>
<h4 id="20-3-2-Virtual-Functions"><a href="#20-3-2-Virtual-Functions" class="headerlink" title="20.3.2 Virtual Functions"></a>20.3.2 Virtual Functions</h4><ol start="17">
<li><p>Virtual functions overcome the problems with the type-field solution by allowing the programmer to declare functions in a base class that can be redefined in each derived class.</p>
<p>The compiler and linker will guarantee the correct correspondence between objects and the funtions applied to them.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">int</span> dept);<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    string first_name, family_name;<br>    <span class="hljs-type">short</span> department;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The keyword <code>virtual</code> indicates that <code>print()</code> can act as an interface to the <code>print()</code> function defined in this class and <code>print()</code> functions defined in classes derived from it.</li>
<li>Where such <code>print()</code> functions are defined in derived classes, the compiler ensures that the right <code>print()</code> for the given <code>Employee</code> object is invoked in each case.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="18">
<li><p>To allow a virtual function declaration to act as an interface to functions defined in derived classes, the argument types specified for a function in a derived class cannot differ from the argument types declared in the base, and only very slight changes are allowed for the return type.</p>
<p>A virtual member function is sometimes called a <em><strong>method</strong></em>.</p>
</li>
</ol>
<ol start="19">
<li><p>A virtual function must be defined for the class in which it is first declared (unless it is declared to be a pure virtual function; section 20.4).</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; family_name &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; department &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>A virtual function can be used even if no class is derived from its class, and a derived class that does not need its own version of a virtual function need not provide one.</p>
<p>When deriving a class, simply provide an appropriate function if it is needed.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Manager</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">int</span> dept, <span class="hljs-type">int</span> lvl);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    list&lt;Employee*&gt; group;<br>    <span class="hljs-type">short</span> level;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Manager::print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    Employee::<span class="hljs-built_in">print</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;\tlevel &quot;</span> &lt;&lt; level &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>A function from a derived class with the same name and the same set of argument types as a virtual function in a base is said to <em><strong>override</strong></em> the base class version of the virtual function.</p>
<ul>
<li>Furthermore, it is possible to override a virtual function from a base with a more derived return type (section 20.3.6)</li>
</ul>
<p>Except where we explicitly say which version of a virtual function is called (as in the call <code>Employee::print()</code>), the overriding function is choosen as the most appropriate for the object for which it is called.</p>
<ul>
<li>Independently of which base class (interface) is used to access an object, we always get the same function when we use the virtual function call mechanism.</li>
</ul>
<p>The global function <code>print_employee()</code> (type field, section 20.3.1) is now unneccessary because the <code>print()</code> member functions have taken its place.</p>
<ul>
<li><p>A list of <code>Employee</code>s can be printed like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;Employee∗&gt;&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s)<br>        x−&gt;<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Each Employee will be written out according to its type.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Employee e &#123;<span class="hljs-string">&quot;Brown&quot;</span>,<span class="hljs-number">1234</span>&#125;;<br>    Manager m &#123;<span class="hljs-string">&quot;Smith&quot;</span>,<span class="hljs-number">1234</span>,<span class="hljs-number">2</span>&#125;;<br>    <br>    <span class="hljs-built_in">print_list</span>(&#123;&amp;e,&amp;m&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>produced:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs terminal">Smith 1234<br>    level 2<br>Brown 1234<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Note that this will work even if <code>print_list()</code> was written and compiled before the specific derived class Manager was even conceived of! </p>
<p>This is a key aspect of classes.</p>
</li>
<li><p>When used properly, it becomes the cornerstone of object-oriented designs and provides a degree of stability to an evolving program.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="20">
<li><p>Getting ‘‘the right’’ behavior from <code>Employee</code>’s functions independently of exactly what kind of Employee is actually used is called <em><strong>polymorphism</strong></em>.</p>
<p><strong>A type with virtual functions</strong> is called a <em><strong>polymorphic type</strong></em> or (more precisely) a <em><strong>run-time polymorphic type</strong></em>.</p>
<p>To get runtime polymorphic behavior in C++, the member functions called must be <code>virtual</code> and objects must be manipulated through pointers or references.</p>
<ul>
<li>When manipulating an object directly (rather than through a pointer or reference), its exact type is known by the compiler so that run-time polymorphism is not needed.</li>
</ul>
</li>
</ol>
<ol start="21">
<li>By default, a function that overrides a virtual function itself becomes <code>virtual</code>. <ul>
<li>We can, but do not have to, repeat virtual in a derived class. </li>
<li>I don’t recommend repeating virtual. If you want to be explicit, use <code>override</code> (§20.3.4.1).</li>
</ul>
</li>
</ol>
<ol start="22">
<li><p>Clearly, to implement polymorphism, the compiler must store some kind of type information in each object of class Employee and use it to call the right version of the virtual function print().</p>
<p>In a typical implementation, the space taken is just enough to hold a pointer (§3.2.3):</p>
<ul>
<li>The usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions.<ul>
<li>That table is usually called the <em><strong>virtual function table</strong></em> or simply the <code>vtbl</code>.</li>
</ul>
</li>
</ul>
<p>Each class with virtual functions has its own <code>vtbl</code> identifying its virtual functions.</p>
<ul>
<li><p>This can be represented graphically like this:</p>
<p><img src="image-20230204162048178.png" srcset="/img/loading.gif" lazyload alt="image-20230204162048178"></p>
</li>
<li><p>The functions in the <code>vtbl</code> allow the object to be used correctly even when the size of the object and the layout of its data are unknown to the caller.</p>
</li>
</ul>
<p>The implementation of a caller need only know the location of the <code>vtbl</code> in an <code>Employee</code> and the index used for each virtual function.</p>
<ul>
<li>This virtual call mechanism can be made almost as efficient as the ‘‘normal function call’’ mechanism (within 25%), so efficiency concerns should not deter anyone from using a virtual function where an ordinary function call would be acceptably efficient.</li>
</ul>
<p>Its space overhead is <strong>one pointer in each object of a class</strong> with <strong>virtual functions</strong> plus <strong>one <code>vtbl</code> for each such class</strong>.</p>
<ul>
<li>You pay this overhead only for objects of a class with a virtual function. </li>
<li>You choose to pay this overhead only if you need the added functionality virtual functions provide. </li>
<li>Had you chosen to use the alternative type-field solution, a comparable amount of space would have been needed for the type field.</li>
</ul>
</li>
</ol>
<ol start="23">
<li><p>A virtual function invoked from a constructor or a destructor reflects that the object is partially constructed or partially destroyed (§22.4). </p>
<p>It is therefore typically a bad idea to call a virtual function from a constructor or a destructor.</p>
</li>
</ol>
<h4 id="20-3-3-Explicit-Qualification"><a href="#20-3-3-Explicit-Qualification" class="headerlink" title="20.3.3 Explicit Qualification"></a>20.3.3 Explicit Qualification</h4><ol start="23">
<li><p>Calling a function using the scope resolution operator, <code>::</code>, as is done in <code>Manager::print()</code> ensures that the virtual mechanism is not used.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Manager::print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    Employee::<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// not a virtual call</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\tlevel &quot;</span> &lt;&lt; level &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Otherwise, <code>Manager::print()</code> would suffer an infinite recursion.</li>
</ul>
</li>
</ul>
<p>The use of a qualified name has another desirable effect. </p>
<p>That is, if a virtual function is also <code>inline</code> (as is not uncommon), then inline substitution can be used for calls specified using <code>::</code>.</p>
<ul>
<li><p>This provides the programmer with an eficient way to handle some important special cases in which one virtual function calls another for the same object.</p>
</li>
<li><p>The <code>Manager::print()</code> function is an example of this. </p>
<p>Because the type of the object is determined in the call of <code>Manager::print()</code>, it need not be dynamically determined again for the resulting call of <code>Employee::print()</code>.</p>
</li>
</ul>
</li>
</ol>
<h4 id="20-3-4-Override-Control"><a href="#20-3-4-Override-Control" class="headerlink" title="20.3.4 Override Control"></a>20.3.4 Override Control</h4><ol start="24">
<li><p>If you declare a function in a derived class that has exactly the same name and type as a virtual function in a base class, then the function in the derived class overrides the one in the base class.</p>
<ul>
<li>That’s a simple and effective rule.</li>
</ul>
<p>However, for larger class hierarchies it can be difficult to be sure that you actually override the function you meant to override.</p>
<ul>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B0</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B1</span> : B0 &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B2</span> : B1 &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B3</span> : B2 &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B4</span> : B3 &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B5</span> : B4 &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : B5 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// override f() in base class</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// override g() in base class</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// override h() in base class</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>This illustrates three errors that are far from obvious when they appear in a real class hierarchy where the classes <code>B0</code>…<code>B5</code> have many members each and are scattered over many header files.</p>
<p>Here:</p>
<ul>
<li><p><code>B0::f()</code> is not <code>virtual</code>, so you can’t override it, only hide it (§20.3.5).</p>
</li>
<li><p><code>D::g()</code> doesn’t hav e the same argument type as <code>B0::g()</code>, so if it overrides anything it’s not the<br>virtual function <code>B0::g()</code>. </p>
<p>Most likely, <code>D::g()</code> just hides <code>B0::g()</code>.</p>
</li>
<li><p>There is no function called <code>h()</code> in <code>B0</code>, if <code>D::h()</code> overrides anything, it is not a function from <code>B0</code>.<br>Most likely, it is introducing a brand-new virtual function.</p>
</li>
</ul>
</li>
<li><p>I didn’t show you what was in <code>B1</code>…<code>B5</code>, so maybe something completely different is going on because of declarations in those classes.</p>
</li>
</ul>
</li>
</ul>
<p>I personally don’t (redundantly) use <code>virtual</code> for a function that’s meant to override.</p>
<p>For smaller programs (especially with a compiler with decent warnings against common mistakes) getting overriding done correctly isn’t hard.</p>
<p>However, for larger hierarchies more specific controls are useful:</p>
<ul>
<li><code>virtual</code>: The function may be overridden (§20.3.2).</li>
<li><code>=0</code>: The function must be <code>virtual</code> and must be overridden (§20.4).</li>
<li><code>override</code>: The function is meant to override a <code>virtual</code> function in a base class (§20.3.4.1).</li>
<li><code>final</code>: The function is not meant to be overridden (§20.3.4.2).</li>
</ul>
<p>In the absence of any of these controls, a non-<code>static</code> member function is virtual if and only if it overridesa virtual function in a base class (§20.3.2).</p>
</li>
</ol>
<ol start="25">
<li>A compiler can warn against inconsistent use of explicit override controls. <ul>
<li>For example, a class declaration that uses <code>override</code> for seven out of nine virtual base class functions could be confusing to maintainers.</li>
</ul>
</li>
</ol>
<h5 id="20-3-4-1-override"><a href="#20-3-4-1-override" class="headerlink" title="20.3.4.1 override"></a>20.3.4.1 <code>override</code></h5><ol start="26">
<li><p>We can be explicit about our desire to override:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : B5 &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// error: B0::f() is not virtual</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// error: B0::f() takes a double argument</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// error: no function h() to overr ide</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Given this definition (and assuming that the intermediate base classes <code>B1</code>…<code>B5</code> do not provide relevant functions), all three declarations give errors.</li>
</ul>
</li>
</ol>
<ol start="27">
<li>In a large or complicated class hierarchy with many virtual functions, it is best to use <code>virtual</code> only to introduce a new virtual function and to use <code>override</code> on all functions intended as overriders.<ul>
<li>Using <code>override</code> is a bit verbose but clarifies the programmer’s intent.</li>
</ul>
</li>
</ol>
<ol start="28">
<li><p>The <code>override</code> specifier comes last in a declaration, after all other parts. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// OK (if there is a suitable f() to override)</span><br><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// syntax error</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// syntax error</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>And yes, it’s illogical that virtual is a prefix and override is a suffix.</p>
<ul>
<li>This is part of the price we pay for compatibility and stability over decades.</li>
</ul>
</li>
</ol>
<ol start="29">
<li><p>An <code>override</code> specifier is not part of the type of a function and cannot be repeated in an out-of-class definition. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// OK if Base has a virtual f()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// OK if Base has a virtual g()</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Derived::f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-comment">// error : override out of class</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> <span class="hljs-comment">// OK</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Curiously, <code>override</code> is not a keyword; it is what is called a <em><strong>contextual keyword</strong></em>. </p>
<p>That is, <code>override</code> has a special meaning in a few contexts but can be used as an identifier elsewhere. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> <span class="hljs-keyword">override</span> = <span class="hljs-number">7</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dx</span> : Base &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">override</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">override</span> + ::<span class="hljs-keyword">override</span>;<br>    &#125;	<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Don’t indulge in such cleverness; it complicates maintenance.</p>
<p>The only reason that <code>override</code> is a contextual keyword, rather than an ordinary keyword, is that there exists a significant amount of code that has used <code>override</code> as an ordinary identifier for decades. </p>
<p>The other contextual keyword is <code>final</code> (§20.3.4.2).</p>
</li>
</ol>
<h5 id="20-3-4-2-final"><a href="#20-3-4-2-final" class="headerlink" title="20.3.4.2 final"></a>20.3.4.2 <code>final</code></h5><ol start="30">
<li><p>When we declare a member function, we have a choice between <code>virtual</code> and not <code>virtual</code> (the default).</p>
<ul>
<li>We use <code>virtual</code> for functions we want writers of derived classes to be able to define or redefine.</li>
</ul>
<p>We base our choice on the meaning (semantics) of our class:</p>
<ul>
<li>Can we imagine the need for further derived classes?</li>
<li>Does a designer of a derived class need to redefine the function to achieve a plausible aim?</li>
<li>Is overriding a function error-prone (i.e., is it hard for an overriding function to provide the<br>expected semantics of a virtual function)?</li>
</ul>
<p>If the answer is ‘‘no’’ to all three questions, we can leave the function non-<code>virtual</code> to gain simplicity of design and occasionally some performance (mostly from inlining). </p>
<p>The standard library is full of examples of this.</p>
</li>
</ol>
<ol start="31">
<li><p>Far more rarely, we have a class hierarchy that starts out with virtual functions, but after the definition of a set of derived classes, one of the answers becomes ‘‘no.’’</p>
<ul>
<li><p>For example:</p>
<p>we can imagine an abstract syntax tree for a language where all language constructs have been defined as concrete node classes derived from a few interfaces. </p>
<p>We only need to derive a new class if we change the language. </p>
<p>In that case, we might want to prevent our users from overriding virtual functions because the only thing such overrides could do would be to change the semantics of our language. </p>
<p>That is, we might want to close our design to modification from its users.</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123; <span class="hljs-comment">// interface class</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Type <span class="hljs-title">type</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">If_statement</span> : <span class="hljs-keyword">public</span> Node &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Type <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// prevent further overriding</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>In a realistic class hierarchy, there would be several intermediate classes between the general interface (here, <code>Node</code>) and the derived class representing a specific language construct (here, <code>If_statement</code>).</p>
<ul>
<li>However, the key point about this example is that <code>Node::type()</code> is meant to be overridden (that’s why it’s declared <code>virtual</code>) and its overrider <code>If_statement::type()</code> is not (that’s why it’s declared <code>final</code>).</li>
</ul>
<p>After using <code>final</code> for a member function, it can no longer be overridden and an attempt to do so is an error.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Modified_if_statement</span> : <span class="hljs-keyword">public</span> If_statement &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Type <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// error : If_statement::type() is final</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="32">
<li><p>We can make every virtual member function of a class final; just add final after the class name.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">For_statement</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> Node &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Type <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Modified_for_statement</span> : <span class="hljs-keyword">public</span> For_statement &#123; <span class="hljs-comment">// error : For_statement is final</span><br>    <span class="hljs-function">Type <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>For good and bad, adding <code>final</code> to the class not only prevents overriding, it also prevents further derivation from a class. There are people who use final to try to gain performance – after all, a non-<code>virtual</code> function is faster than a <code>virtual</code> one (by maybe 25% on a modern implementation) and offers greater opportunities for inlining (§12.1.5).</p>
<ul>
<li>However, do not blindly use final as an optimization aid; it affects the class hierarchy design (often negatively), and the performance improvements are rarely significant.</li>
</ul>
<p>Do some serious measurements before claiming efficiency improvements.</p>
<p>Use <code>final</code> where it clearly reflects a class hierarchy design that you consider proper. </p>
<ul>
<li>That is, use <code>final</code> to reflect a semantic need.</li>
</ul>
</li>
</ol>
<ol start="33">
<li><p>A <code>final</code> specifier is not part of the type of a function and cannot be repeated in an out-of-class definition.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// OK if Base has a virtual f()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// OK if Base has a virtual g()</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Derived::f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> <span class="hljs-comment">// error : final out of class</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> <span class="hljs-comment">// OK</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Like <code>override</code> (§20.3.4.1), <code>final</code> is a contextual keyword. </p>
<p>That is, <code>final</code> has a special meaning in a few contexts but can be used as an ordinary identifier elsewhere.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> <span class="hljs-keyword">final</span> = <span class="hljs-number">7</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dx</span> : Base &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">final</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">final</span> + ::<span class="hljs-keyword">final</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Don’t indulge in such cleverness; it complicates maintenance.</p>
<ul>
<li>The only reason that <code>final</code> is a contextual keyword, rather than an ordinary keyword, is that there exist a significant amount of code that has used <code>final</code> as an ordinary identifier for decades. </li>
<li>The other contextual keyword is <code>override</code> (§20.3.4.1).</li>
</ul>
</li>
</ol>
<h4 id="20-3-5-using-Base-Members"><a href="#20-3-5-using-Base-Members" class="headerlink" title="20.3.5 using Base Members"></a>20.3.5 <code>using</code> Base Members</h4><ol start="34">
<li><p>Functions do not overload across scopes (§12.3.3). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">(Derived d)</span></span><br><span class="hljs-function"></span>&#123;<br>    d.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// call Derived::f(double)</span><br>    Base&amp; br = d<br>    br.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// call Base::f(int)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>This can surprise people, and sometimes we want overloading to ensure that the best matching member function is used.</p>
<p>As for namespaces, <code>using</code>-declarations can be used to add a function to a scope. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D2</span> : Base &#123;<br>    <span class="hljs-keyword">using</span> Base::f; <span class="hljs-comment">// bring all fs from Base into D2</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use2</span><span class="hljs-params">(D2 d)</span></span><br><span class="hljs-function"></span>&#123;<br>    d.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// call D2::f(int), that is, Base::f(int)</span><br>    Base&amp; br = d<br>    br.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// call Base::f(int)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>This is a simple consequence of a class also being considered a namespace (§16.2).</p>
</li>
</ul>
<p>Several <code>using</code>-declarations can bring in names from multiple base classes.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B1</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : B1, B2 &#123;<br>    <span class="hljs-keyword">using</span> B1::f; <span class="hljs-comment">// using</span><br>    <span class="hljs-keyword">using</span> B2::f; <span class="hljs-comment">// using</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">(D d)</span></span><br><span class="hljs-function"></span>&#123;<br>    d.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// call D::f(int), that is, B1::f(int)</span><br>    d.<span class="hljs-built_in">f</span>(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// call D::f(char)</span><br>    d.<span class="hljs-built_in">f</span>(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// call D::f(double), that is, B2::f(double)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="35">
<li><p>We can bring constructors into a derived class scope; see §20.3.5.1. </p>
<p>A name brought into a derived class scope by a <code>using</code>-declaration has its access determined by the placement of the <code>using</code>-declaration; see §20.5.3. </p>
<p>We cannot use <code>using</code>-directives to bring all members of a base class into a derived class.</p>
</li>
</ol>
<h5 id="20-3-5-1-Inheriting-Constructors"><a href="#20-3-5-1-Inheriting-Constructors" class="headerlink" title="20.3.5.1 Inheriting Constructors"></a>20.3.5.1 Inheriting Constructors</h5><ol start="36">
<li><p>Say I want a vector that’s just like <code>std::vector</code>, but with guaranteed range checking. I can try this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector</span> : std::vector&lt;T&gt; &#123;<br>    T&amp; <span class="hljs-keyword">operator</span>[](size_type i) &#123; <span class="hljs-built_in">check</span>(i); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>−&gt;<span class="hljs-built_in">elem</span>(i); &#125;<br>    <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>[](size_type i) <span class="hljs-type">const</span> &#123; <span class="hljs-built_in">check</span>(i); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>−&gt;<span class="hljs-built_in">elem</span>(i); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(siz e_type i)</span> </span>&#123; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>−&gt;<span class="hljs-built_in">size</span>()&lt;i) <span class="hljs-keyword">throw</span> rang e_error&#123;<span class="hljs-string">&quot;Vector::check() failed&quot;</span>&#125;; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Unfortunately, we would soon find out that this definition is rather incomplete.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Vector&lt;<span class="hljs-type">int</span>&gt; v &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span> &#125;; <span class="hljs-comment">// error : no initializer-list constructor</span><br></code></pre></td></tr></table></figure>

<p>A quick check will show that <code>Vector</code> failed to inherit any constructors from <code>std::vector</code>.</p>
</li>
</ul>
<p>That’s not an unreasonable rule: if a class adds data members to a base or requires a stricter class invariant, it would be a disaster to inherit constructors.</p>
<ul>
<li>However, <code>Vector</code> did not do anything like that.</li>
</ul>
<p>We solve the problem by simply saying that the constructors should be inherited:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector</span> : std::vector&lt;T&gt; &#123;<br>    <span class="hljs-keyword">using</span> vector&lt;T&gt;::vector; <span class="hljs-comment">// inherit constructors from std::vector</span><br>    T&amp; <span class="hljs-keyword">operator</span>=[](size_type i) &#123; <span class="hljs-built_in">check</span>(i); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>−&gt;<span class="hljs-built_in">elem</span>(i); &#125;<br>    <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>=(size_type i) <span class="hljs-type">const</span> &#123; <span class="hljs-built_in">check</span>(i); <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>−&gt;<span class="hljs-built_in">elem</span>(i); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(siz e_type i)</span> </span>&#123; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>−&gt;<span class="hljs-built_in">size</span>()&lt;i) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Bad_index</span>(i); &#125;<br>&#125;;<br><br>Vector&lt;<span class="hljs-type">int</span>&gt; v &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span> &#125;; <span class="hljs-comment">// OK: use initializer-list constructor from std::vector</span><br></code></pre></td></tr></table></figure>

<ul>
<li>This use of <code>using</code> is exactly equivalent to its use for ordinary functions (§14.4.5, §20.3.5).</li>
</ul>
<p>If you so choose, you can shoot yourself in the foot by inheriting constructors in a derived class in which you define new member variables needing explicit initialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B1</span> &#123;<br>    <span class="hljs-built_in">B1</span>(<span class="hljs-type">int</span>) &#123; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D1</span> : B1 &#123;<br>    <span class="hljs-keyword">using</span> B1::B1; <span class="hljs-comment">// implicitly declares D1(int)</span><br>    string s; <span class="hljs-comment">// string has a default constructor</span><br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// we &#x27;forgot&#x27; to provide for initialization of x (built-in type)</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D1 d &#123;<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// oops: d.x is not initialized</span><br>    D1 e; <span class="hljs-comment">// error : D1 has no default constructor</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The reason that <code>D1::s</code> is initialized and <code>D1::x</code> is not is that the inheriting constructor is equivalent to a constructor that simply initializes the base.</p>
</li>
<li><p>In this case, we might equivalently have written:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D1</span> : B1 &#123;<br>    <span class="hljs-built_in">D1</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">B1</span>(i) &#123; &#125;<br>    string s; <span class="hljs-comment">// string has a default constructor</span><br>    <span class="hljs-type">int</span> x; <span class="hljs-comment">// we &#x27;forgot&#x27; to provide for initialization of x</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>One way to remove the bullet from your foot is by adding an in-class member initializer (§17.4.4):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D1</span> : B1 &#123;<br>    <span class="hljs-keyword">using</span> B1::B1; <span class="hljs-comment">// implicitly declares D1(int)</span><br>    <span class="hljs-type">int</span> x &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// note: x is initialized</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D1 d &#123;<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// d.x is zero</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="37">
<li>Most often it is best to avoid being clever and restrict the use of inheriting constructors to the simple cases where no data members are added.</li>
</ol>
<h4 id="20-3-6-Return-Type-Relaxation"><a href="#20-3-6-Return-Type-Relaxation" class="headerlink" title="20.3.6 Return Type Relaxation"></a>20.3.6 Return Type Relaxation</h4><ol start="38">
<li><p>There is a relaxation of the rule that the type of an overriding function must be the same as the type of the virtual function it overrides. </p>
<p>That is, if the original return type was <code>B∗</code>, then the return type of the overriding function may be <code>D∗</code>, provided <code>B</code> is a public base of <code>D</code>. </p>
<p>Similarly, a return type of <code>B&amp;</code> may be relaxed to <code>D&amp;</code>. </p>
<p>This is sometimes called the <em><strong>covariant return</strong></em> rule.</p>
</li>
</ol>
<ol start="39">
<li><p><strong>This relaxation applies only to return types that are pointers or references</strong>, and not to ‘‘smart pointers’’ such as <code>unique_ptr</code> (§5.2.1). </p>
<p>In particular, there is not a similar relaxation of the rules for argument types because that would lead to type violations.</p>
</li>
</ol>
<ol start="40">
<li><p>Consider a class hierarchy representing different kinds of expressions. </p>
<p>In addition to the operations for manipulating expressions, the base class <code>Expr</code> would provide facilities for making new<br>expression objects of the various expression types:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Expr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Expr</span>(); <span class="hljs-comment">//default constructor</span><br>    <span class="hljs-built_in">Expr</span>(<span class="hljs-type">const</span> Expr&amp;); <span class="hljs-comment">// copy constructor</span><br>    <span class="hljs-keyword">virtual</span> Expr∗ <span class="hljs-built_in">new_expr</span>() =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> Expr∗ <span class="hljs-built_in">clone</span>() =<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The idea is that <code>new_expr()</code> makes a default object of the type of the expression and <code>clone()</code> makes a copy of the object. </p>
<p>Both will return an object of some specific class derived from <code>Expr</code>. </p>
<p>They can never just return a ‘‘plain <code>Expr</code>’’ because <code>Expr</code> was deliberately and appropriately declared to be an abstract class.</p>
</li>
</ul>
<p>A derived class can override <code>new_expr()</code> and/or <code>clone()</code> to return an object of its own type:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cond</span> : <span class="hljs-keyword">public</span> Expr &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cond</span>();<br>    <span class="hljs-built_in">Cond</span>(<span class="hljs-type">const</span> Cond&amp;);<br>    Cond∗ <span class="hljs-built_in">new_expr</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cond</span>(); &#125; <span class="hljs-comment">// override</span><br>    Cond∗ <span class="hljs-built_in">clone</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cond</span>(∗<span class="hljs-keyword">this</span>); &#125; <span class="hljs-comment">// override</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>This means that given an object of class <code>Expr</code>, a user can create a new object of ‘‘just the same type.’’ </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">(Expr∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    Expr∗ p2 = p−&gt;<span class="hljs-built_in">new_expr</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The pointer assigned to <code>p2</code> is declared to point to a ‘‘plain <code>Expr</code>,’’ but it will point to an object of a type derived from <code>Expr</code>, such as <code>Cond</code>.</li>
</ul>
</li>
</ul>
<p>The return type of <code>Cond::new_expr()</code> and <code>Cond::clone()</code> is <code>Cond∗</code> rather than <code>Expr∗</code>.</p>
<ul>
<li>This allows a <code>Cond</code> to be cloned without loss of type information.</li>
</ul>
<p>Similarly, a derived class <code>Addition</code> would have a <code>clone()</code> returning a <code>Addition∗</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user2</span><span class="hljs-params">(Cond∗ pc, Addition∗ pa)</span></span><br><span class="hljs-function"></span>&#123;<br>    Cond∗ p1 = pc−&gt;<span class="hljs-built_in">clone</span>(); <span class="hljs-comment">// Cond::clone() --&gt; returns a Cond*</span><br>    Addition∗ p2 = pa−&gt;<span class="hljs-built_in">clone</span>(); <span class="hljs-comment">// Addition::clone() --&gt; returns an Addtion*</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>If we use <code>clone()</code> for an <code>Expr</code> we only know that the result is an <code>Expr∗</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user3</span><span class="hljs-params">(Cond∗ pc, Expr∗ pe)</span></span><br><span class="hljs-function"></span>&#123;<br>    Cond∗ p1 = pc−&gt;<span class="hljs-built_in">clone</span>();<br>    Cond∗ p2 = pe−&gt;<span class="hljs-built_in">clone</span>(); <span class="hljs-comment">// error : Expr::clone() returns an Expr*, not a Cond*</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Because <strong>functions such as <code>new_expr()</code> and <code>clone()</code> are <code>virtual</code> and they (indirectly) construct objects</strong>, they are often called <em><strong>virtual constructors</strong></em>. </p>
<ul>
<li>Each simply uses a constructor to create a suitable object.</li>
</ul>
</li>
</ol>
<ol start="41">
<li><p>To make an object, a constructor needs the exact type of the object it is to create. </p>
<ul>
<li><p>Consequently, a constructor cannot be <code>virtual</code>. </p>
</li>
<li><p>Furthermore, a constructor is not quite an ordinary function. </p>
<p>In particular, it interacts with memory management routines in ways ordinary member functions don’t. </p>
</li>
</ul>
<p>So, you cannot take a pointer to a constructor and pass that to an object creation function.</p>
<p>Both of these restrictions can be circumvented by defining a function that calls a constructor and returns a constructed object. </p>
<ul>
<li>This is fortunate because creating a new object without knowing its exact type is often useful. </li>
<li>The <code>Ival_box_maker</code> (§21.2.4) is an example of a class designed specifically to do that.</li>
</ul>
</li>
</ol>
<h3 id="20-4-Abstract-Classes"><a href="#20-4-Abstract-Classes" class="headerlink" title="20.4 Abstract Classes"></a>20.4 Abstract Classes</h3><ol start="42">
<li>Many classes resemble class <code>Employee</code> in that they are useful as themselves, as interfaces for derived classes, and as part of the implementation of derived classes.<ul>
<li>For such classes, the techniques described in §20.3.2 suffice.</li>
</ul>
</li>
</ol>
<ol start="43">
<li><p>However, not all classes follow that pattern. </p>
<p>Some classes, such as a class <code>Shape</code>, represent abstract concepts for which objects cannot exist.</p>
<p>A <code>Shape</code> makes sense only as the base of some class derived from it. </p>
<ul>
<li><p>This can be seen from the fact that it is not possible to provide sensible definitions for its virtual functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; <span class="hljs-keyword">throw</span> runtime_error&#123;<span class="hljs-string">&quot;Shape::rotate&quot;</span>&#125;; &#125; <span class="hljs-comment">// inelegant</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">throw</span> runtime_error&#123;<span class="hljs-string">&quot;Shape::draw&quot;</span>&#125;; &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Trying to make a shape of this unspecified kind is silly but legal:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Shape s; <span class="hljs-comment">// silly: &#x27;shapeless shape&#x27;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>It is silly because every operation on <code>s</code> will result in an error.</li>
</ul>
<p>A better alternative is to declare the virtual functions of class <code>Shape</code> to be <em><strong>pure virtual functions</strong></em>.</p>
<p>A virtual function is ‘‘made pure’’ by the ‘‘pseudo initializer’’ <code>= 0</code>:</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123; <span class="hljs-comment">// abstract class</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Shape</span>(); <span class="hljs-comment">// virtual</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>A class with one or more pure virtual functions is an <em><strong>abstract class</strong></em>, and no objects of that abstract class can be created:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Shape s; <span class="hljs-comment">// error : variable of abstract class Shape(abstract class) cannot be created</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="44">
<li><p>An abstract class is intended as an interface to objects accessed through pointers and references (to preserve polymorphic behavior). </p>
<p>Consequently, <strong>it is usually important for an abstract class to have a virtual destructor</strong> (§3.2.4, §21.2.2). </p>
<p>Because the interface provided by an abstract class cannot be used to create objects using a constructor, abstract classes don’t usually have constructors.</p>
</li>
</ol>
<ol start="45">
<li><p>An abstract class can be used only as an interface to other classes. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>    <br>    <span class="hljs-built_in">Circle</span>(Point p, <span class="hljs-type">int</span> r);<br><span class="hljs-keyword">private</span>:<br>    Point center;<br>    <span class="hljs-type">int</span> radius;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="46">
<li><p>A pure virtual function that is not defined in a derived class remains a pure virtual function, so the derived class is also an abstract class. </p>
<p>This allows us to build implementations in stages:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Polygon</span> : <span class="hljs-keyword">public</span> Shape &#123; <span class="hljs-comment">// Polygon is also abstract class</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>    <span class="hljs-comment">// ... draw and rotate not overridden ...</span><br>&#125;;<br><br>Polygon b &#123;p1,p2,p3,p4&#125;; <span class="hljs-comment">// error : declaration of object of abstract class Polygon</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>Polygon is still abstract because we did not override <code>draw()</code> and <code>rotate()</code>. </p>
<p>Only when that is done do we have a class from which we can create objects:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Irregular_polygon</span> : <span class="hljs-keyword">public</span> Polygon &#123;<br>    list&lt;Point&gt; lp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Irregular_polygon</span>(initializ er_list&lt;Point&gt;);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br>Irregular_polygon poly &#123;p1,p2,p3,p4&#125;; <span class="hljs-comment">// assume that p1 .. p4 are Points defined somewhere</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="47">
<li><p>An abstract class provides an interface without exposing implementation details. </p>
<ul>
<li><p>For example, an operating system might hide the details of its device drivers behind an abstract class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Character_device</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">int</span> opt)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> opt)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span>∗ p, <span class="hljs-type">int</span> n)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ p, <span class="hljs-type">int</span> n)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> ...)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//device I/O control</span><br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Character_device</span>() &#123; &#125; <span class="hljs-comment">// vir tual destr uctor</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>We can then specify drivers as classes derived from <code>Character_device</code> and manipulate a variety of drivers through that interface.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="48">
<li>The design style supported by abstract classes is called <em><strong>interface inheritance</strong></em> in contrast to the <em><strong>implementation inheritance</strong></em> supported by base classes with state and/or defined member functions.<br>Combinations of the two approaches are possible. <ul>
<li>That is, we can define and use base classes with both state and pure virtual functions. </li>
<li>However, such mixtures of approaches can be confusing and require extra care.</li>
</ul>
</li>
</ol>
<ol start="49">
<li>With the introduction of abstract classes, we have the basic facilities for writing a complete program in a modular fashion using classes as building blocks.</li>
</ol>
<h3 id="20-5-Access-Control"><a href="#20-5-Access-Control" class="headerlink" title="20.5 Access Control"></a>20.5 Access Control</h3><ol start="50">
<li><p>A member of a class can be <code>private</code>, <code>protected</code>, or <code>public</code>:</p>
<ul>
<li>If it is <code>private</code>, its name can be used only by member functions and friends of the class in which it is declared.</li>
<li>If it is <code>protected</code>, its name can be used only by member functions and friends of the class in which it is declared and by member functions and friends of classes derived from this class (see §19.4).</li>
<li>If it is <code>public</code>, its name can be used by any function.</li>
</ul>
<p>This reflects the view that there are three kinds of functions accessing a class: </p>
<ul>
<li>functions implementing the class (its friends and members), </li>
<li>functions implementing a derived class (the derived class’s friends and members), and</li>
<li>other functions. </li>
</ul>
<p>This can be presented graphically:</p>
<p><img src="image-20230204203640537.png" srcset="/img/loading.gif" lazyload alt="image-20230204203640537"></p>
</li>
</ol>
<ol start="51">
<li><p>The access control is applied uniformly to names. </p>
<ul>
<li>What a name refers to does not affect the control of its use. </li>
</ul>
<p>This means that we can have <code>private</code> member functions, types, constants, etc., as well as <code>private</code> data members. </p>
<ul>
<li><p>For example, an efficient nonintrusive list class often requires data structures to keep track of elements. </p>
<ul>
<li>A list is <em><strong>nonintrusive</strong></em> if it does not require modification to its elements (e.g., by requiring element types to have link fields). </li>
</ul>
<p>The information and data structures used to organize the list can be kept private:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Link</span> &#123; T val; Link∗ next; &#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span> &#123;<br>        <span class="hljs-keyword">enum</span> &#123; chunk_siz e = <span class="hljs-number">15</span> &#125;;<br>        Link v[chunk_siz e];<br>        Chunk∗ next;<br>    &#125;;<br>    <br>    Chunk∗ allocated;<br>    Link∗ free;<br>    Link∗ <span class="hljs-built_in">get_free</span>();<br>    Link∗ head;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>The definitions of the public functions are pretty strainghtforward:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> List&lt;T&gt;::<span class="hljs-built_in">insert</span>(T val)<br>&#123;<br>    Link∗ lnk = <span class="hljs-built_in">get_free</span>();<br>    lnk−&gt;val = val;<br>    lnk−&gt;next = head;<br>    head = lnk;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T List&lt;T&gt;::<span class="hljs-built_in">get</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> Underflow&#123;&#125;; <span class="hljs-comment">// Underflow is my exception class</span><br>    Link∗ p= head;<br>    head = p−&gt;next;<br>    p−&gt;next = free;<br>    free = p;<br>    <span class="hljs-keyword">return</span> p−&gt;val;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>As is common, the definition of the supporting (here, private) functions are a bit more tricky:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">typename</span> List&lt;T&gt;::Link∗ List&lt;T&gt;::<span class="hljs-built_in">get_free</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (free == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// ... allocate a new chunk and place its Links on the free list ...</span><br>    &#125;<br>    Link∗ p = free;<br>    free = free−&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The <code>List&lt;T&gt;</code> scope is entered by saying <code>List&lt;T&gt;::</code> in a member function definition. </p>
</li>
<li><p>However, because the return type of <code>get_free()</code> (i.e., <code>Link*</code>) is mentioned before the name <code>List&lt;T&gt;::get_free()</code> is mentioned, the full name <code>List&lt;T&gt;::Link</code> must be used instead of the abbreviation Link. </p>
<p>The alternative is to use the suffix notation for return types (§12.1.4):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">auto</span> List&lt;T&gt;::<span class="hljs-built_in">get_free</span>() −&gt; Link∗<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Nonmember functions (except friends) do not have such access:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">would_be_meddler</span><span class="hljs-params">(List&lt;T&gt;∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    List&lt;T&gt;::Link∗ q = <span class="hljs-number">0</span>; <span class="hljs-comment">// error: List&lt;T&gt;::Link is private</span><br>    <span class="hljs-comment">// ...</span><br>    q = p−&gt;free; <span class="hljs-comment">//error : List&lt;T&gt;::free is private</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (List&lt;T&gt;::Chunk::chunk_siz e &gt; <span class="hljs-number">31</span>) &#123; <span class="hljs-comment">// error : List&lt;T&gt;::Chunk::chunk_size is private</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>In a <code>class</code>, members are by default <code>private</code>; in a <code>struct</code>, members are by default <code>public</code></strong> (§16.2.4).</p>
<p>The obvious alternative to using a member type is to place the type in the surrounding namespace.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Link2</span> &#123;<br>    T val;<br>    Link2∗ next;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Link2&lt;T&gt;∗ free;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p><code>Link</code> is implicitly parameterized with <code>List&lt;T&gt;</code>’s parameter <code>T</code>. </p>
<p>For <code>Link2</code>, we must make that explicit.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="52">
<li>If a member type does not depend on all the template class’s parameters, the nonmember version can be preferable; see §23.4.6.3.</li>
</ol>
<ol start="53">
<li><p>If the nested class is not generally useful by itself and the enclosing class needs access to its representation, declaring the member class a <code>friend</code> (§19.4.2) may be a good idea:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Link3</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&lt;T&gt;; <span class="hljs-comment">// only List&lt;T&gt; can access Link3&lt;T&gt;</span><br>    T val;<br>    Link3∗ next;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>    Link3&lt;T&gt;∗ free;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="54">
<li><p>A compiler may reorder sections of a class with separate access specifiers (§8.2.6). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m1;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m2;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The compiler may decide for <code>m2</code> to precede <code>m1</code> in the layout of an <code>S</code> object. </li>
</ul>
</li>
</ul>
<p>Such reordering could come as a surprise to the programmer and is implementation-dependent, so don’t use multiple access specifiers for data members without good reason.</p>
</li>
</ol>
<h4 id="20-5-1-protected-Members"><a href="#20-5-1-protected-Members" class="headerlink" title="20.5.1 protected Members"></a>20.5.1 <code>protected</code> Members</h4><ol start="55">
<li><p>When designing a class hierarchy, we sometimes provide functions designed to be used by implementers of derived classes but not by the general user. </p>
<ul>
<li><p>For example, we may provide an (efficient) unchecked access function for derived class implementers and (safe) checked access for others.</p>
<ul>
<li><p>Declaring the unchecked version protected achieves that.</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i); <span class="hljs-comment">// checked access</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>; <span class="hljs-comment">// unchecked access</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circular_buffer</span> : <span class="hljs-keyword">public</span> Buffer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reallocate</span><span class="hljs-params">(<span class="hljs-type">char</span>∗ p, <span class="hljs-type">int</span> s)</span></span>; <span class="hljs-comment">// change location and size</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Circular_buffer::reallocate</span><span class="hljs-params">(<span class="hljs-type">char</span>∗ p, <span class="hljs-type">int</span> s)</span><span class="hljs-comment">// change location and size</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i!=old_sz; ++i)<br>        p[i] = <span class="hljs-built_in">access</span>(i); <span class="hljs-comment">// no redundant checking</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Buffer&amp; b)</span> <span class="hljs-comment">// other functions cannot access the protected</span></span><br><span class="hljs-function"></span>&#123;<br>    b[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;b&#x27;</span>; <span class="hljs-comment">// OK (checked)</span><br>    b.<span class="hljs-built_in">access</span>(<span class="hljs-number">3</span>) = <span class="hljs-string">&#x27;c&#x27;</span>; <span class="hljs-comment">// error: Buffer ::access() is protected</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>For another example, see <code>Window_with_border</code> in §21.3.5.2.</p>
</li>
</ul>
</li>
</ol>
<ol start="56">
<li><p>A derived class can access a base class’s protected members only for objects of its own type:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">128</span>];<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Linked_buffer</span> : <span class="hljs-keyword">public</span> Buffer &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circular_buffer</span> : <span class="hljs-keyword">public</span> Buffer &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Linked_buffer∗ p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// OK: access to Circular_buffer’s own protected member</span><br>        p−&gt;a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// error : access to protected member of different type (i.e., Linked_buffer)</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>This prevents subtle errors that would otherwise occur when one derived class corrupts data belonging to other derived classes.</p>
</li>
</ol>
<h5 id="20-5-1-1-Use-of-protected-Members"><a href="#20-5-1-1-Use-of-protected-Members" class="headerlink" title="20.5.1.1 Use of protected Members"></a>20.5.1.1 Use of <code>protected</code> Members</h5><ol start="57">
<li><p>The simple private/public model of data hiding serves the notion of concrete types (§16.3) well. </p>
<p>However, when derived classes are used, there are two kinds of users of a class: </p>
<ul>
<li>derived classes and </li>
<li>‘‘the general public.’’ </li>
</ul>
<p>The members and friends that implement the operations on the class operate on the class objects on behalf of these users. </p>
<p>The private/public model allows the programmer to distinguish clearly between the implementers and the general public, but it does not provide a way of catering specifically to derived classes.</p>
</li>
</ol>
<ol start="58">
<li><p>Members declared <code>protected</code> are far more open to abuse than members declared private. </p>
<ul>
<li>In particular, declaring data members protected is usually a design error. </li>
</ul>
<p>Placing significant amounts of data in a common class for all derived classes to use leaves that data open to corruption. Worse, protected data, like public data, cannot easily be restructured because there is no good way of finding every use. Thus, protected data becomes a software maintenance problem.</p>
</li>
</ol>
<ol start="59">
<li><p>Fortunately, you don’t hav e to use protected data; <code>private</code> is the default in classes and is usually the better choice. </p>
<p>In my experience, there have always been alternatives to placing significant amounts of information in a common base class for derived classes to use directly.</p>
<p>However, none of these objections are significant for protected member functions; <code>protected</code> is a fine way of specifying operations for use in derived classes. </p>
<ul>
<li><p>The <code>Ival_slider</code> in §21.2.2 is an example of this. </p>
<p>Had the implementation class been private in this example, further derivation would have been infeasible. </p>
</li>
</ul>
<p>On the other hand, making bases providing implementation details public invites mistakes and misuse.</p>
</li>
</ol>
<h4 id="20-5-2-Access-to-Base-Classes"><a href="#20-5-2-Access-to-Base-Classes" class="headerlink" title="20.5.2 Access to Base Classes"></a>20.5.2 Access to Base Classes</h4><ol start="60">
<li><p>Like a member, a base class can be declared <code>private</code>, <code>protected</code>, or <code>public</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> : <span class="hljs-keyword">public</span> B &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span> : <span class="hljs-keyword">protected</span> B &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span> : <span class="hljs-keyword">private</span> B &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>The different access specifiers serve different design needs</strong>:</p>
<ul>
<li><p><code>public</code> derivation makes <strong>the derived class a subtype of its base</strong>. </p>
<ul>
<li>For example, <code>X</code> is a kind of <code>B</code>. </li>
</ul>
<p>This is the most common form of derivation.</p>
</li>
<li><p><code>private</code> bases are most useful when defining a class by restricting the interface to a base so that stronger guarantees can be provided. </p>
<ul>
<li>For example, <code>B</code> is <strong>an implementation detail of</strong> <code>Z</code>.</li>
<li>The <code>Vector</code> of pointers template that adds type checking to its <code>Vector&lt;void∗&gt;</code> base from §25.3 is a good example.</li>
</ul>
</li>
<li><p><code>protected</code> bases are useful in class hierarchies in which <strong>further derivation is the norm</strong>. </p>
<p>Like <code>private</code> derivation, <code>protected</code> derivation is used to represent <strong>implementation details</strong>. </p>
<ul>
<li>The <code>Ival_slider</code> from §21.2.2 is a good example.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="61">
<li><p>The access specifier for a base class can be left out.</p>
<p>In that case, the base defaults to a private base for a <code>class</code> and a <code>public</code> base for a struct. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">XX</span> : B &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// B is a private base</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">YY</span> : B &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// B is a public base</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>People expect base classes to be public (that is, to express a subtype relationship), so the absence of an access specifier for a base is likely to be surprising for a <code>class</code> but not for a <code>struct</code>.</p>
</li>
</ol>
<ol start="62">
<li><p>The access specifier for a base class controls the access to members of the base class and the conversion of pointers and references from the derived class type to the base class type.</p>
<p>Consider a class <code>D</code> derived from a base class <code>B</code>:</p>
<ul>
<li><p>If <code>B</code> is a <code>private</code> base, its public and protected members can be used only by member functions and friends of <code>D</code>. </p>
<p>Only friends and members of <code>D</code> can convert a <code>D∗</code> to a <code>B∗</code>.</p>
</li>
<li><p>If <code>B</code> is a <code>protected</code> base, its public and protected members can be used only by member functions and friends of <code>D</code> and by member functions and friends of classes derived from <code>D</code>. </p>
<p>Only friends and members of <code>D</code> and friends and members of classes derived from <code>D</code> can convert a <code>D∗</code> to a <code>B∗</code>.</p>
</li>
<li><p>If <code>B</code> is a <code>public</code> base, its public members can be used by any function. </p>
<p>In addition, its protected members can be used by members and friends of <code>D</code> and members and friends of classes derived from <code>D</code>. </p>
<p>Any function can convert a <code>D∗</code> to a <code>B∗</code>.</p>
</li>
</ul>
<p>This basically restates the rules for member access (§20.5). </p>
<p>When designing a class, we choose access for bases in the same way as we do for members. </p>
<ul>
<li>For an example, see <code>Ival_slider</code> in §21.2.2.</li>
</ul>
</li>
</ol>
<h5 id="20-5-2-1-Multiple-Inheritance-and-Access-Control"><a href="#20-5-2-1-Multiple-Inheritance-and-Access-Control" class="headerlink" title="20.5.2.1 Multiple Inheritance and Access Control"></a>20.5.2.1 Multiple Inheritance and Access Control</h5><ol start="63">
<li><p>If the name of a base class can be reached through multiple paths in a multiple-inheritance lattice (§21.3), it is accessible if it is accessible through any path. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> sm;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> B &#123; <span class="hljs-comment">/* ... */</span> &#125; ;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D2</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> B &#123; <span class="hljs-comment">/* ... */</span> &#125; ;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D12</span> : <span class="hljs-keyword">public</span> D1, <span class="hljs-keyword">private</span> D2 &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br>D12∗ pd = <span class="hljs-keyword">new</span> D12;<br>B∗ pb = pd; <span class="hljs-comment">// OK: accessible through D1</span><br><span class="hljs-type">int</span> i1 = pd−&gt;m; <span class="hljs-comment">// OK: accessible through D1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>If a single entity is reachable through several paths, we can still refer to it without ambiguity.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X1</span> : <span class="hljs-keyword">public</span> B &#123; <span class="hljs-comment">/* ... */</span> &#125; ;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X2</span> : <span class="hljs-keyword">public</span> B &#123; <span class="hljs-comment">/* ... */</span> &#125; ;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XX</span> : <span class="hljs-keyword">public</span> X1, <span class="hljs-keyword">public</span> X2 &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br>XX∗ pxx = <span class="hljs-keyword">new</span> XX;<br><span class="hljs-type">int</span> i1 = pxx−&gt;m; <span class="hljs-comment">// error, ambiguous: XX::X1::B::m or XX::X2::B::m?</span><br><span class="hljs-type">int</span> i2 = pxx−&gt;sm; <span class="hljs-comment">// OK: there is only one B::sm in an XX (sm is a static member)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="20-5-3-using-Declarations-and-Access-Control"><a href="#20-5-3-using-Declarations-and-Access-Control" class="headerlink" title="20.5.3 using-Declarations and Access Control"></a>20.5.3 <code>using</code>-Declarations and Access Control</h4><ol start="64">
<li><p>A <code>using</code>-declaration (§14.2.2, §20.3.5) cannot be used to gain access to additional information. </p>
<p>It is simply a mechanism for making accessible information more convenient to use. </p>
<p>On the other hand, once access is available, it can be granted to other users. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> B::a; <span class="hljs-comment">// error: B::a is private</span><br>    <span class="hljs-keyword">using</span> B::b; <span class="hljs-comment">// make B::b publicly available through D</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>When a <code>using</code>-declaration is combined with private or protected derivation, it can be used to specify interfaces to some, but not all, of the facilities usually offered by a class.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span> : <span class="hljs-keyword">private</span> B &#123; <span class="hljs-comment">// give access to B::b and B::c, but not B::a (a is private of B)</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> B::b;<br>    <span class="hljs-keyword">using</span> B::c;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>See also §20.3.5.</p>
</li>
</ul>
</li>
</ol>
<h3 id="20-6-Pointers-to-Members"><a href="#20-6-Pointers-to-Members" class="headerlink" title="20.6 Pointers to Members"></a>20.6 Pointers to Members</h3><ol start="66">
<li><p>A pointer to member is an offset-like construct that allows a programmer to indirectly refer to a member of a class. </p>
<p>The operators <code>−&gt;∗</code> and <code>.∗</code> are arguably the most specialized and least used C++ operators. </p>
<ul>
<li><p>Using <code>−&gt;</code>, we can access a member of a class, <code>m</code>, by naming it: <code>p−&gt;m</code>. </p>
</li>
<li><p>Using <code>−&gt;∗</code>, we can access a member that (conceptually) has its name stored in a pointer to member, <code>ptom</code>: <code>p−&gt;∗ptom</code>. </p>
<p>That is<code>p-&gt;(*ptom)</code>.</p>
</li>
</ul>
<p>This allows us to access members with their names passed as arguments. </p>
<p>In both cases, <code>p</code> must be a pointer to an object of an appropriate class.</p>
</li>
</ol>
<ol start="67">
<li><p>A pointer to member cannot be assigned to a <code>void∗</code> or any other ordinary pointer. </p>
<p>A null pointer (e.g., <code>nullptr</code>) can be assigned to a pointer to member and then represents ‘‘no member.’’</p>
</li>
</ol>
<h4 id="20-6-1-Pointers-to-Function-Members"><a href="#20-6-1-Pointers-to-Function-Members" class="headerlink" title="20.6.1 Pointers to Function Members"></a>20.6.1 Pointers to Function Members</h4><ol start="68">
<li><p>Many classes provide simple, very general interfaces intended to be invoked in several different ways. </p>
<ul>
<li>For example, many ‘‘object-oriented’’ user interfaces define a set of requests to which every object represented on the screen should be prepared to respond. </li>
</ul>
<p>In addition, such requests can be presented directly or indirectly from programs. </p>
<p>Consider a simple variant of this idea:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Std_interface</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">quit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">full_size</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">small</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Std_interface</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>The exact meaning of each operation is defined by the object on which it is invoked. </p>
<p>Often, there is a layer of software between the person or program issuing the request and the object receiving it.</p>
<ul>
<li><p>Ideally, such intermediate layers of software should not have to know anything about the individual operations such as <code>resume()</code> and <code>full_size()</code>. </p>
</li>
<li><p>If they did, the intermediate layers would have to be updated each time an operation changed. </p>
</li>
</ul>
<p>Consequently, such intermediate layers simply transmit data representing the operation to be invoked from the source of the request to its recipient.</p>
<p>One simple way of doing that is to send a <code>string</code> representing the operation to be invoked. </p>
<ul>
<li><p>For example, to invoke <code>suspend()</code> we could send the string <code>&quot;suspend&quot;</code>. </p>
</li>
<li><p>However, someone has to create that string and someone has to decode it to determine to which operation it corresponds – if any.</p>
</li>
<li><p>Often, that seems indirect and tedious. </p>
</li>
</ul>
<p>Instead, we might simply send an integer representing the operation. </p>
<ul>
<li><p>For example, <code>2</code> might be used to mean <code>suspend()</code>. </p>
</li>
<li><p>However, while an integer may be convenient for machines to deal with, it can get pretty obscure for people. </p>
</li>
<li><p>We still have to write code to determine that <code>2</code> means <code>suspend()</code> and to invoke <code>suspend()</code>.</p>
</li>
</ul>
</li>
</ol>
<ol start="69">
<li><p>However, we can use a pointer to member to indirectly refer to a member of a class. </p>
<p>Consider <code>Std_interface</code>. </p>
<ul>
<li>If I want to invoke <code>suspend()</code> for some object without mentioning <code>suspend()</code> directly, I need a pointer to member referring to <code>Std_interface::suspend()</code>. </li>
</ul>
<p>I also need a pointer or reference to the object I want to suspend. </p>
<ul>
<li><p>Consider a trivial example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> Pstd_mem = <span class="hljs-built_in">void</span> (Std_interface::∗)(); <span class="hljs-comment">// pointer-to-member type</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Std_interface∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    Pstd_mem s = &amp;Std_interface::suspend; <span class="hljs-comment">// pointer to suspend()</span><br>    p−&gt;<span class="hljs-built_in">suspend</span>(); <span class="hljs-comment">// direct call</span><br>    p−&gt;∗<span class="hljs-built_in">s</span>(); <span class="hljs-comment">// call through pointer to member</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>A pointer to member can be obtained by applying the address-of operator, <code>&amp;</code>, to a fully qualified class member name.</p>
<ul>
<li>For example, <code>&amp;Std_interface::suspend</code>. </li>
</ul>
<p>A variable of type ‘‘pointer to member of class X’’ is declared using a declarator of the form <code>X::∗</code>.</p>
<ul>
<li><p>For example, <code>Std_interface::∗</code>.</p>
</li>
<li><p>The use of an alias to compensate for the lack of readability of the C declarator syntax is typical.</p>
</li>
<li><p>However, please note how the <code>X::∗</code> declarator matches the traditional <code>∗</code> declarator exactly.</p>
</li>
</ul>
</li>
</ol>
<ol start="70">
<li><p>A pointer to member <code>m</code> can be used in combination with an object. </p>
<p>The operators <code>−&gt;∗</code> and <code>.∗</code> allow the programmer to express such combinations. </p>
<ul>
<li>For example, <code>p−&gt;∗m</code> binds <code>m</code> to the object pointed to by p, and <code>obj.∗m</code> binds <code>m</code> to the object <code>obj</code>. </li>
</ul>
<p>The result can be used in accordance with <code>m</code>’s type. </p>
<p>It is not possible to store the result of a <code>−&gt;∗</code> or a <code>.∗</code> operation for later use.</p>
</li>
</ol>
<ol start="71">
<li><p>Naturally, if we knew which member we wanted to call, we would invoke it directly rather than mess with pointers to members. </p>
<p>Just like ordinary pointers to functions, <strong>pointers to member functions are used when we need to refer to a function without having to know its name</strong>. </p>
<p>However, a pointer to member isn’t a pointer to a piece of memory the way a pointer to a variable or a pointer to a function is. </p>
<ul>
<li>It is more like an offset into a structure or an index into an array, but of course an implementation takes into account the differences between data members, virtual functions, nonvirtual functions, etc. </li>
</ul>
<p>When a pointer to member is combined with a pointer to an object of the right type, it yields something that identifies a particular member of a particular object.</p>
</li>
</ol>
<ol start="72">
<li><p>The <code>p−&gt;∗s()</code> call can be represented graphically like this:</p>
<p><img src="image-20230205142817901.png" srcset="/img/loading.gif" lazyload alt="image-20230205142817901"></p>
<p>Because a pointer to a virtual member (<code>s</code> in this example) is a kind of offset, it does not depend on an object’s location in memory. </p>
<p>A pointer to a virtual member can therefore be passed between different address spaces as long as the same object layout is used in both. </p>
<p>Like pointers to ordinary functions, pointers to non-virtual member functions cannot be exchanged between address spaces.</p>
</li>
</ol>
<ol start="73">
<li><p>Note that the function invoked through the pointer to function can be <code>virtual</code>. </p>
<ul>
<li>For example, when we call <code>suspend()</code> through a pointer to function, we get the right <code>suspend()</code> for the object to which the pointer to function is applied. </li>
</ul>
<p>This is an essential aspect of pointers to functions.</p>
<p>When writing an interpreter, we might use pointers to members to invoke functions presented as strings:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string,Std_interface∗&gt; variable;<br>map&lt;string,Pstd_mem&gt; operation;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_member</span><span class="hljs-params">(string var, string oper)</span></span><br><span class="hljs-function"></span>&#123;<br>    (variable[var]−&gt;∗operation[oper])(); <span class="hljs-comment">// var.oper()</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="74">
<li><p>A <code>static</code> member isn’t associated with a particular object, so a pointer to a static member is simply an ordinary pointer. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-built_in">void</span> (∗p)() = &amp;Task::schedule; <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">void</span> (Task::∗ pm)() = &amp;Task::schedule; <span class="hljs-comment">// error : ordinary pointer (&amp;Task::schedule) assigned</span><br>									   <span class="hljs-comment">// to pointer to member (Task::* pm)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="20-6-2-Pointers-to-Data-Members"><a href="#20-6-2-Pointers-to-Data-Members" class="headerlink" title="20.6.2 Pointers to Data Members"></a>20.6.2 Pointers to Data Members</h4><ol start="75">
<li><p>Naturally, the notion of pointer to member applies to data members and to member functions with arguments and return types. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ val;<br>    <span class="hljs-type">int</span> i;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; cout &lt;&lt; val &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ v) &#123; val = v; &#125;<br>&#125;;<br><br><span class="hljs-keyword">using</span> Pmfi = <span class="hljs-built_in">void</span> (C::∗)(<span class="hljs-type">int</span>); <span class="hljs-comment">// pointer to member function of C taking an int</span><br><span class="hljs-keyword">using</span> Pm = <span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ C::∗; <span class="hljs-comment">//pointer to char* data member of C</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(C&amp; z1, C&amp; z2)</span></span><br><span class="hljs-function"></span>&#123;<br>    C∗ p = &amp;z2;<br>    Pmfi pf = &amp;C::print;<br>    Pm pm = &amp;C::val;<br>    <br>    z1.<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>);<br>    (z1.∗pf)(<span class="hljs-number">2</span>);<br>    z1.∗pm = <span class="hljs-string">&quot;nv1 &quot;</span>;<br>    p−&gt;∗pm = <span class="hljs-string">&quot;nv2 &quot;</span>;<br>    z2.<span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>);<br>    (p−&gt;∗pf)(<span class="hljs-number">4</span>);<br>    <br>    pf = &amp;C::f1; <span class="hljs-comment">// error : return type mismatch</span><br>    pf = &amp;C::f2; <span class="hljs-comment">// error : argument type mismatch</span><br>    pm = &amp;C::i; <span class="hljs-comment">// error : type mismatch</span><br>    pm = pf; <span class="hljs-comment">// error : type mismatch</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The type of a pointer to function is checked just like any other type.</p>
</li>
</ul>
</li>
</ol>
<h4 id="20-6-3-Base-and-Derived-Members"><a href="#20-6-3-Base-and-Derived-Members" class="headerlink" title="20.6.3 Base and Derived Members"></a>20.6.3 Base and Derived Members</h4><ol start="76">
<li><p>A derived class has at least the members that it inherits from its base classes. </p>
<ul>
<li>Often it has more. </li>
</ul>
<p>This implies that we can safely assign a pointer to a member of a base class to a pointer to a member of a derived class, but not the other way around. </p>
<p>This property is often called <em><strong>contravariance</strong></em>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Text</span> : <span class="hljs-keyword">public</span> Std_interface &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    vector s;<br>&#125;;<br><br><span class="hljs-built_in">void</span> (Std_interface::∗ pmi)() = &amp;Text::print; <span class="hljs-comment">// error (derived --&gt; base)</span><br><span class="hljs-built_in">void</span> (Text::∗pmt)() = &amp;Std_interface::start; <span class="hljs-comment">// OK (base --&gt; derived)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>This contravariance rule appears to be the opposite of the rule that says we can assign a pointer to a derived class to a pointer to its base class.</p>
<p>In fact, both rules exist to preserve the fundamental guarantee that a pointer may never point to an object that doesn’t at least have the properties that the pointer promises.</p>
<ul>
<li>In this case, <code>Std_interface::∗</code> can be applied to any <code>Std_interface</code>, and most such objects presumably are not of type <code>Text</code>. </li>
<li>Consequently, they do not have the member <code>Text::print</code> with which we tried to initialize <code>pmi</code>. </li>
<li>By refusing the initialization, the compiler saves us from a run-time error.</li>
</ul>
</li>
</ol>
<h3 id="20-7-Advice"><a href="#20-7-Advice" class="headerlink" title="20.7 Advice"></a>20.7 Advice</h3><p>[1] Avoid type fields; §20.3.1.<br>[2] Access polymorphic objects through pointers and references; §20.3.2.<br>[3] Use abstract classes to focus design on the provision of clean interfaces; §20.4.<br>[4] Use <code>override</code> to make overriding explicit in large class hierarchies; §20.3.4.1.<br>[5] Use <code>final</code> only sparingly; §20.3.4.2.<br>[6] Use abstract classes to specify interfaces; §20.4.<br>[7] Use abstract classes to keep implementation details out of interfaces; §20.4.<br>[8] A class with a virtual function should have a virtual destructor; §20.4.<br>[9] An abstract class typically doesn’t need a constructor; §20.4.<br>[10] Prefer <code>private</code> members for implementation details; §20.5.<br>[11] Prefer <code>public</code> members for interfaces; §20.5.<br>[12] Use <code>protected</code> members only carefully when really needed; §20.5.1.1.<br>[13] Don’t declare data members <code>protected</code>; §20.5.1.1.</p>
<h2 id="Chapter-21-Class-Hierarchies"><a href="#Chapter-21-Class-Hierarchies" class="headerlink" title="Chapter 21.Class Hierarchies"></a>Chapter 21.Class Hierarchies</h2><ul>
<li>Introduction</li>
<li>Design of Class Hierarchies<ul>
<li>Implementation Inheritance</li>
<li>Interface Inheritance</li>
<li>Alternative Implementations</li>
<li>Localizing Object Creation</li>
</ul>
</li>
<li>Multiple Interitance<ul>
<li>Multiple Interfaces</li>
<li>Multiple Implementation Classes</li>
<li>Ambiguity Resolution</li>
<li>Repeated Use of Base Class</li>
<li>Virtual Base Classes</li>
<li>Replicated vs. Virtual Bases</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="21-1-Introduction"><a href="#21-1-Introduction" class="headerlink" title="21.1 Introduction"></a>21.1 Introduction</h3><ol>
<li><p>The primary focus of this chapter is <strong>design techniques</strong>, rather than language features. </p>
<ul>
<li><p>The examples are taken from user-interface design, but I avoid the topic of event-driven programming as commonly used for graphical user interface (GUI) systems. </p>
<ul>
<li>A discussion of exactly how an action on the screen is transformed into a call of a member function would add little to the issues of class hierarchy design and has a huge potential for distraction: it is an interesting and important topic in its own right. </li>
</ul>
</li>
<li><p>For an understanding of GUI, have a look at one of the many C++ GUI libraries.</p>
</li>
</ul>
</li>
</ol>
<h3 id="21-2-Design-of-Class-Hierarchies"><a href="#21-2-Design-of-Class-Hierarchies" class="headerlink" title="21.2 Design of Class Hierarchies"></a>21.2 Design of Class Hierarchies</h3><ol start="2">
<li><p>Consider a simple design problem: Provide a way for a program (‘‘an application’’) to get an integer value from a user. </p>
<ul>
<li>This can be done in a bewildering number of ways. </li>
</ul>
<p>To insulate our program from this variety, and also to get a chance to explore the possible design choices, let us start by defining our program’s model of this simple input operation.</p>
<ul>
<li><p>The idea is to have a class <code>Ival_box</code> (‘‘integer value input box’’) that knows what range of input values it will accept. </p>
<p>A program can ask an <code>Ival_box</code> for its value and ask it to prompt the user if necessary. </p>
<p>In addition, a program can ask an <code>Ival_box</code> if a user changed the value since the program last looked at it:</p>
<p><img src="image-20230206131551001.png" srcset="/img/loading.gif" lazyload alt="image-20230206131551001"></p>
</li>
<li><p>Because there are many ways of implementing this basic idea, we must assume that there will be many different kinds of <code>Ival_box</code>es, such as sliders, plain boxes in which a user can type a number, dials, and voice interaction.</p>
</li>
</ul>
<p>The general approach is to build a ‘‘virtual user-interface system’’ for the application to use.</p>
<ul>
<li><p>This system provides some of the services provided by existing user-interface systems. </p>
</li>
<li><p>It can be implemented on a wide variety of systems to ensure the portability of application code. </p>
</li>
</ul>
<p>Naturally, there are other ways of insulating an application from a user-interface system. </p>
<ul>
<li>I chose this approach because it is general, because it allows me to demonstrate a variety of techniques and design tradeoffs, because those techniques are also the ones used to build ‘‘real’’ user-interface systems, and – most important – because these techniques are applicable to problems far beyond the narrow domain of interface systems.</li>
</ul>
<p>In addition to ignoring the topic of how to map user actions (events) to library calls, I also ignore the need for locking in a multi-threaded GUI system.</p>
</li>
</ol>
<h4 id="21-2-1-Implementation-Inheritance"><a href="#21-2-1-Implementation-Inheritance" class="headerlink" title="21.2.1 Implementation Inheritance"></a>21.2.1 Implementation Inheritance</h4><ol start="3">
<li><p>Our first solution is a class hierarchy using implementation inheritance (as is commonly found in older programs).</p>
<p>Class <code>Ival_box</code> defines the basic interface to all <code>Ival_box</code>es and specifies a default implementation that more specific kinds of <code>Ival_box</code>es can override with their own versions. </p>
<p>In addition, we declare the data needed to implement the basic notion:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> &#123;<br><span class="hljs-keyword">protected</span>: <span class="hljs-comment">// data members of Ival_box were declared protected to allow access from derived class</span><br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-type">int</span> low, high;<br>    <span class="hljs-type">bool</span> changed &#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// changed by user using set_value()</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Ival_box</span>(<span class="hljs-type">int</span> ll, <span class="hljs-type">int</span> hh) :val&#123;ll&#125;, low&#123;ll&#125;, high&#123;hh&#125; &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> </span>&#123; changed = <span class="hljs-literal">false</span>; <span class="hljs-keyword">return</span> val; &#125; <span class="hljs-comment">// for application</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; changed = <span class="hljs-literal">true</span>; val = i; &#125; <span class="hljs-comment">// for user</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">reset_value</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; changed = <span class="hljs-literal">false</span>; val = i; &#125; <span class="hljs-comment">// for application</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">prompt</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">was_changed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> changed; &#125;<br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Ival_box</span>() &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The default implementation of the functions is pretty sloppy and is provided here primarily to illustrate the intended semantics. </li>
<li>A realistic class would, for example, provide some range checking.</li>
</ul>
<p>A programmer might use these ‘‘ival classes’’ like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">interact</span><span class="hljs-params">(Ival_box∗ pb)</span></span><br><span class="hljs-function"></span>&#123;<br>    pb−&gt;<span class="hljs-built_in">prompt</span>(); <span class="hljs-comment">// alert user</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">int</span> i = pb−&gt;<span class="hljs-built_in">get_value</span>();<br>    <span class="hljs-keyword">if</span> (pb−&gt;<span class="hljs-built_in">was_changed</span>()) &#123;<br>        <span class="hljs-comment">// ... new value; do something ...</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ... do something else ...</span><br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">some_fct</span>()<br>&#123;<br>    unique_ptr&lt;Ival_box&gt; p1 &#123;<span class="hljs-keyword">new</span> Ival_slider&#123;<span class="hljs-number">0</span>,<span class="hljs-number">5</span>&#125;&#125;; <span class="hljs-comment">// Ival_slider derived from Ival_box</span><br>    <span class="hljs-built_in">interact</span>(p1.<span class="hljs-built_in">get</span>());<br>    unique_ptr&lt;Ival_box&gt; p2 &#123;<span class="hljs-keyword">new</span> Ival_dial&#123;<span class="hljs-number">1</span>,<span class="hljs-number">12</span>&#125;&#125;;  <span class="hljs-comment">// Ival_dial derived from Ival_box</span><br>    <span class="hljs-built_in">interact</span>(p2.<span class="hljs-built_in">get</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Most application code is written in terms of (pointers to) plain <code>Ival_box</code>es the way <code>interact()</code> is. </p>
<ul>
<li><p>That way, the application doesn’t have to know about the potentially large number of variants of the <code>Ival_box</code> concept. </p>
</li>
<li><p>The knowledge of such specialized classes is isolated in the relatively few functions that create such objects. </p>
</li>
<li><p>This isolates users from changes in the implementations of the derived classes. </p>
</li>
</ul>
<p>Most code can be oblivious to the fact that there are different kinds of <code>Ival_box</code>es.</p>
<p><strong>I use <code>unique_ptr</code> (§5.2.1, §34.3.1) to avoid forgetting to <code>delete</code> the <code>ival_box</code>es.</strong></p>
<p>To simplify the discussion, I do not address issues of how a program waits for input. </p>
<ul>
<li>Maybe the program really does wait for the user in <code>get_value()</code> (e.g., using a <code>get()</code> on a <code>future</code>; §5.3.5.1), </li>
<li>maybe the program associates the <code>Ival_box</code> with an event and prepares to respond to a callback, or </li>
<li>maybe the program spawns a thread for the <code>Ival_box</code> and later inquires about the state of that thread. </li>
</ul>
<p>Such decisions are crucial in the design of user-interface systems. </p>
<p>However, discussing them here in any realistic detail would simply distract from the presentation of programming techniques and language facilities. </p>
<p>The design techniques described here and the language facilities that support them are not specific to user interfaces. </p>
<ul>
<li>They apply to a far greater range of problems.</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>The different kinds of <code>Ival_boxe</code>s are defined as classes derived from <code>Ival_box</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span> : <span class="hljs-keyword">public</span> Ival_box &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// ... graphics stuff to define what the slider looks like, etc. ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Ival_slider</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// get value from user and deposit it in val</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prompt</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;    <br></code></pre></td></tr></table></figure>

<ul>
<li><p>The data members of <code>Ival_box</code> were declared <code>protected</code> to allow access from derived classes. </p>
<ul>
<li><p>Thus, <code>Ival_slider::get_value()</code> can deposit a value in <code>Ival_box::val</code>. </p>
</li>
<li><p>A protected member is accessible from a class’s own members and from members of derived classes, but not to general users (see §20.5).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In addition to <code>Ival_slider</code>, we would define other variants of the <code>Ival_box</code> concept. </p>
<ul>
<li><p>These could include <code>Ival_dial</code>, which lets you select a value by turning a knob; </p>
</li>
<li><p><code>Flashing_ival_slider</code>, which flashes when you ask it to <code>prompt()</code>; </p>
</li>
<li><p>and <code>Popup_ival_slider</code>, which responds to <code>prompt()</code> by appearing in some prominent place, thus making it hard for the user to ignore.</p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>From where would we get the graphics stuff? </p>
<p>Most user-interface systems provide a class defining the basic properties of being an entity on the screen. </p>
<ul>
<li><p>So, if we use the system from ‘‘Big Bucks Inc.,’’ we would have to make each of our <code>Ival_slider</code>, <code>Ival_dial</code>, etc., classes a kind of <code>BBwidget</code>.</p>
<ul>
<li><p>This would most simply be achieved by rewriting our <code>Ival_box</code> so that it derives from <code>BBwidget</code>.</p>
</li>
<li><p>In that way, all our classes inherit all the properties of a <code>BBwidget</code>. </p>
</li>
<li><p>For example, every <code>Ival_box</code> can be placed on the screen, obey the graphical style rules, be resized, be dragged around, etc., according to the standard set by the <code>BBwidget</code> system. </p>
</li>
</ul>
</li>
</ul>
<p>Our class hierarchy would look like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> : <span class="hljs-keyword">public</span> BBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// rewritten to use BBwidget</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span> : <span class="hljs-keyword">public</span> Ival_box &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_dial</span> : <span class="hljs-keyword">public</span> Ival_box &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flashing_ival_slider</span> : <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Popup_ival_slider</span> : <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206140620903.png" srcset="/img/loading.gif" lazyload alt="image-20230206140620903"></p>
</li>
</ol>
<h5 id="21-2-1-1-Critique"><a href="#21-2-1-1-Critique" class="headerlink" title="21.2.1.1 Critique"></a>21.2.1.1 Critique</h5><ol start="4">
<li><p>This design works well in many ways, and for many problems this kind of hierarchy is a good solution.<br>However, there are some awkward details that could lead us to look for alternative designs.</p>
<ul>
<li><p>We retrofitted <code>BBwidget</code> as the base of <code>Ival_box</code>. </p>
<ul>
<li>This is not quite right (even if this style is common in real-world systems). </li>
</ul>
<p>The use of <code>BBwidget</code> isn’t part of our basic notion of an <code>Ival_box</code>; it is an implementation detail. </p>
<p>Deriving <code>Ival_box</code> from <code>BBwidget</code> elevated an implementation detail to a first-level design decision. </p>
<ul>
<li>That can be right. <ul>
<li>For example, using the environment defined by ‘‘Big Bucks Inc.’’ may be a key decision based on how our organization conducts its business. </li>
</ul>
</li>
</ul>
<p>However, what if we also wanted to have implementations of our <code>Ival_box</code>es for systems from ‘‘Imperial Bananas,’’ ‘‘Liberated Software,’’ and ‘‘Compiler Whizzes’’? </p>
<ul>
<li><p>We would have to maintain four distinct versions of our program:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> : <span class="hljs-keyword">public</span> BBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// BB version</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> : <span class="hljs-keyword">public</span> CWwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// CW version</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> : <span class="hljs-keyword">public</span> IBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// IB version</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> : <span class="hljs-keyword">public</span> LSwindow &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// LS version</span><br></code></pre></td></tr></table></figure></li>
<li><p>Having many versions could result in a version control nightmare.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>In reality, we are unlikely to find a simple, coherent, two-letter prefix scheme. </p>
<ul>
<li>More likely, the libraries from different purveyors would be in different namespaces and use different terminologies for similar concepts, such as <code>BigBucks::Widget</code>, <code>Wizzies::control</code>, and <code>LS::window</code>. </li>
</ul>
<p>But that does not affect our class hierarchy design discussion, so to simplify I ignore naming and namespace issues.</p>
</li>
</ol>
<ol start="6">
<li><p>Another problem is that every derived class shares the basic data declared in <code>Ival_box</code>. </p>
<ul>
<li>That data is, of course, an implementation detail that also crept into our <code>Ival_box</code> interface. </li>
</ul>
<p>From a practical point of view, it is also the wrong data in many cases. </p>
<ul>
<li><p>For example, an <code>Ival_slider</code> doesn’t need the value stored specifically. </p>
<p>It can easily be calculated from the position of the slider when someone executes <code>get_value()</code>. </p>
</li>
</ul>
<p><strong>In general, keeping two related, but different, sets of data is asking for trouble</strong>.</p>
<ul>
<li>Sooner or later someone will get them out of sync. </li>
</ul>
<p>Also, experience shows that novice programmers tend to mess with protected data in ways that are unnecessary and that cause maintenance problems. </p>
<ul>
<li><p>Data members are better kept private so that writers of derived classes cannot mess with them. </p>
</li>
<li><p>Better still, data should be in the derived classes, where it can be defined to match requirements exactly and cannot complicate the life of unrelated derived classes. </p>
</li>
</ul>
<p>In almost all cases, a protected interface should contain only functions, types, and constants.</p>
</li>
</ol>
<ol start="7">
<li>Deriving from <code>BBwidget</code> gives the benefit of making the facilities provided by <code>BBwidget</code> available to users of <code>Ival_box</code>. Unfortunately, it also means that changes to class <code>BBwidget</code> may force users to recompile or even rewrite their code to recover from such changes. <ul>
<li>In particular, the way most C++ implementations work implies that a change in the size of a base class requires a recompilation of all derived classes.</li>
</ul>
</li>
</ol>
<ol start="8">
<li><p>Finally, our program may have to run in a mixed environment in which windows of different user-interface systems coexist. </p>
<ul>
<li>This could happen either because two systems somehow share a screen or because our program needs to communicate with users on different systems. </li>
</ul>
<p>Having our user-interface systems ‘‘wired in’’ as the one and only base of our one and only <code>Ival_box</code> interface just isn’t flexible enough to handle those situations.</p>
</li>
</ol>
<h4 id="21-2-2-Interface-Inheritance"><a href="#21-2-2-Interface-Inheritance" class="headerlink" title="21.2.2 Interface Inheritance"></a>21.2.2 Interface Inheritance</h4><ol start="9">
<li><p>So, let’s start again and build a new class hierarchy that solves the problems presented in the critique of the traditional hierarchy:</p>
<ul>
<li><p>The user-interface system should be an implementation detail that is hidden from users who don’t want to know about it.</p>
</li>
<li><p>The <code>Ival_box</code> class should contain no data.</p>
</li>
<li><p>No recompilation of code using the <code>Ival_box</code> family of classes should be required after a change of the user-interface system.</p>
</li>
<li><p><code>Ival_box</code>es for different interface systems should be able to coexist in our program.</p>
</li>
</ul>
</li>
</ol>
<ol start="10">
<li><p>Several alternative approaches can be taken to achieve this. </p>
<p>Here, I present one that maps cleanly into the C++ language.</p>
<p>First, <strong>I specify class <code>Ival_box</code> as a pure interface</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">reset_value</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">prompt</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">was_changed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Ival_box</span>() &#123; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This is much cleaner than the original declaration of <code>Ival_box</code>. <ul>
<li>The data is gone and so are the simplistic implementations of the member functions. </li>
<li>Gone, too, is the constructor, since there is no data for it to initialize. </li>
<li>Instead, I added a virtual destructor to ensure proper cleanup of the data that will be defined in the derived classes.</li>
</ul>
</li>
</ul>
<p>The definition of <code>Ival_slider</code> might look like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span> : <span class="hljs-keyword">public</span> Ival_box, <span class="hljs-keyword">protected</span> BBwidget &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Ival_slider</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>); <span class="hljs-comment">// constructor</span><br>    ˜<span class="hljs-built_in">Ival_slider</span>() <span class="hljs-keyword">override</span>; <span class="hljs-comment">// destructor</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// ... functions overriding BBwidget virtual functions</span><br>    <span class="hljs-comment">// e.g., BBwidget::draw(), BBwidget::mouse1hit() ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// ... data needed for slider ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The derived class <code>Ival_slider</code> inherits from an abstract class (<code>Ival_box</code>) that requires it to implement the base class’s pure virtual functions. </p>
<p>It also inherits from <code>BBwidget</code> which provides it with the means of doing so. </p>
</li>
<li><p>Since <code>Ival_box</code> provides the interface for the derived class, it is derived using <code>public</code>. </p>
<p>Since <code>BBwidget</code> is only an implementation aid, it is derived using <code>protected</code> (§20.5.2). </p>
<ul>
<li>This implies that a programmer using <code>Ival_slider</code> cannot directly use facilities defined by <code>BBwidget</code>. </li>
</ul>
</li>
<li><p>The interface provided by <code>Ival_slider</code> is the one inherited from <code>Ival_box</code>, plus what <code>Ival_slider</code> explicitly declares. </p>
</li>
<li><p>I used <code>protected</code> derivation instead of the more restrictive (and usually safer) <code>private</code> derivation to make <code>BBwidget</code> available to classes derived from <code>Ival_slider</code>. </p>
</li>
<li><p>I used explicit <code>override</code> because this ‘‘widget hierarchy’’ is exactly the kind of large, complicated hierachy where being<br>explicit can help minimize confusion.</p>
</li>
</ul>
</li>
</ol>
<ol start="11">
<li><p>Deriving directly from more than one class is usually called <em><strong>multiple inheritance</strong></em> (§21.3). </p>
<p>Note that <code>Ival_slider</code> must override functions from both <code>Ival_box</code> and <code>BBwidget</code>. </p>
<p>Therefore, it must be derived directly or indirectly from both. </p>
<ul>
<li>As shown in §21.2.1.1, deriving <code>Ival_slider</code> indirectly from <code>BBwidget</code> by making <code>BBwidget</code> a base of <code>Ival_box</code> is possible, but doing so has undesirable side effects. </li>
</ul>
<p>Similarly, making the ‘‘implementation class’’ <code>BBwidget</code> a member of <code>Ival_box</code> is not a solution because a class cannot override virtual functions of its members. </p>
<ul>
<li>Representing the window by a <code>BBwidget∗</code> member in <code>Ival_box</code> leads to a completely different design with a separate set of tradeoffs.</li>
</ul>
</li>
</ol>
<ol start="12">
<li><p>To some people, the words ‘‘multiple inheritance’’ indicate something complicated and scary.<br>However, <strong>the use of one base class for implementation details and another for interface (the abstract class) is common to all languages supporting inheritance and compile-time checked interfaces</strong>. </p>
<ul>
<li>In particular, the use of the abstract class <code>Ival_box</code> is almost identical to the use of an interface in Java or C#.</li>
</ul>
<p>Interestingly, this declaration of <code>Ival_slider</code> allows application code to be written exactly as before. </p>
<ul>
<li>All we have done is to restructure the implementation details in a more logical way.</li>
</ul>
<p>Many classes require some form of cleanup for an object before it goes away. </p>
<p>Since the abstract class <code>Ival_box</code> cannot know if a derived class requires such cleanup, it must assume that it does require some. </p>
<p>We ensure proper cleanup by defining a virtual destructor <code>Ival_box::˜Ival_box()</code> in the base and overriding it suitably in derived classes. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Ival_box∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>delete</code> operator explicitly destroys the object pointed to by <code>p</code>. <ul>
<li>We have no way of knowing exactly to which class the object pointed to by <code>p</code> belongs, but thanks to <code>Ival_box</code>’s virtual destructor, proper cleanup as (optionally) defined by that class’ destructor will be done.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="13">
<li><p>The <code>Ival_box</code> hierarchy can now be defined like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_box, <span class="hljs-keyword">protected</span> BBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_dial</span><br>    : <span class="hljs-keyword">public</span> Ival_box, <span class="hljs-keyword">protected</span> BBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flashing_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Popup_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206155452129.png" srcset="/img/loading.gif" lazyload alt="image-20230206155452129"></p>
<ul>
<li>I used a dashed line to represent protected inheritance (§20.5.1). </li>
<li>General users cannot access the protected bases because they are (correctly) considered part of the implementation.</li>
</ul>
</li>
</ol>
<h4 id="21-2-3-Alternative-Implementations"><a href="#21-2-3-Alternative-Implementations" class="headerlink" title="21.2.3 Alternative Implementations"></a>21.2.3 Alternative Implementations</h4><ol start="14">
<li><p>This design is cleaner and more easily maintainable than the traditional one – and no less efficient.<br>However, it still fails to solve the version control problem:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// common</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_box, <span class="hljs-keyword">protected</span> BBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// for BB</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_box, <span class="hljs-keyword">protected</span> CWwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// for CW</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<ul>
<li>There is no way of having the <code>Ival_slider</code> for <code>BBwidgets</code> coexist with the <code>Ival_slider</code> for <code>CWwidgets</code>, even if the two user-interface systems could themselves coexist. </li>
</ul>
<p>The obvious solution is to define several different <code>Ival_slider</code> classes with separate names:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_box, <span class="hljs-keyword">protected</span> BBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CW_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_box, <span class="hljs-keyword">protected</span> CWwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206160024996.png" srcset="/img/loading.gif" lazyload alt="image-20230206160024996"></p>
<p>To further insulate our application-oriented <code>Ival_box</code> classes from implementation details, we can derive an abstract <code>Ival_slider</code> class from <code>Ival_box</code> and then derive the system-specific <code>Ival_sliders</code> from that:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_box &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> BBwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CW_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> CWwidget &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206160253304.png" srcset="/img/loading.gif" lazyload alt="image-20230206160253304"></p>
<p>Usually, we can do better yet by utilizing more specific classes in the implementation hierarchy.</p>
<p>For example, if the ‘‘Big Bucks Inc.’’ system has a slider class, we can derive our <code>Ival_slider</code> directly from the <code>BBslider</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> BBslider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CW_ival_slider</span><br>: <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> CWslider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206160538008.png" srcset="/img/loading.gif" lazyload alt="image-20230206160538008"></p>
<ul>
<li><p>This improvement becomes significant where – as is not uncommon – our abstractions are not too different from the ones provided by the system used for implementation. </p>
<ul>
<li><p>In that case, programming is reduced to mapping between similar concepts. </p>
</li>
<li><p>Derivation from general base classes, such as <code>BBwidget</code>, is then done only rarely.</p>
</li>
</ul>
</li>
</ul>
<p>The complete hierarchy will consist of our original application-oriented conceptual hierarchy of interfaces expressed as derived classes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_box</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_box &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_dial</span><br>    : <span class="hljs-keyword">public</span> Ival_box &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flashing_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Popup_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>followed by the implementations of this hierarchy for various graphical user interface systems, expressed as derived classes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> BBslider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_flashing_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Flashing_ival_slider, <span class="hljs-keyword">protected</span> BBwidget_with_bells_and_whistles &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_popup_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Popup_ival_slider, <span class="hljs-keyword">protected</span> BBslider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CW_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> CWslider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>Using obvious abbreviations, this hierarchy can be represented graphically like this:</p>
<p><img src="image-20230206161206795.png" srcset="/img/loading.gif" lazyload alt="image-20230206161206795"></p>
<p>The original <code>Ival_box</code> class hierarchy appears unchanged surrounded by implementation classes.</p>
<h5 id="21-2-3-1-Critique"><a href="#21-2-3-1-Critique" class="headerlink" title="21.2.3.1 Critique"></a>21.2.3.1 Critique</h5><ol start="15">
<li><p><strong>The abstract class design</strong> is flexible and almost as simple to deal with as the equivalent <strong>design that relies on a common base</strong> defining the user-interface system. </p>
<ul>
<li><p>In the latter design, the windows class is the root of a tree. </p>
</li>
<li><p>In the former, the original application class hierarchy appears unchanged as the root of classes that supply its implementations. </p>
</li>
</ul>
<p>From the application’s point of view, these designs are equivalent in the strong sense that almost all code works unchanged and in the same way in the two cases. </p>
<p>In either case, you can look at the <code>Ival_box</code> family of classes without bothering with the window-related implementation details most of the time. </p>
<ul>
<li>For example, we would not need to rewrite <code>interact()</code> from §21.2.1 if we switched from one class hierarchy to the other.</li>
</ul>
<p>In either case, the implementation of each <code>Ival_box</code> class must be rewritten when the public interface of the user-interface system changes. </p>
<p>However, in the abstract class design, almost all user code is protected against changes to the implementation hierarchy and requires no recompilation after such a change. </p>
<ul>
<li>This is especially important when the supplier of the implementation hierarchy issues a new ‘‘almost compatible’’ release. </li>
</ul>
<p>In addition, users of the abstract class hierarchy are in less danger of being locked into a proprietary implementation than are users of a classical hierarchy. </p>
<ul>
<li>Users of the <code>Ival_box</code> abstract class application hierarchy cannot accidentally use facilities from the implementation because only facilities explicitly specified in the <code>Ival_box</code> hierarchy are accessible; </li>
<li>nothing is implicitly inherited from an implementation-specific base class.</li>
</ul>
</li>
</ol>
<ol start="16">
<li><p>The logical conclusion of this line of thought is a system represented to users as a hierarchy of abstract classes and implemented by a classical hierarchy. </p>
<p>In other words:</p>
<ul>
<li>Use abstract classes to support interface inheritance (§3.2.3, §20.1).</li>
<li>Use base classes with implementations of virtual functions to support implementation inheritance (§3.2.3, §20.1).</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="21-2-3-1-Critique-1"><a href="#21-2-3-1-Critique-1" class="headerlink" title="21.2.3.1 Critique"></a>21.2.3.1 Critique</h5><ol start="15">
<li><p><strong>The abstract class design</strong> is flexible and almost as simple to deal with as the equivalent <strong>design that relies on a common base</strong> defining the user-interface system. </p>
<ul>
<li><p>In the latter design, the windows class is the root of a tree. </p>
</li>
<li><p>In the former, the original application class hierarchy appears unchanged as the root of classes that supply its implementations. </p>
</li>
</ul>
<p>From the application’s point of view, these designs are equivalent in the strong sense that almost all code works unchanged and in the same way in the two cases. </p>
<p>In either case, you can look at the <code>Ival_box</code> family of classes without bothering with the window-related implementation details most of the time. </p>
<ul>
<li>For example, we would not need to rewrite <code>interact()</code> from §21.2.1 if we switched from one class hierarchy to the other.</li>
</ul>
<p>In either case, the implementation of each <code>Ival_box</code> class must be rewritten when the public interface of the user-interface system changes. </p>
<p>However, in the abstract class design, almost all user code is protected against changes to the implementation hierarchy and requires no recompilation after such a change. </p>
<ul>
<li>This is especially important when the supplier of the implementation hierarchy issues a new ‘‘almost compatible’’ release. </li>
</ul>
<p>In addition, users of the abstract class hierarchy are in less danger of being locked into a proprietary implementation than are users of a classical hierarchy. </p>
<ul>
<li>Users of the <code>Ival_box</code> abstract class application hierarchy cannot accidentally use facilities from the implementation because only facilities explicitly specified in the <code>Ival_box</code> hierarchy are accessible; </li>
<li>nothing is implicitly inherited from an implementation-specific base class.</li>
</ul>
</li>
</ol>
<ol start="16">
<li><p>The logical conclusion of this line of thought is a system represented to users as a hierarchy of abstract classes and implemented by a classical hierarchy. </p>
<p>In other words:</p>
<ul>
<li>Use abstract classes to support interface inheritance (§3.2.3, §20.1).</li>
<li>Use base classes with implementations of virtual functions to support implementation inheritance (§3.2.3, §20.1).</li>
</ul>
</li>
</ol>
<h4 id="21-2-4-Localizing-Object-Creation"><a href="#21-2-4-Localizing-Object-Creation" class="headerlink" title="21.2.4 Localizing Object Creation"></a>21.2.4 Localizing Object Creation</h4><ol start="17">
<li><p>Most of an application can be written using the <code>Ival_box</code> interface. </p>
<ul>
<li><p>Further, should the derived interfaces evolve to provide more facilities than plain <code>Ival_box</code>, then most of an application can be written using the <code>Ival_box</code>, <code>Ival_slider</code>, etc., interfaces. </p>
</li>
<li><p>However, the creation of objects must be done using implementation-specific names such as <code>CW_ival_dial</code> and <code>BB_flashing_ival_slider</code>. </p>
</li>
</ul>
<p>We would like to minimize the number of places where such specific names occur, and object creation is hard to localize unless it is done systematically.</p>
<p>As usual, the solution is to introduce an indirection. </p>
<ul>
<li><p>This can be done in many ways. </p>
</li>
<li><p>A simple one is to introduce an abstract class to represent the set of creation operations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ival_maker</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> Ival_dial∗ <span class="hljs-built_in">dial</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) =<span class="hljs-number">0</span>; <span class="hljs-comment">// make dial</span><br>    <span class="hljs-keyword">virtual</span> Popup_ival_slider∗ <span class="hljs-built_in">popup_slider</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) =<span class="hljs-number">0</span>; <span class="hljs-comment">// make popup slider</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>For each interface from the <code>Ival_box</code> family of classes that a user should know about, class <code>Ival_maker</code> provides a function that makes an object. </p>
<p>Such a class is sometimes called a <em><strong>factory</strong></em>, and its functions are (somewhat misleadingly) sometimes called <em><strong>virtual constructors</strong></em> (§20.3.6).</p>
</li>
</ol>
<ol start="18">
<li><p>We now represent each user-interface system by a class derived from <code>Ival_maker</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_maker</span> : <span class="hljs-keyword">public</span> Ival_maker &#123; <span class="hljs-comment">// make BB versions</span><br>    <span class="hljs-keyword">public</span>:<br>    Ival_dial∗ <span class="hljs-built_in">dial</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) <span class="hljs-keyword">override</span>;<br>    Popup_ival_slider∗ <span class="hljs-built_in">popup_slider</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) <span class="hljs-keyword">override</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LS_maker</span> : <span class="hljs-keyword">public</span> Ival_maker &#123; <span class="hljs-comment">// make LS versions</span><br>    <span class="hljs-keyword">public</span>:<br>    Ival_dial∗ <span class="hljs-built_in">dial</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) <span class="hljs-keyword">override</span>;<br>    Popup_ival_slider∗ <span class="hljs-built_in">popup_slider</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) <span class="hljs-keyword">override</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Each function creates an object of the desired interface and implementation type. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">Ival_dial∗ BB_maker::<span class="hljs-built_in">dial</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BB_ival_dial</span>(a,b);<br>&#125;<br><br>Ival_dial∗ LS_maker::<span class="hljs-built_in">dial</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LS_ival_dial</span>(a,b);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="19">
<li><p>Given an <code>Ival_maker</code>, a user can now create objects without having to know exactly which user-interface system is used. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">(Ival_maker&amp; im)</span></span><br><span class="hljs-function"></span>&#123;<br>    unique_ptr&lt;Ival_box&gt; pb &#123;im.<span class="hljs-built_in">dial</span>(<span class="hljs-number">0</span>,<span class="hljs-number">99</span>)&#125;; <span class="hljs-comment">// create appropriate dial</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>BB_maker BB_impl; <span class="hljs-comment">// for BB users</span><br>LS_maker LS_impl; <span class="hljs-comment">// for LS users</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">driver</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">user</span>(BB_impl); <span class="hljs-comment">// use BB</span><br>    <span class="hljs-built_in">user</span>(LS_impl); <span class="hljs-comment">// use LS</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Passing arguments to such ‘‘virtual constructors’’ is a bit tricky. </p>
<ul>
<li><p>In particular, we cannot override the base class functions that represent the interface with different arguments in different derived classes. </p>
</li>
<li><p>This implies that a fair bit of foresight is required to design the factory class’s interface.</p>
</li>
</ul>
</li>
</ol>
<h3 id="21-3-Multiple-Inheritance"><a href="#21-3-Multiple-Inheritance" class="headerlink" title="21.3 Multiple Inheritance"></a>21.3 Multiple Inheritance</h3><ol start="20">
<li><p>As described in §20.1, inheritance aims to provide one of two benefits:</p>
<ul>
<li><p><em><strong>Shared interfaces</strong></em>: </p>
<ul>
<li><p>leading to less replication of code using classes and making such code more uniform. </p>
</li>
<li><p>This is often called <em><strong>run-time polymorphism</strong></em> or <em><strong>interface inheritance</strong></em>.</p>
</li>
</ul>
</li>
<li><p><em><strong>Shared implementation</strong></em>: </p>
<ul>
<li><p>leading to less code and more uniform implementation code. </p>
</li>
<li><p>This is often called <em><strong>implementation inheritance</strong></em>.</p>
</li>
</ul>
</li>
</ul>
<p>A class can combine aspects of these two styles.</p>
</li>
</ol>
<ol start="21">
<li>Here, we explore more general uses of multiple base classes and examine more technical issues related to combining and accessing features from multiple base classes.</li>
</ol>
<h4 id="21-3-1-Multiple-Interfaces"><a href="#21-3-1-Multiple-Interfaces" class="headerlink" title="21.3.1 Multiple Interfaces"></a>21.3.1 Multiple Interfaces</h4><ol start="22">
<li><p>An abstract class (e.g., <code>Ival_box</code>; §21.2.2) is the obvious way to represent an interface. </p>
<ul>
<li><p>For an abstract class without mutable state, there really is little difference between single and multiple uses of a base class in a class hierarchy. </p>
</li>
<li><p>The resolution of potential ambiguities is discussed in §21.3.3, §21.3.4, and §21.3.5. </p>
</li>
<li><p>In fact, any class without mutable state can be used as an interface in a multiple-inheritance lattice without significant complications and overhead. </p>
</li>
<li><p>The key observation is that a class without mutable state can be replicated if necessary or shared if that is desired.</p>
</li>
</ul>
</li>
</ol>
<ol start="23">
<li>The use of multiple abstract classes as interfaces is almost universal in object-oriented designs (in any language with a notion of an interface).</li>
</ol>
<h4 id="21-3-2-Multiple-Implementation-Classes"><a href="#21-3-2-Multiple-Implementation-Classes" class="headerlink" title="21.3.2 Multiple Implementation Classes"></a>21.3.2 Multiple Implementation Classes</h4><ol start="24">
<li><p>Consider a simulation of bodies orbiting the Earth in which orbiting objects are represented as object of class <code>Satellite</code>. </p>
<ul>
<li><p>A Satellite object would contain orbital, size, shape, albedo, density parameters, etc., and provide operations for orbital calculations, modifying attributes, etc. </p>
</li>
<li><p>Examples of satellites would be rocks, debris from old space vehicles, communication satellites, and the International Space Station. </p>
</li>
</ul>
<p>These kinds of satellites would be objects of classes derived from Satellite. </p>
<ul>
<li>Such derived classes would add data members and functions and would override some of Satellite’s virtual functions to adjust their meaning suitably.</li>
</ul>
</li>
</ol>
<ol start="25">
<li><p>Now assume that I want to display the results of these simulations graphically and that I had available a graphics system that used the (not uncommon) strategy of deriving objects to be displayed from a common base class holding graphical information. </p>
<ul>
<li><p>This graphics class would provide operations for placement on the screen, scaling, etc. </p>
</li>
<li><p>For generality, simplicity, and to hide the details of the actual graphics system, I will refer to the class providing graphical (or in fact alternatively nongraphical) output <code>Display</code>.</p>
</li>
</ul>
</li>
</ol>
<ol start="26">
<li><p>We can now define a class of simulated communication satellites, class <code>Comm_sat</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comm_sat</span> : <span class="hljs-keyword">public</span> Satellite, <span class="hljs-keyword">public</span> Displayed &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206183745502.png" srcset="/img/loading.gif" lazyload alt="image-20230206183745502"></p>
<p>In addition to whatever operations are defined specifically for a <code>Comm_sat</code>, the union of operations on <code>Satellite</code> and <code>Displayed</code> can be applied.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Comm_sat&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>    s.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">//Displayed::draw()</span><br>    Pos p = s.<span class="hljs-built_in">center</span>(); <span class="hljs-comment">// Satellite::center()</span><br>    s.<span class="hljs-built_in">transmit</span>(); <span class="hljs-comment">// Comm_sat::transmit()</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Similarly, a <code>Comm_sat</code> can be passed to a function that expects a <code>Satellite</code> and to a function that expects <code>Displayed</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">highlight</span><span class="hljs-params">(Displayed∗)</span></span>;<br><br><span class="hljs-function">Pos <span class="hljs-title">center_of_gravity</span><span class="hljs-params">(<span class="hljs-type">const</span> Satellite∗)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Comm_sat∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">highlight</span>(p); <span class="hljs-comment">//pass a pointer to the Displayed par t of the Comm_sat</span><br>    Pos x = <span class="hljs-built_in">center_of_gravity</span>(p); <span class="hljs-comment">// pass a pointer to the Satellite part of the Comm_sat</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The implementation of this clearly involves some (simple) compiler technique to ensure that functions expecting a <code>Satellite</code> see a different part of a <code>Comm_sat</code> than do functions expecting a <code>Displayed</code>.</p>
</li>
</ul>
<p>Virtual functions work as usual. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Satellite</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Pos <span class="hljs-title">center</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// center of gravity</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Displayed</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comm_sat</span> : <span class="hljs-keyword">public</span> Satellite, <span class="hljs-keyword">public</span> Displayed &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Pos <span class="hljs-title">center</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// override Satellite::center()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// override Displayed::draw()</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This ensures that <code>comm_sat::center()</code> and <code>Displayed::draw()</code> will be called for a <code>Comm_sat</code> treated as a <code>Comm_sat</code> and a <code>Displayed</code>, respectively.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="27">
<li><p>Why didn’t I just keep the <code>Satellite</code> and <code>Displayed</code> parts of a <code>Comm_sat</code> completely separate? </p>
<ul>
<li><p>I could have defined <code>Comm_sat</code> to have a <code>Satellite</code> member and a <code>Displayed member</code>. </p>
</li>
<li><p>Alternatively, I could have defined <code>Comm_sat</code> to have a <code>Satellite∗</code> member and a <code>Displayed∗</code> member and let its constructor set up the proper connections. </p>
</li>
</ul>
<p>For many design problems, I would do just that. </p>
<p>However, the system that inspired this example was built on the idea of a <code>Satellite</code> class with virtual functions and a (separately designed) <code>Displayed</code> class with virtual functions. </p>
<p>You provided your own satellites and your own displayed objects through derivation. </p>
<ul>
<li><p>In particular, you had to override <code>Satellite</code> virtual member functions and <code>Displayed</code> virtual member functions to specify the behavior of your own objects. </p>
</li>
<li><p>That is the situation in which multiple inheritance of base classes with state and implementation is hard to avoid.</p>
</li>
</ul>
<p>Workarounds can be painful and hard to maintain.</p>
</li>
</ol>
<ol start="28">
<li><p>The use of multiple inheritance to ‘‘glue’’ two otherwise unrelated classes together as part of the implementation of a third class is crude, effective, and relatively important, but not very interesting.</p>
<ul>
<li><p>Basically, it saves the programmer from writing a lot of forwarding functions (to compensate for the fact that we can only override functions defined in bases). </p>
</li>
<li><p>This technique does not affect the overall design of a program significantly and can occasionally clash with the wish to keep implementation details hidden. </p>
</li>
</ul>
<p>However, <strong>a technique doesn’t have to be clever to be useful</strong>.</p>
</li>
</ol>
<ol start="29">
<li><p>I generally prefer to have a single implementation hierarchy and (where needed) several abstract classes providing interfaces.</p>
<ul>
<li>This is typically more flexible and leads to systems that are easier to evolve. </li>
</ul>
<p>However, you can’t always get that – especially if you need to use existing classes that you don’t want to modify (e.g., because they are parts of someone else’s library).</p>
<p>Note that with single inheritance (only), the programmer’s choices for implementing the classes <code>Displayed</code>, <code>Satellite</code>, and <code>Comm_sat</code> would be limited. </p>
<ul>
<li>A <code>Comm_sat</code> could be a <code>Satellite</code> or a <code>Displayed</code>, but not both (unless <code>Satellite</code> was derived from <code>Displayed</code> or vice versa). <ul>
<li>Either alternative involves a loss of flexibility.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="30">
<li><p>Why would anyone want a class <code>Comm_sat</code>? </p>
<ul>
<li><p>Contrary to some people’s conjectures, the <code>Satellite</code> example is real. </p>
</li>
<li><p>There really was – and maybe there still is – a program constructed along the lines used to describe multiple implementation inheritance here. </p>
</li>
</ul>
<p>It was used to study the design of communication systems involving satellites, ground stations, etc. </p>
<ul>
<li>In fact, <code>Satellite</code> was derived from an early notion of a concurrent task. </li>
</ul>
<p>Given such a simulation, we can:</p>
<ul>
<li>answer questions about communication traffic flow, </li>
<li>determine proper responses to a ground station that is being blocked by a rainstorm, </li>
<li>consider tradeoffs between satellite connections and Earth-bound connections, etc.</li>
</ul>
</li>
</ol>
<h4 id="21-3-3-Ambiguity-Resolution"><a href="#21-3-3-Ambiguity-Resolution" class="headerlink" title="21.3.3 Ambiguity Resolution"></a>21.3.3 Ambiguity Resolution</h4><ol start="31">
<li><p>Two base classes may have member functions with the same name. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Satellite</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Debug_info <span class="hljs-title">get_debug</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Displayed</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Debug_info <span class="hljs-title">get_debug</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>When a <code>Comm_sat</code> is used, these functions must be disambiguated. </p>
<p>This can be done simply by qualifying a member name by its class name:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Comm_sat&amp; cs)</span></span><br><span class="hljs-function"></span>&#123;<br>    Debug_info di = cs.<span class="hljs-built_in">get_debug</span>(); <span class="hljs-comment">// error : ambiguous</span><br>    di = cs.Satellite::<span class="hljs-built_in">get_debug</span>(); <span class="hljs-comment">// OK</span><br>    di = cs.Displayed::<span class="hljs-built_in">get_debug</span>(); <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>However, explicit disambiguation is messy, so it is usually best to resolve such problems by defining a new function in the derived class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comm_sat</span> : <span class="hljs-keyword">public</span> Satellite, <span class="hljs-keyword">public</span> Displayed &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Debug_info <span class="hljs-title">get_debug</span><span class="hljs-params">()</span> <span class="hljs-comment">// override Comm_sat::get_debug() and Displayed::get_debug()</span></span><br><span class="hljs-function">    </span>&#123;<br>        Debug_info di1 = Satellite::<span class="hljs-built_in">get_debug</span>();<br>        Debug_info di2 = Displayed::<span class="hljs-built_in">get_debug</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge_info</span>(di1,di2);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>A function declared in a derived class overrides all functions of the same name and type in its base classes. </p>
</li>
<li><p>Typically, that is exactly the right thing to do because it is generally a bad idea to use the same name for operations with different semantics in a single class. </p>
</li>
</ul>
<p>The ideal for <code>virtual</code> is for a call to have the same effect independently of which interface was used to find the function (§20.3.2).</p>
</li>
</ol>
<ol start="32">
<li><p>In the implementation of an overriding function, it is often necessary to explicitly qualify the name to get the right version from a base class. </p>
<p>A qualified name, such as <code>Telstar::draw</code>, can refer to a <code>draw</code> declared either in <code>Telstar</code> or in one of its base classes. </p>
<ul>
<li><p>For example:]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Telstar</span> : <span class="hljs-keyword">public</span> Comm_sat &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        Comm_sat::<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">//finds Displayed::draw</span><br>        <span class="hljs-comment">// ... own stuff ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206191643810.png" srcset="/img/loading.gif" lazyload alt="image-20230206191643810"></p>
</li>
<li><p>If <code>Comm_sat::draw</code> doesn’t resolve to a <code>draw</code> declared in <code>Comm_sat</code>, the compiler recursively looks in its base classes;</p>
<ul>
<li>that is, it looks for <code>Satellite::draw</code> and <code>Displayed::draw</code>, and if necessary looks in their base classes. </li>
</ul>
</li>
</ul>
<p>If exactly one match is found, that name will be used. </p>
<ul>
<li>Otherwise, <code>Comm_sat::draw</code> is either not found or is ambiguous.</li>
</ul>
<p>If, in <code>Telstar::draw()</code>, I had said plain <code>draw()</code>, the result would have been an ‘‘infinite’’ recursive call of <code>Telstar::draw()</code>.</p>
<p>I could have said <code>Displayed::draw()</code>, but now the code would be subtly broken if someone added a <code>Comm_sat::draw()</code>; </p>
<ul>
<li><strong>it is generally better to refer to a direct base class than to an indirect base class</strong>. </li>
</ul>
<p>I could have said <code>Comm_sat::Displayed::draw()</code>, but that would have been redundant. </p>
<p>Had I said <code>Satellite::draw()</code>, the result would have been an error because the <code>draw</code> is over on the <code>Displayed</code> branch of the class hierarchy.</p>
</li>
</ol>
<ol start="33">
<li><p>The <code>get_debug()</code> example basically assumes that at least some parts of <code>Satellite</code> and <code>Displayed</code> have been designed together. </p>
<ul>
<li>Getting an exact match of names, return types, argument types, and semantics by accident is extremely unlikely. </li>
</ul>
<p>It is far more likely that similar functionality is provided in different ways so that it takes effort to merge it into something that can be used together.</p>
<ul>
<li><p>We might originally have been presented with two classes <code>SimObj</code> and <code>Widget</code> that we could not modify, didn’t exactly provide what we needed, and where they did provide what we needed, did so through incompatible interfaces. </p>
</li>
<li><p>In that case, we might have designed <code>Satellite</code> and <code>Displayed</code> as our interface classes, providing a ‘‘mapping layer’’ for our higher-level classes to use:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Satellite</span> : <span class="hljs-keyword">public</span> SimObj &#123;<br>    <span class="hljs-comment">// map SimObj facilities to something easier to use for Satellite simulation</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Debug_info <span class="hljs-title">get_debug</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// call SimObj::DBinf() and extract infor mation</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Displayed</span> : <span class="hljs-keyword">public</span> Widget &#123;<br>    <span class="hljs-comment">// map Widget facilities to something easier to use to display Satellite simulation results</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Debug_info <span class="hljs-title">get_debug</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// read Widget data and compose Debug_info</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206202030043.png" srcset="/img/loading.gif" lazyload alt="image-20230206202030043"></p>
</li>
</ul>
<p>Interestingly enough, this is exactly the technique we would use to disambiguate in the unlikely case where two base classes provided operations with exactly the same name, but with different semantics: <strong>add an interface layer</strong>. </p>
<ul>
<li><p>Consider the classical (but mostly hypothetical/theoretical) example of a class of a <code>draw()</code> member function in a video game involving cowboys:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// display image</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cowboy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// pull gun from holster</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cowboy_window</span> : <span class="hljs-keyword">public</span> Cowboy, <span class="hljs-keyword">public</span> Window &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>These two functions have radically different meanings (semantics) but are identical in name and type; </p>
<ul>
<li>we need to override them by two separate functions. </li>
</ul>
</li>
<li><p>There is no direct language solution to this (exotic) problem, but adding intermediate classes will do:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WWindow</span> : Window &#123;<br>    <span class="hljs-keyword">using</span> Window::Window; <span class="hljs-comment">// inherit constructors</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">win_draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// force derived class to override</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span> </span>&#123; <span class="hljs-built_in">win_draw</span>(); &#125; <span class="hljs-comment">// display image</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CCowboy</span> : Cowboy&#123;<br>    <span class="hljs-keyword">using</span> Cowboy::Cowboy; <span class="hljs-comment">// inherit constructors</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">cow_draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// force derived class to override</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span> </span>&#123; <span class="hljs-built_in">cow_draw</span>(); &#125; <span class="hljs-comment">// pull gun from holster</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cowboy_window</span> : <span class="hljs-keyword">public</span> CCowboy, <span class="hljs-keyword">public</span> WWindow &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cow_draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">win_draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206202926635.png" srcset="/img/loading.gif" lazyload alt="image-20230206202926635"></p>
<ul>
<li>Had the designer of <code>Window</code> been a bit more careful and specified <code>draw()</code> to be <code>const</code>, the whole problem would have evaporated. </li>
<li>I find that fairly typical.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="21-3-4-Repeated-Use-of-a-Base-Class"><a href="#21-3-4-Repeated-Use-of-a-Base-Class" class="headerlink" title="21.3.4 Repeated Use of a Base Class"></a>21.3.4 Repeated Use of a Base Class</h4><ol start="34">
<li><p>When each class has only one direct base class, the class hierarchy will be a tree, and a class can only occur once in the tree.</p>
<p>When a class can have multiple base classes, a class can appear multiple times in the resulting hierarchy. </p>
<ul>
<li><p>Consider a class providing facilities for storing state in a file (e.g., for breakpointing, debug information, or persistence) and restoring it later:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Storable</span> &#123; <span class="hljs-comment">// persistent storage</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">get_file</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Storable</span>() &#123; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>Such a useful class will naturally be used in several places in a class hierarchy. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transmitter</span> : <span class="hljs-keyword">public</span> Storable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> : <span class="hljs-keyword">public</span> Storable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Radio</span> : <span class="hljs-keyword">public</span> Transmitter, <span class="hljs-keyword">public</span> Receiver &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">get_file</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Given that, we could imagine two cases:</p>
<ul>
<li>A <code>Radio</code> object has two subobjects of class <code>Storable</code> (one for <code>Transmitter</code> and one for <code>Receiver</code>).</li>
<li>A <code>Radio</code> object has one subobject of class <code>Storable</code> (shared by <code>Transmitter</code> and <code>Receiver</code>).</li>
</ul>
</li>
<li><p><strong>The default, provided for the example as written, is two subobjects</strong>. Unless you state otherwise, you get one copy for each time you mention a class as a base. </p>
<ul>
<li><p>Graphically, we can represent that like this:</p>
<p><img src="image-20230206203844744.png" srcset="/img/loading.gif" lazyload alt="image-20230206203844744"></p>
</li>
</ul>
</li>
<li><p>A virtual function of a replicated base class can be overridden by a (single) function in a derived class. </p>
<p>Typically, an overriding function calls its base class versions and then does the work specific to the derived class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Radio::write</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Transmitter::<span class="hljs-built_in">write</span>();<br>    Receiver::<span class="hljs-built_in">write</span>();<br>    <span class="hljs-comment">// ... write radio-specific information ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="35">
<li><p>Casting from a replicated base class to a derived class is discussed in §22.2. </p>
<p>For a technique for overriding each of the <code>write()</code> functions with separate functions from derived classes, see §21.3.3.</p>
</li>
</ol>
<h4 id="21-3-5-Virtual-Base-Classes"><a href="#21-3-5-Virtual-Base-Classes" class="headerlink" title="21.3.5 Virtual Base Classes"></a>21.3.5 Virtual Base Classes</h4><ol start="36">
<li><p>The <code>Radio</code> example in the previous subsection works because class <code>Storable</code> can be safely, conveniently, and efficiently replicated. </p>
<ul>
<li><p>The reason for that is simply that <code>Storable</code> is an abstract class providing a pure interface. </p>
</li>
<li><p>A <code>Storable</code> object holds no data of its own. </p>
</li>
</ul>
<p>This is the simplest case and the one that offers the best separation of interface and implementation concerns. </p>
<p>In fact, a class could not without some difficulty determine that there were two <code>Storable</code> subobjects on a <code>Radio</code>.</p>
</li>
</ol>
<ol start="37">
<li><p>What if <code>Storable</code> did hold data and it was important that it should not be replicated? </p>
<ul>
<li><p>For example, we might define <code>Storable</code> to hold the name of the file to be used for storing the object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Storable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Storable</span>(<span class="hljs-type">const</span> string&amp; s); <span class="hljs-comment">// store in file named s</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Storable</span>();<br><span class="hljs-keyword">protected</span>:<br>    string file_name; <span class="hljs-comment">// Storable&#x27;s own data</span><br>    <br>    <span class="hljs-built_in">Storable</span>(<span class="hljs-type">const</span> Storable&amp;) = <span class="hljs-keyword">delete</span>;<br>    Storable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Storable&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Given this apparently minor change to <code>Storable</code>, we must change the design of <code>Radio</code>. </p>
<ul>
<li><p>All parts of an object must share a single copy of <code>Storable</code>. </p>
</li>
<li><p>Otherwise, we could get two parts of something derived from <code>Storable</code> multiple times using different files. </p>
</li>
</ul>
<p>**We avoid replication by declaring a base <code>virtual</code>: **</p>
<ul>
<li><p><strong>every <code>virtual</code> base of a derived class is represented by the same (shared) object.</strong> </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transmitter</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Storable &#123; <span class="hljs-comment">// virtual base Storable</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Storable &#123; <span class="hljs-comment">// virtual base Storable</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Radio</span> : <span class="hljs-keyword">public</span> Transmitter, <span class="hljs-keyword">public</span> Receiver &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206205536969.png" srcset="/img/loading.gif" lazyload alt="image-20230206205536969"></p>
<ul>
<li>Compare this diagram with the drawing of the <code>Storable</code> object in §21.3.4 to see the difference between ordinary inheritance and virtual inheritance. </li>
</ul>
<p>In an inheritance graph, <strong>every base class of a given name that is specified to be <code>virtual</code> will be represented by a single object of that class</strong>. </p>
<p>On the other hand, <strong>each base class not specified <code>virtual</code> will have its own subobject representing it</strong>.</p>
</li>
</ul>
</li>
</ol>
<ol start="38">
<li><p>Why would someone want to use a virtual base containing data? </p>
<p>I can think of three obvious ways for two classes in a class hierarchy to share data:</p>
<ul>
<li><p>Make the data nonlocal (outside the class as a global or namespace variable).</p>
<ul>
<li>Option [1], nonlocal data, is usually a poor choice because we cannot control what code accesses the data and how.</li>
<li>It breaks all notions of encapsulation and locality.</li>
</ul>
</li>
<li><p>Put the data in a base class.</p>
<ul>
<li><p>Option [2], put the data in a base class, is usually the simplest. </p>
</li>
<li><p>However, for single inheritance that solution makes useful data (and functions) ‘‘bubble up’’ to a common base class; often it ‘‘bubbles’’ all the way to the root of an inheritance tree. </p>
<ul>
<li><p>This means that every member of the class hierarchy gets access. </p>
</li>
<li><p>That is logically very similar to using nonlocal data and suffers from the same problems. </p>
</li>
</ul>
<p>So we need a common base that is not the root of a tree – that is, a virtual base.</p>
</li>
</ul>
</li>
<li><p>Allocate an object somewhere and give each of the two classes a pointer.</p>
<ul>
<li><p>Option [3], sharing an object accessed through pointers, makes sense. </p>
</li>
<li><p>However, then constructor(s) need to set aside memory for that shared object, initialize it, and provide pointers to the shared object to objects needing access. </p>
<p>That is roughly what constructors do to implement a virtual base.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="39">
<li><p>If you don’t need sharing, you can do without virtual bases, and your code is often better and typically simpler for it. </p>
<p>However, if you do need sharing within a general class hierarchy, you basically have a choice between using a virtual base and laboriously constructing your own variants of the idea.</p>
</li>
</ol>
<ol start="40">
<li><p>We can represent an object of a class with a virtual base like this:</p>
<p><img src="image-20230206212239272.png" srcset="/img/loading.gif" lazyload alt="image-20230206212239272"></p>
<p>The ‘‘pointers’’ to the shared object representing the virtual base, <code>Storable</code>, will be offsets, and often one of those can be optimized away by placing <code>Storable</code> in a fixed position relative to either the <code>Receiver</code> or the <code>Transmitter</code> subobject.</p>
<p>Expect a storage overhead of one word for each virtual base.</p>
</li>
</ol>
<h5 id="21-3-5-1-Constructing-Virtual-Bases"><a href="#21-3-5-1-Constructing-Virtual-Bases" class="headerlink" title="21.3.5.1 Constructing Virtual Bases"></a>21.3.5.1 Constructing Virtual Bases</h5><ol start="41">
<li><p>Using virtual bases you can create complicated lattices. </p>
<p>Naturally, we would prefer to keep the lattices simple, but however complicated we make them, <strong>the language ensures that a constructor of a virtual base is called exactly once</strong>. </p>
<p>Furthermore, <strong>the constructor of a base (whether virtual or not) is called before its derived classes</strong>. </p>
<ul>
<li><p>Anything else would cause chaos (that is, an object might be used before it had been initialized). </p>
</li>
<li><p>To avoid such chaos, the constructor of every virtual base is invoked (implicitly or explicitly) from the constructor for the complete object (the constructor for the most derived class). </p>
</li>
</ul>
<p>In particular, this ensures that a virtual base is constructed exactly once even if it is mentioned in many places in the class hierarchy. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">V</span> &#123;<br>    <span class="hljs-built_in">V</span>(<span class="hljs-type">int</span> i); <span class="hljs-comment">// no default constructor; must be explicitly initialized</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-built_in">A</span>(); <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> V, <span class="hljs-keyword">virtual</span> A &#123;<br>    <span class="hljs-built_in">B</span>() :V&#123;<span class="hljs-number">1</span>&#125; &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// default constructor ; must initialize base V</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> V &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i) : V&#123;i&#125; &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// must initialize base V</span><br>    <span class="hljs-comment">// ...						 // no default constructor</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> C &#123;<br>    <span class="hljs-comment">// implicitly gets the virtual base V from B and C</span><br>    <span class="hljs-comment">// implicitly gets virtual base A from B</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">D</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// error : no default constructor for C or V</span><br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i) :C&#123;i&#125; &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// error : no default constructor for V</span><br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) :V&#123;i&#125;, C&#123;j&#125; &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Note that <code>D</code> can and must provide an initializer for <code>V</code>. <ul>
<li>The fact that <code>V</code> wasn’t explicitly mentioned as a base of <code>D</code> is irrelevant. </li>
</ul>
</li>
<li><strong>Knowledge of a virtual base and the obligation to initialize it ‘‘bubbles up’’ to the most derived class.</strong> </li>
<li><strong>A virtual base is always considered a direct base of its most derived class</strong>.</li>
</ul>
</li>
<li><p>The fact that both <code>B</code> and <code>C</code> initialized <code>V</code> is irrelevant because the compiler has no idea which of those two initializers to prefer.</p>
<p>Thus, <strong>only the initializer provided by the most derived class is used</strong>.</p>
<ul>
<li>In this example, the initializer provided by <code>D</code> is used to initialize <code>V</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="42">
<li><p>The constructor for a virtual base is called before the constructors for its derived classes.</p>
<p>In practice, this is not quite as localized as we would prefer. </p>
<ul>
<li><p>In particular, if we derive another class, <code>DD</code>, from <code>D</code>, then <code>DD</code> has to do work to initialize the virtual bases. </p>
</li>
<li><p>Unless we can simply inherit <code>D</code>’s constructors (§20.3.5.1), that can be a nuisance. </p>
</li>
</ul>
<p>That ought to encourage us not to overuse virtual base classes.</p>
</li>
</ol>
<ol start="43">
<li><p>This logical problem with constructors does not exist for destructors. </p>
<ul>
<li>They are simply invoked in reverse order of construction (§20.2.2). </li>
</ul>
<p>In particular, a destructor for a virtual base is invoked exactly once.</p>
</li>
</ol>
<h5 id="21-3-5-2-Calling-a-Virtual-Class-Member-Only-Once"><a href="#21-3-5-2-Calling-a-Virtual-Class-Member-Only-Once" class="headerlink" title="21.3.5.2 Calling a Virtual Class Member Only Once"></a>21.3.5.2 Calling a Virtual Class Member Only Once</h5><ol start="44">
<li><p>When defining the functions for a class with a virtual base, the programmer in general cannot know whether the base will be shared with other derived classes. </p>
<ul>
<li>This can be a problem when implementing a service that requires a base class function to be called exactly once for each call of a derived function. </li>
</ul>
<p>Where needed, the programmer can simulate the scheme used for constructors by <strong>calling a virtual base class function only from the most derived class</strong>. </p>
<ul>
<li><p>For example, assume we have a basic <code>Window</code> class that knows how to draw its contents:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// basic stuff</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>In addition, we have various ways of decorating a window and adding facilities:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_with_border</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Window &#123;<br>    <span class="hljs-comment">// border stuff</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">own_draw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// display the border</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_with_menu</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Window &#123;<br>    <span class="hljs-comment">// menu stuff</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">own_draw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// display the menu</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>own_draw()</code> functions need not be virtual because they are meant to be called from within a virtual <code>draw()</code> function that ‘‘knows’’ the type of the object for which it was called.</li>
</ul>
<p>From this, we can compose a plausible <code>Clock</code> class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> : <span class="hljs-keyword">public</span> Window_with_border, <span class="hljs-keyword">public</span> Window_with_menu &#123;<br>    <span class="hljs-comment">// clock stuff</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">own_draw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// display the clock face and hands</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230206230214511.png" srcset="/img/loading.gif" lazyload alt="image-20230206230214511"></p>
<ul>
<li><p>The <code>draw()</code> functions can now be defined using the <code>own_draw()</code> functions, so that a caller of any <code>draw()</code> gets <code>Window::draw()</code> invoked exactly once. </p>
</li>
<li><p>This is done independently of the kind of <code>Window</code> for which <code>draw()</code> is invoked:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Window_with_border::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Window::<span class="hljs-built_in">draw</span>();<br>    <span class="hljs-built_in">own_draw</span>(); <span class="hljs-comment">// display the border</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Window_with_menu::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Window::<span class="hljs-built_in">draw</span>();<br>    <span class="hljs-built_in">own_draw</span>(); <span class="hljs-comment">// display the menu</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clock::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Window::<span class="hljs-built_in">draw</span>();<br>    Window_with_border::<span class="hljs-built_in">own_draw</span>();<br>    Window_with_menu::<span class="hljs-built_in">own_draw</span>();<br>    <span class="hljs-built_in">own_draw</span>(); <span class="hljs-comment">// display the clock face and hands</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Note that a qualified call, such as <code>Window::draw()</code>, does not use the virtual call mechanism. </p>
<p>Instead, it directly calls the explicitly named function, thus avoiding nasty infinite recursion.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="45">
<li>Casting from a virtual base class to a derived class is discussed in §22.2.</li>
</ol>
<h4 id="21-3-6-Replicated-vs-Virtual-Bases"><a href="#21-3-6-Replicated-vs-Virtual-Bases" class="headerlink" title="21.3.6 Replicated vs. Virtual Bases"></a>21.3.6 Replicated vs. Virtual Bases</h4><ol start="46">
<li><p><strong>Using multiple inheritance to provide implementations for abstract classes representing pure interfaces</strong> affects the way a program is designed. </p>
<ul>
<li><p>Class <code>BB_ival_slider</code> (§21.2.3) is an example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span><br>    : <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-comment">// interface</span><br>	<span class="hljs-keyword">protected</span> BBslider <span class="hljs-comment">// implementation</span><br>&#123;<br>    <span class="hljs-comment">// implementation of functions required by Ival_slider and BBslider, using</span><br>    <span class="hljs-comment">//   facilities from BBslider</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>In this example, <strong>the two base classes play logically distinct roles</strong>. </p>
<ul>
<li>One base is a public abstract class providing the interface, and</li>
<li>the other is a protected concrete class providing implementation ‘‘details.’’ </li>
</ul>
<p>These roles are reflected in both the style of the classes and in the access control (§20.5) provided. </p>
</li>
<li><p>The use of multiple inheritance is close to essential here because the derived class needs to override virtual functions from both the interface and the implementation.</p>
</li>
</ul>
<p>For example, consider again the <code>Ival_box</code> classes from §21.2.1.</p>
<ul>
<li><p>In the end (§21.2.2), I made all the <code>Ival_box</code> classes abstract to reflect their role as pure interfaces. </p>
</li>
<li><p>Doing that allowed me to place all implementation details in specific implementation classes. </p>
</li>
<li><p>Also, all sharing of implementation details was done in the classical hierarchy of the windows system used for the implementation.</p>
</li>
</ul>
</li>
</ol>
<ol start="47">
<li><p>When using an abstract class (without any shared data) as an interface, we have a choice:</p>
<ul>
<li>Replicate the interface class (one object per mention in the class hierarchy).</li>
<li>Make the interface class <code>virtual</code> to share a simple object among all classes in the hierarchy that mention it.</li>
</ul>
<p>Using <code>Ival_slider</code> as <strong>a virtual base</strong> gives us:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span><br>    : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Ival_slider, <span class="hljs-keyword">protected</span> BBslider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Popup_ival_slider</span><br>    : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_popup_ival_slider</span><br>    : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Popup_ival_slider, <span class="hljs-keyword">protected</span> BB_ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230207120637785.png" srcset="/img/loading.gif" lazyload alt="image-20230207120637785"></p>
<ul>
<li>It is easy to imagine further interfaces derived from <code>Popup_ival_slider</code> and further implementation classes derived from such classes and <code>BB_popup_ival_slider</code>.</li>
</ul>
<p>However, we also have this alternative using <strong>replicated</strong> <code>Ival_slider</code> objects:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span><br>: <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> BBslider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Popup_ival_slider</span><br>: <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_popup_ival_slider</span><br>: <span class="hljs-keyword">public</span> Popup_ival_slider, <span class="hljs-keyword">protected</span> BB_ival_slider &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230207121023689.png" srcset="/img/loading.gif" lazyload alt="image-20230207121023689"></p>
</li>
</ol>
<ol start="48">
<li><p>Surprisingly, <strong>there are no fundamental run-time or space advantages to one design over the other</strong>.</p>
<p>There are logical differences, though. </p>
<p><strong>In the replicated <code>Ival_slider</code> design, a <code>BB_popup_ival_slider</code> can’t be implicitly converted to an <code>Ival_slider</code></strong> (because that would be ambiguous):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Ival_slider∗ p)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(BB_popup_ival_slider∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(p); <span class="hljs-comment">// error : Popup_ival_slider ::Ival_slider or BB_ival_slider ::Ival_slider?</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>On the other hand, it is possible to construct plausible scenarios where the sharing implied in the virtual base design causes ambiguities for casts <em><strong>from</strong></em> the base class (§22.2). </p>
<ul>
<li>However, such ambiguities are easily dealt with.</li>
</ul>
</li>
</ol>
<ol start="49">
<li><p>How do we choose between virtual base classes and replicated base classes for our interfaces?</p>
<ul>
<li><p>Most often, of course, we don’t get a choice because we have to conform to an existing design.</p>
</li>
<li><p><strong>When we do have a choice, we can take into account that (surprisingly) the replicated base solution</strong> tends to lead to slightly smaller objects (because there is no need for data structures supporting sharing) and that we often get our interface objects from ‘‘virtual constructors’’ or ‘‘factory functions’’ (§21.2.4). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Popup_ival_slider∗ <span class="hljs-built_in">popup_slider_factory</span>(args) <span class="hljs-comment">// &quot;virtual constructor&quot; or &quot;factory function&quot;</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BB_popup_ival_slider</span>(args);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>No explicit conversion is needed to get from an implementation (here, <code>BB_popup_ival_slider</code>) to its direct interfaces (here, <code>Popup_ival_slider</code>).</p>
</li>
</ul>
</li>
</ol>
<h5 id="21-3-6-1-Overriding-Virtual-Base-Functions"><a href="#21-3-6-1-Overriding-Virtual-Base-Functions" class="headerlink" title="21.3.6.1 Overriding Virtual Base Functions"></a>21.3.6.1 Overriding Virtual Base Functions</h5><ol start="50">
<li><p>A derived class can override a virtual function of its direct or indirect virtual base class. </p>
<p>In particular, two different classes might override different virtual functions from the virtual base. </p>
<ul>
<li><p>In that way, several derived classes can contribute implementations to the interface presented by a virtual base class. </p>
</li>
<li><p>For example, the <code>Window</code> class might have functions <code>set_color()</code> and <code>prompt()</code>. </p>
<ul>
<li>In that case, <code>Window_with_border</code> might override <code>set_color()</code> as part of controlling the color scheme, and</li>
<li><code>Window_with_menu</code> might override <code>prompt()</code> as part of its control of user interactions:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">set_color</span><span class="hljs-params">(Color)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// set background color</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">prompt</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_with_border</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Window &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_color</span><span class="hljs-params">(Color)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// control background color</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_with_menu</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Window &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prompt</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// control user interactions</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_window</span> : <span class="hljs-keyword">public</span> Window_with_menu, <span class="hljs-keyword">public</span> Window_with_border &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>What if different derived classes override the same function? </p>
<ul>
<li><p>This is allowed if and only if some overriding class is derived from every other class that overrides the function. </p>
</li>
<li><p>That is, <strong>one function must override all others</strong>. </p>
</li>
</ul>
<p>For example, <code>My_window</code> could override <code>prompt()</code> to improve on what <code>Window_with_menu</code> provides:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_window</span> : <span class="hljs-keyword">public</span> Window_with_menu, <span class="hljs-keyword">public</span> Window_with_border &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prompt</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// don’t leave user interactions to base</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230207123714467.png" srcset="/img/loading.gif" lazyload alt="image-20230207123714467"></p>
<p><strong>If two classes override a base class function, but neither overrides the other, the class hierarchy is an error.</strong> </p>
<ul>
<li><p>The reason is that <strong>no single function can be used to give a consistent meaning for all calls independently of which class they use as an interface</strong>. </p>
</li>
<li><p>Or, using implementation terminology, <strong>no virtual function table can be constructed</strong> because a call to that function on the complete object would be <strong>ambiguous</strong>. </p>
</li>
</ul>
<p>For example, had <code>Radio</code> in §21.3.5 not declared <code>write()</code>, the declarations of <code>write()</code> in <code>Receiver</code> and <code>Transmitter</code> would have caused an error when defining <code>Radio</code>. </p>
<ul>
<li>Ambiguity.</li>
</ul>
<p>As with <code>Radio</code>, such a conflict is resolved by adding an overriding function to the most derived class.</p>
</li>
</ol>
<ol start="51">
<li>A class that provides some – but not all – of the implementation for a virtual base class is often called a <em><strong>mixin</strong></em>.</li>
</ol>
<h3 id="21-4-Advice"><a href="#21-4-Advice" class="headerlink" title="21.4 Advice"></a>21.4 Advice</h3><p>[1] Use <code>unique_ptr</code> or <code>shared_ptr</code> to avoid forgetting to <code>delete</code> objects created using <code>new</code>; §21.2.1.<br>[2] Avoid data members in base classes intended as interfaces; §21.2.1.1.<br>[3] Use abstract classes to express interfaces; §21.2.2.<br>[4] Give an abstract class a virtual destructor to ensure proper cleanup; §21.2.2.<br>[5] Use <code>override</code> to make overriding explicit in large class hierarchies; §21.2.2.<br>[6] Use abstract classes to support interface inheritance; §21.2.2.<br>[7] Use base classes with data members to support implementation inheritance; §21.2.2.<br>[8] Use ordinary multiple inheritance to express a union of features; §21.3.<br>[9] Use multiple inheritance to separate implementation from interface; §21.3.<br>[10] Use a virtual base to represent something common to some, but not all, classes in a hierarchy; §21.3.5.</p>
<h2 id="Chapter-22-Run-Time-Type-Information"><a href="#Chapter-22-Run-Time-Type-Information" class="headerlink" title="Chapter 22. Run-Time Type Information"></a>Chapter 22. Run-Time Type Information</h2><ul>
<li>Introduction</li>
<li>Class Hierarchy Navigation<ul>
<li><code>dynamic_cast</code></li>
<li>Multiple Inheritance</li>
<li><code>static_cast</code> and <code>dynamic_cast</code></li>
<li>Recovering an Interface</li>
</ul>
</li>
<li>Double Dispatch and Visitors<ul>
<li>Double Dispatch</li>
<li>Visitors</li>
</ul>
</li>
<li>Construction and Destruction</li>
<li>Type Identification<ul>
<li>Extended Type Information</li>
</ul>
</li>
<li>Uses and Misuses of RTTI</li>
<li>Advice</li>
</ul>
<h3 id="22-1-Introduction"><a href="#22-1-Introduction" class="headerlink" title="22.1 Introduction"></a>22.1 Introduction</h3><ol>
<li><p>In general, a class is constructed from a lattice of base classes. </p>
<p>Such a class lattice is often called a <em><strong>class hierarchy</strong></em>. </p>
<p>We try to design classes so that users need not be unduly concerned about the way a class is composed out of other classes.</p>
<ul>
<li>In particular, the virtual call mechanism ensures that when we call a function <code>f()</code> on an object, the same function is called whichever class in the hierarchy provided the declaration of <code>f()</code> used for the call and whichever class defined it. </li>
</ul>
<p>This chapter explains how to gain information about the total object given only the interface provided by a base class.</p>
</li>
</ol>
<h3 id="22-2-Class-Hierarchy-Navigation"><a href="#22-2-Class-Hierarchy-Navigation" class="headerlink" title="22.2 Class Hierarchy Navigation"></a>22.2 Class Hierarchy Navigation</h3><ol start="2">
<li><p>A plausible use of the <code>Ival_box</code>es defined in §21.2 would be to hand them to a system that controlled a screen and have that system hand objects back to the application program whenever some activity had occurred. </p>
<ul>
<li><p>We will refer to the combination of GUI library and operating system facilities that control the screen as <em><strong>the system</strong></em>. </p>
</li>
<li><p>Objects passed back and forth between the system and the application are commonly referred to as <em><strong>widgets</strong></em> or <em><strong>controls</strong></em>. </p>
</li>
<li><p>This is how many user interfaces work.</p>
</li>
</ul>
<p><strong>From a language point of view, it is important that the system does not know about our <code>Ival_box</code>es</strong>.</p>
<ul>
<li><p>The system’s interfaces are specified in terms of the system’s own classes and objects rather than our application’s classes.</p>
</li>
<li><p>This is necessary and proper. </p>
</li>
</ul>
<p>However, <strong>it does have the unpleasant effect that we lose information about the type of objects passed to the system and later returned to us</strong>.</p>
</li>
</ol>
<ol start="3">
<li><p>Recovering the ‘‘lost’’ type of an object requires us to somehow ask the object to reveal its type. </p>
<p><strong>Any operation on an object requires us to have a pointer or reference of a suitable type for the object.</strong> </p>
<p>Consequently, the <strong>most obvious and useful operation for inspecting the type of an object at run time is a type conversion operation that returns a valid pointer</strong> if the object is of the expected type and a null pointer if it isn’t. </p>
<ul>
<li><p>The <code>dynamic_cast</code> operator does exactly that. </p>
</li>
<li><p>For example, assume that ‘‘the system’’ invokes <code>my_event_handler()</code> with a pointer to a <code>BBwindow</code>, where an activity has occurred. </p>
<p>I then might invoke my application code using <code>Ival_box</code>’s <code>do_something()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_event_handler</span><span class="hljs-params">(BBwindow∗ pw)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> pb = <span class="hljs-built_in">dynamic_cast</span>&lt;Ival_box∗&gt;(pw)) &#123; <span class="hljs-comment">// does pw point to an Ival_box?</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-type">int</span> x = pb−&gt;<span class="hljs-built_in">get_value</span>(); <span class="hljs-comment">// use the Ival_box</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ... oops! cope with unexpected event ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>One way of explaining what is going on here is that <code>dynamic_cast</code> translates from the implementation-oriented language of the user-interface system to the language of the application. </li>
<li>It is important to note <strong>what is not mentioned in this example</strong>: <strong>the actual type of the object</strong>. <ul>
<li>The object will be a particular kind of <code>Ival_box</code>, say, an <code>Ival_slider</code>, implemented by a particular kind of <code>BBwindow</code>, say, a <code>BBslider</code>. </li>
</ul>
</li>
<li><strong>It is neither necessary nor desirable to make the actual type of the object explicit in this interaction between ‘‘the system’’ and the application.</strong> </li>
<li><strong>An interface exists to represent the essentials of an interaction</strong>. <ul>
<li>In particular, a well-designed interface hides inessential details.</li>
</ul>
</li>
</ul>
</li>
<li><p>Graphically, the action of <code>pb=dynamic_cast&lt;Ival_box∗&gt;(pw)</code> can be represented like this:</p>
<p><img src="image-20230207151825566-1675754306748-1.png" srcset="/img/loading.gif" lazyload alt="image-20230207151825566"></p>
<ul>
<li>The arrows from <code>pw</code> and <code>pb</code> represent the pointers into the object passed, whereas the rest of the arrows represent the inheritance relationships between the different parts of the object passed.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li>The use of type information at run time is conventionally referred to as ‘‘<strong>run-time type information</strong>,’’ often abbreviated to <strong>RTTI</strong>.</li>
</ol>
<ol start="5">
<li><p>Casting from a base class to a derived class is often called a <em><strong>downcast</strong></em> because of the convention of drawing inheritance trees growing from the root down. </p>
<p>Similarly, a cast from a derived class to a base is called an <em><strong>upcast</strong></em>. </p>
<p>A cast that goes from a base to a sibling class, like the cast from <code>BBwindow</code> to <code>Ival_box</code>, is called a <em><strong>crosscast</strong></em>.</p>
</li>
</ol>
<h4 id="22-2-1-dynamic-cast"><a href="#22-2-1-dynamic-cast" class="headerlink" title="22.2.1 dynamic_cast"></a>22.2.1 <code>dynamic_cast</code></h4><ol start="6">
<li>The <code>dynamic_cast</code> operator takes two operands: <ul>
<li>a type bracketed by <code>&lt;</code> and <code>&gt;</code>, and</li>
<li>a pointer or reference bracketed by <code>(</code> and <code>)</code>. </li>
</ul>
</li>
</ol>
<ol start="7">
<li><p>Consider first the pointer case:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">dynamic_cast</span>&lt;T∗&gt;(p)<br></code></pre></td></tr></table></figure>

<p>If <code>p</code> is of type <code>T∗</code> or of a type <code>D∗</code> where <code>T</code> is a base class of <code>D</code>, the result is exactly as if we had simply assigned <code>p</code> to a <code>T∗</code>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB_ival_slider</span> : <span class="hljs-keyword">public</span> Ival_slider, <span class="hljs-keyword">protected</span> BBslider &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(BB_ival_slider∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    Ival_slider∗ pi1 = p; <span class="hljs-comment">// OK</span><br>    Ival_slider∗ pi2 = <span class="hljs-built_in">dynamic_cast</span>&lt;Ival_slider∗&gt;(p); <span class="hljs-comment">// OK</span><br>    <br>    BBslider∗ pbb1 = p; <span class="hljs-comment">// error : BBslider is a protected base</span><br>    BBslider∗ pbb2 = <span class="hljs-built_in">dynamic_cast</span>&lt;BBslider∗&gt;(p); <span class="hljs-comment">//OK: pbb2 becomes nullptr</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This (the upcast) is the uninteresting case. </li>
<li>However, it is reassuring to know that <strong><code>dynamic_cast</code> doesn’t allow accidental violation of the protection of private and protected base classes</strong>. </li>
<li>Since <strong>a <code>dynamic_cast</code> used as an upcast is exactly like a simple assignment</strong>, it implies <strong>no overhead and is sensitive to its lexical context</strong>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="8">
<li><p><strong>The purpose of <code>dynamic_cast</code> is to deal with the case in which the correctness of the conversion cannot be determined by the compiler</strong>. </p>
<p>In that case, <code>dynamic_cast&lt;T∗&gt;(p)</code> looks at the object pointed to by <code>p</code> (if any). </p>
<ul>
<li><p>If that object is of class <code>T</code> or has a unique base class of type <code>T</code>, then <code>dynamic_cast</code> returns a pointer of type <code>T∗</code> to that object; otherwise, <code>nullptr</code> is returned. </p>
</li>
<li><p>If the value of <code>p</code> is <code>nullptr</code>, <code>dynamic_cast&lt;T∗&gt;(p)</code> returns <code>nullptr</code>. </p>
</li>
</ul>
<p>Note the requirement that <strong>the conversion must be to a uniquely identified object</strong>. </p>
<ul>
<li>It is possible to construct examples where the conversion fails and <code>nullptr</code> is returned because the object pointed to by <code>p</code> has more than one subobject representing bases of type <code>T</code> (§22.2).</li>
</ul>
</li>
</ol>
<ol start="9">
<li><p><strong>A <code>dynamic_cast</code> requires a pointer or a reference to a polymorphic type</strong> in order <strong>to do a downcast or a crosscast</strong>.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_slider</span>: <span class="hljs-keyword">public</span> Ival_slider &#123; <span class="hljs-comment">// polymorphic base (Ival_slider has virtual functions)</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_date</span> : <span class="hljs-keyword">public</span> Date &#123; <span class="hljs-comment">// base not polymorphic (Date has no virtual functions)</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Ival_box∗ pb, Date∗ pd)</span></span><br><span class="hljs-function"></span>&#123;<br>    My_slider∗ pd1 = <span class="hljs-built_in">dynamic_cast</span>&lt;My_slider∗&gt;(pb); <span class="hljs-comment">// OK</span><br>    My_date∗ pd2 = <span class="hljs-built_in">dynamic_cast</span>&lt;My_date∗&gt;(pd); <span class="hljs-comment">//error : Date not polymorphic</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Requiring the pointer’s type to be polymorphic simplifies the implementation of <code>dynamic_cast</code> because it makes it easy to find a place to hold the necessary information about the object’s type. </p>
<p><strong>A typical implementation will attach a ‘‘type information object’’</strong> (§22.5) <strong>to an object by placing a pointer to the type information in the virtual function table for the object’s class</strong> (§3.2.3).</p>
<ul>
<li><p>For example:</p>
<p><img src="image-20230207161057433.png" srcset="/img/loading.gif" lazyload alt="image-20230207161057433"></p>
<ul>
<li>The dashed arrow represents an offset that allows the start of the complete object to be found given only a pointer to a polymorphic subobject. </li>
<li>It is clear that <code>dynamic_cast</code> can be efficiently implemented.<ul>
<li>All that is involved are a few comparisons of <code>type_info</code> objects representing base classes;</li>
<li>no expensive lookups or string comparisons are needed.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Restricting <code>dynamic_cast</code> to polymorphic types also makes sense from a logical point of view.</p>
<ul>
<li><p>That is, if an object has no virtual functions, it cannot safely be manipulated without knowledge of its exact type. </p>
</li>
<li><p>Consequently, care should be taken not to get such an object into a context in which its type isn’t known. </p>
</li>
<li><p>If its type is known, we don’t need to use <code>dynamic_cast</code>.</p>
</li>
</ul>
</li>
</ol>
<ol start="10">
<li><p>The target type of <code>dynamic_cast</code> need not be polymorphic. </p>
<p>This allows us to wrap a concrete type in a polymorphic type, say, for transmission through an object I/O system (§22.2.4), and then ‘‘unwrap’’ the concrete type later. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Io_obj</span> &#123; <span class="hljs-comment">// base class for object I/O system</span><br>    <span class="hljs-keyword">virtual</span> Io_obj∗ <span class="hljs-built_in">clone</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Io_date</span> : <span class="hljs-keyword">public</span> Date, <span class="hljs-keyword">public</span> Io_obj &#123; &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Io_obj∗ pio)</span></span><br><span class="hljs-function"></span>&#123;<br>    Date∗ pd = <span class="hljs-built_in">dynamic_cast</span>&lt;Date∗&gt;(pio);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="11">
<li><p>A <code>dynamic_cast</code> to <code>void∗</code> can be used to determine the address of the beginning of an object of polymorphic type. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Ival_box∗ pb, Date∗ pd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">void</span>∗ pb2 = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">void</span>∗&gt;(pb); <span class="hljs-comment">// OK</span><br>    <span class="hljs-type">void</span>∗ pd2 = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">void</span>∗&gt;(pd); <span class="hljs-comment">// error : Date not polymorphic</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>The object representing a base class</strong>, such as <code>Ival_box</code>, <strong>in a derived class object is not necessarily the first subobject in that object of the most derived class</strong>. </p>
<ul>
<li>So, <code>pb</code> does not necessarily hold the same address as <code>pb2</code>.</li>
</ul>
</li>
</ul>
<p>Such casts are only useful for interaction with very low-level functions (only such functions deal with <code>void∗</code>s). </p>
<p>There is no <code>dynamic_cast</code> from <code>void∗</code> (because there would be no way of knowing where to find the <code>vptr</code>; §22.2.3).</p>
</li>
</ol>
<h5 id="22-2-1-1-dynamic-cast-to-Reference"><a href="#22-2-1-1-dynamic-cast-to-Reference" class="headerlink" title="22.2.1.1 dynamic_cast to Reference"></a>22.2.1.1 <code>dynamic_cast</code> to Reference</h5><ol start="12">
<li><p>To get polymorphic behavior, an object must be manipulated through a pointer or a reference.</p>
<p>When a <code>dynamic_cast</code> is used for a pointer type, a <code>nullptr</code> indicates failure. </p>
<p>That is neither feasible nor desirable for references.</p>
</li>
</ol>
<ol start="13">
<li><p>Given a pointer result, we must consider the possibility that the result is <code>nullptr</code>, that is, that the pointer doesn’t point to an object. </p>
<p>Consequently, <strong>the result of a <code>dynamic_cast</code> of a pointer should always be explicitly tested</strong>. </p>
<ul>
<li><p>For a pointer <code>p</code>, <code>dynamic_cast&lt;T∗&gt;(p)</code> can be seen as the question ‘‘Is the object pointed to by <code>p</code>, if any, of type <code>T</code>?’’ </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fp</span><span class="hljs-params">(Ival_box∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Ival_slider∗ is = <span class="hljs-built_in">dynamic_cast</span>&lt;Ival_slider∗&gt;(p)) &#123; <span class="hljs-comment">// does p point to an Ival_slider?</span><br>        <span class="hljs-comment">// ... use is ...</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ... *p not a slider; handle alternatives ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>On the other hand, <strong>we may legitimately assume that a reference refers to an object</strong> (§7.7.4). </p>
<p>Consequently, <code>dynamic_cast&lt;T&amp;&gt;(r)</code> of a reference r is not a question but an assertion: ‘‘The object referred to by<code> r</code> is of type <code>T</code>.’’ </p>
<ul>
<li><p>The result of a <code>dynamic_cast</code> for a reference is implicitly tested by the implementation of <code>dynamic_cast</code> itself. </p>
<ul>
<li>If the operand of a <code>dynamic_cast</code> to a reference isn’t of the expected type, a <code>bad_cast</code> exception is thrown. </li>
</ul>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fr</span><span class="hljs-params">(Ival_box&amp; r)</span></span><br><span class="hljs-function"></span>&#123;<br>    Ival_slider&amp; is = <span class="hljs-built_in">dynamic_cast</span>&lt;Ival_slider&amp;&gt;(r); <span class="hljs-comment">// r references an Ival_slider!</span><br>    <span class="hljs-comment">// ... use is ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>The difference in results of a failed dynamic pointer cast and a failed dynamic reference cast reflects a fundamental difference between references and pointers. </p>
<p>If a user wants to protect against bad casts to references, a suitable handler must be provided. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fp</span><span class="hljs-params">(Ival_box∗ p)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fr</span><span class="hljs-params">(Ival_box&amp; r)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(BB_ival_slider&amp; slider, BB_ival_dial&amp; dial)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">fp</span>(&amp;slider); <span class="hljs-comment">// pointer to BB_ival_slider passed as Ival_box*</span><br>        <span class="hljs-built_in">fr</span>(slider); <span class="hljs-comment">// reference to BB_ival_slider passed as Ival_box&amp;</span><br>        <br>        <span class="hljs-built_in">fp</span>(&amp;dial); <span class="hljs-comment">// pointer to BB_ival_dial passed as Ival_box*</span><br>        <span class="hljs-built_in">fr</span>(dial); <span class="hljs-comment">// dial passed as Ival_box</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (bad_cast) &#123; <span class="hljs-comment">// §30.4.1.1</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The calls to <code>fp()</code> and the first call to <code>fr()</code> will return normally (assuming that <code>fp()</code> really can cope with a <code>BB_ival_dial</code>), but the second call of <code>fr()</code> will cause a <code>bad_cast</code> exception that will be caught by <code>g()</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="14">
<li><p>Explicit tests against <code>nullptr</code> can easily be accidentally omitted. </p>
<p>If that worries you, you can write a conversion function that throws an exception instead of returning <code>nullptr</code> in case of failure.</p>
</li>
</ol>
<h4 id="22-2-2-Multiple-Inheritance"><a href="#22-2-2-Multiple-Inheritance" class="headerlink" title="22.2.2 Multiple Inheritance"></a>22.2.2 Multiple Inheritance</h4><ol start="15">
<li><p>When only single inheritance is used, a class and its base classes constitute a tree rooted in a single base class. </p>
<ul>
<li>This is simple but often constraining. </li>
</ul>
<p>When multiple inheritance is used, there is no single root. </p>
<ul>
<li><p>In itself, this doesn’t complicate matters much. </p>
</li>
<li><p>However, if a class appears more than once in a hierarchy, we must be a bit careful when we refer to the object or objects that represent that class.</p>
</li>
</ul>
</li>
</ol>
<ol start="16">
<li><p>Naturally, we try to keep hierarchies as simple as our application allows (and no simpler).</p>
<p>However, once a nontrivial hierarchy has been constructed, we sometimes need to <strong>navigate it to find a specific class to use</strong>.</p>
<p>This need occurs in two variants:</p>
<ul>
<li>Sometimes, we want to explicitly name a base class for use as an interface, <ul>
<li>for example, to resolve an ambiguity or to call a specific function without relying on the virtual function mechanism (an explicitly qualified call; §21.3.3).</li>
</ul>
</li>
<li>Sometimes, we want to obtain a pointer to a subobject of a hierarchy given a pointer to another, <ul>
<li>for example, to get a pointer to the complete derived class object from a pointer to a base (a downcast; §22.2.1) or to get a pointer to a base class object from a pointer to another base (a crosscast; §22.2.4).</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="17">
<li><p>Here, we consider how to navigate a class hierarchy using type conversions (casts) to gain a pointer of the desired type. </p>
<p>To illustrate the mechanisms available and the rules that guide them, consider a lattice containing both a replicated base and a virtual base:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span><br>    : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Storable &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span><br>    : <span class="hljs-keyword">public</span> Component &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transmitter</span><br>    : <span class="hljs-keyword">public</span> Component &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Radio</span><br>    : <span class="hljs-keyword">public</span> Receiver, <span class="hljs-keyword">public</span> Transmitter &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>or graphically:</p>
<p><img src="image-20230207185954370.png" srcset="/img/loading.gif" lazyload alt="image-20230207185954370"></p>
<ul>
<li><p>Here, a <code>Radio</code> object has two subobjects of class <code>Component</code>. </p>
</li>
<li><p>Consequently, a <code>dynamic_cast</code> from <code>Storable</code> to <code>Component</code> within a <code>Radio</code> will be ambiguous and return a <code>0</code>. </p>
</li>
<li><p>There is simply no way of knowing which <code>Component</code> the programmer wanted:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h1</span><span class="hljs-params">(Radio&amp; r)</span></span><br><span class="hljs-function"></span>&#123;<br>    Storable∗ ps = &amp;r; <span class="hljs-comment">// a Radio has a unique Storable; pc is valid</span><br>    <span class="hljs-comment">// ...</span><br>    Component∗ pc = <span class="hljs-built_in">dynamic_cast</span>&lt;Component∗&gt;(ps); <span class="hljs-comment">// pc = 0(nullptr); a Radio has two Components</span><br>    <span class="hljs-comment">// ...											</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>In general – and typically – a programmer (and a compiler looking at a single translation unit) does not know the complete class lattice. </p>
<p>Instead, <strong>code is written with the knowledge of some sublattice</strong>.</p>
<ul>
<li><p>For example, a programmer might know only about the <code>Transmitter</code> part of a <code>Radio</code> and write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h2</span><span class="hljs-params">(Storable∗ ps)</span> <span class="hljs-comment">//ps might or might not point to a Component</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Component∗ pc = <span class="hljs-built_in">dynamic_cast</span>&lt;Component∗&gt;(ps)) &#123;<br>        <span class="hljs-comment">// we have a component!</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// it wasn’t a Component</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The ambiguity for a pointer to a Radio object is not in general detectable at compile time.</p>
</li>
</ul>
<p><strong>This kind of run-time ambiguity detection is needed only for virtual bases</strong>. </p>
<ul>
<li>For ordinary bases, there is always a unique subobject of a given cast (or none) when downcasting (that is, toward a derived class; §22.2). </li>
</ul>
<p><strong>The equivalent ambiguity for virtual bases occurs when upcasting</strong> (that is, toward a base), but such ambiguities are caught at compile time.</p>
</li>
</ol>
<h4 id="22-2-3-static-cast-and-dynamic-cast"><a href="#22-2-3-static-cast-and-dynamic-cast" class="headerlink" title="22.2.3 static_cast and dynamic_cast"></a>22.2.3 <code>static_cast</code> and <code>dynamic_cast</code></h4><ol start="18">
<li><p>A <code>dynamic_cast</code> can cast from a polymorphic virtual base class to a derived class or a sibling class (§22.2.1). </p>
<p><strong>A <code>static_cast</code> (§11.5.2) does not examine the object it casts from</strong>, so it cannot:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Radio&amp; r)</span></span><br><span class="hljs-function"></span>&#123;<br>    Receiver∗ prec = &amp;r; <span class="hljs-comment">// Receiver is an ordinary base of Radio</span><br>    Radio∗ pr = <span class="hljs-built_in">static_cast</span>&lt;Radio∗&gt;(prec); <span class="hljs-comment">// OK, unchecked</span><br>    pr = <span class="hljs-built_in">dynamic_cast</span>&lt;Radio∗&gt;(prec); <span class="hljs-comment">// OK, run-time checked</span><br>    <br>    Storable∗ ps = &amp;r; <span class="hljs-comment">// Storable is a virtual base of Radio</span><br>    pr = <span class="hljs-built_in">static_cast</span>&lt;Radio∗&gt;(ps); <span class="hljs-comment">// error : cannot cast from virtual base</span><br>    pr = <span class="hljs-built_in">dynamic_cast</span>&lt;Radio∗&gt;(ps); <span class="hljs-comment">// OK, run-time checked</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="19">
<li><p>The <code>dynamic_cast</code> requires a polymorphic operand because there is no information stored in a nonpolymorphic object that can be used to find the objects for which it represents a base. </p>
<p>In particular, an object of a type with layout constraints determined by some other language – such as Fortran or C – may be used as a virtual base class. </p>
<ul>
<li>For objects of such types, only static type information will be available. </li>
</ul>
<p>However, the information needed to provide run-time type identification includes the information needed to implement the <code>dynamic_cast</code>.</p>
</li>
</ol>
<ol start="20">
<li><p>Why would anyone want to use a <code>static_cast</code> for class hierarchy navigation? </p>
<ul>
<li><p>There is a run-time cost associated with the use of a <code>dynamic_cast</code> (§22.2.1). </p>
</li>
<li><p>More significantly, there are millions of lines of code that were written before <code>dynamic_cast</code> became available. </p>
</li>
</ul>
<p>This code(<code>static_cast</code>) relies on alternative ways of making sure that a cast is valid, so the checking done by <code>dynamic_cast</code> is seen as redundant. </p>
<p>However, such code is typically written using the C-style cast (§11.5.3); often obscure errors remain. </p>
<p>Where possible, use the safer <code>dynamic_cast</code>.</p>
</li>
</ol>
<ol start="21">
<li><p>The compiler cannot assume anything about the memory pointed to by a <code>void∗</code>. </p>
<ul>
<li>This implies that <code>dynamic_cast</code> – which must look into an object to determine its type – cannot cast from a <code>void∗</code>.</li>
</ul>
<p>For that, a <code>static_cast</code> is needed. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Radio∗ <span class="hljs-built_in">f1</span>(<span class="hljs-type">void</span>∗ p)<br>&#123;<br>    Storable∗ ps = <span class="hljs-built_in">static_cast</span>&lt;Storable∗&gt;(p); <span class="hljs-comment">// trust the programmer</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dynamic_cast</span>&lt;Radio∗&gt;(ps);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="22">
<li><p>Both <code>dynamic_cast</code> and <code>static_cast</code> respect <code>const</code> and access controls.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Users</span> : <span class="hljs-keyword">private</span> set&lt;Person&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(Users∗ pu, <span class="hljs-type">const</span> Receiver∗ pcr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static_cast</span>&lt;set&lt;Person&gt;∗&gt;(pu); <span class="hljs-comment">//error : access violation</span><br>    <span class="hljs-keyword">dynamic_cast</span>&lt;set&lt;Person&gt;∗&gt;(pu); <span class="hljs-comment">// error : access violation</span><br>    <br>    <span class="hljs-built_in">static_cast</span>&lt;Receiver∗&gt;(pcr); <span class="hljs-comment">//error : can’t cast away const</span><br>    <span class="hljs-built_in">dynamic_cast</span>&lt;Receiver∗&gt;(pcr); <span class="hljs-comment">//error : can’t cast away const</span><br>    <br>    Receiver∗ pr = <span class="hljs-built_in">const_cast</span>&lt;Receiver∗&gt;(pcr); <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>It is not possible to cast to a private base class using <code>static_cast</code> or <code>reinterpret_cast</code>, and ‘‘casting away <code>const</code>’’ (or <code>volatile</code>) requires a <code>const_cast</code></strong> (§11.5.2). </p>
<ul>
<li>Even then, using the result is safe only provided the object wasn’t originally declared <code>const</code> (or <code>volatile</code>) (§16.2.9).</li>
</ul>
</li>
</ol>
<h4 id="22-2-4-Recovering-an-Interface"><a href="#22-2-4-Recovering-an-Interface" class="headerlink" title="22.2.4 Recovering an Interface"></a>22.2.4 Recovering an Interface</h4><ol start="23">
<li><p><strong>From a design perspective, <code>dynamic_cast</code> (§22.2.1) can be seen as a mechanism for asking an object if it provides a given interface.</strong></p>
<p>As an example, consider a simple object I/O system. </p>
<ul>
<li><p>Users want to read objects from a stream, determine that they are of the expected types, and then use them. </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ... open file assumed to hold shapes, and attach ss as an istream for that file ...</span><br>    unique_ptr&lt;Io_obj&gt; p &#123;<span class="hljs-built_in">get_obj</span>(ss)&#125;; <span class="hljs-comment">// read object from stream</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sp = <span class="hljs-built_in">dynamic_cast</span>&lt;Shape∗&gt;(p.<span class="hljs-built_in">get</span>())) &#123;<br>        sp−&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// use the Shape</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// oops: non-shape in Shape file</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The function <code>user()</code> deals with shapes exclusively through the abstract class <code>Shape</code> and can therefore use every kind of shape. </p>
</li>
<li><p>The use of <code>dynamic_cast</code> is essential because the object I/O system can deal with many other kinds of objects, and the user may accidentally have opened a file containing perfectly good objects of classes that the user has never heard of.</p>
</li>
<li><p>I used <code>unique_ptr&lt;Io_obj&gt;</code> (§5.2.1, §34.3.1) so that I would not forget to delete the object allocated by <code>get_obj()</code>.</p>
</li>
</ul>
<p>This object I/O system assumes that every object read or written is of a class derived from <code>Io_obj</code>. </p>
<ul>
<li><p>Class <code>Io_obj</code> must be a polymorphic type to allow the user of <code>get_obj()</code> to use <code>dynamic_cast</code> to recover the ‘‘true type’’ of a returned object. </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Io_obj</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> Io_obj∗ <span class="hljs-built_in">clone</span>() <span class="hljs-type">const</span> =<span class="hljs-number">0</span>; <span class="hljs-comment">// polymorphic</span><br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">Io_obj</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>The critical function in the object I/O system is <code>get_obj()</code>, which reads data from an <code>istream</code> and creates class objects based on that data. </p>
<ul>
<li><p>Assume that the data representing an object on an input stream is prefixed by a string identifying the object’s class. </p>
</li>
<li><p>The job of <code>get_obj()</code> is to read that string and call a function capable of reading and creating an object of the right class. </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> Pf = Io_obj∗(istream&amp;); <span class="hljs-comment">// pointer to function returning an Io_obj*</span><br><br>map&lt;string,Pf&gt; io_map; <span class="hljs-comment">// maps strings to creation functions</span><br><br><span class="hljs-function">string <span class="hljs-title">get_word</span><span class="hljs-params">(istream&amp; is)</span></span>; <span class="hljs-comment">// read a word from is; throw Read_error if the read failed</span><br><br>Io_obj∗ <span class="hljs-built_in">get_obj</span>(istream&amp; is)<br>&#123;<br>    string str = <span class="hljs-built_in">get_word</span>(is); <span class="hljs-comment">// read initial word (prefix used to identify the object&#x27;s class)</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> f = io_map[str]) <span class="hljs-comment">// look up str to get function</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(is); <span class="hljs-comment">// call function</span><br>    <span class="hljs-keyword">throw</span> Unknown_class&#123;&#125;; <span class="hljs-comment">// no match for str</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The map called <code>io_map</code> holds pairs of name strings and functions that can construct objects of the class with that name.</li>
</ul>
</li>
</ul>
<p>We could derive class <code>Shape</code> from <code>Io_obj</code> as needed by <code>user()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> : <span class="hljs-keyword">public</span> Io_obj &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>However, it would be more interesting (and in many cases more realistic) to use an already defined <code>Shape</code> (§3.2.4) unchanged:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Io_circle</span> : Circle, Io_obj &#123;<br>    <span class="hljs-built_in">Io_circle</span>(istream&amp;); <span class="hljs-comment">// initialize from input stream</span><br>    Io_circle∗ <span class="hljs-built_in">clone</span>() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Io_circle&#123;∗<span class="hljs-keyword">this</span>&#125;; &#125; <span class="hljs-comment">// use copy constructor</span><br>    <span class="hljs-type">static</span> Io_obj∗ <span class="hljs-built_in">new_circle</span>(istream&amp; is) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Io_circle&#123;is&#125;; &#125; <span class="hljs-comment">// for io_map</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>This is an example of how a class can be fitted into a hierarchy using an abstract class with less foresight than would have been required to build it as a node class in the first place (§21.2.2).</p>
</li>
<li><p>The <code>Io_circle(istream&amp;)</code> constructor initializes an object with data from its <code>istream</code> argument. </p>
</li>
<li><p>The <code>new_circle()</code> function is the one put into the <code>io_map</code> to make the class known to the object I/O system.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">io_map[<span class="hljs-string">&quot;Io_circle&quot;</span>]=&amp;Io_circle::new_circle; <span class="hljs-comment">// somewhere</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Other shapes are constructed in the same way:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Io_triangle</span> : <span class="hljs-keyword">public</span> Triangle , <span class="hljs-keyword">public</span> Io_obj &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br>io_map[<span class="hljs-string">&quot;Io_triangle&quot;</span>]=&amp;Io_circle::new_triangle; <span class="hljs-comment">// somewhere</span><br></code></pre></td></tr></table></figure></li>
<li><p>If the provision of the object I/O scaffolding becomes tedious, a template might help:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Io</span> : T, Io_obj &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Io</span>(istream&amp;); <span class="hljs-comment">// initialize from input stream</span><br>    Io∗ <span class="hljs-built_in">clone</span>() <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Io&#123;∗<span class="hljs-keyword">this</span>&#125;; &#125;<br>    <span class="hljs-type">static</span> Io∗ <span class="hljs-built_in">new_io</span>(istream&amp; is) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Io&#123;is&#125;; &#125; <span class="hljs-comment">// for io_map</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>Given this, we can define <code>Io_circle</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> Io_circle = Io&lt;Circle&gt;;<br></code></pre></td></tr></table></figure></li>
<li><p>We still need to define <code>Io&lt;Circle&gt;::Io(istream&amp;)</code> explicitly, though, because it needs to know about the details of <code>Circle</code>. </p>
<ul>
<li>Note that <code>Io&lt;Circle&gt;::Io(istream&amp;)</code> does not have access to <code>T</code>’s private or protected data. </li>
</ul>
<p>The idea is that the transmission format for a type <code>X</code> is what is needed to construct an <code>X</code> using one of <code>X</code>’s constructors.</p>
<ul>
<li>The information of the stream is not necessarily the sequence of <code>X</code>’s member values.</li>
</ul>
</li>
<li><p>The <code>Io</code> template is an example of a way to fit concrete types into a class hierarchy by providing a handle that is a node in that hierarchy. </p>
<ul>
<li><p>It derives from its template parameter to allow casting from <code>Io_obj</code>. </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(io&lt;Shape&gt;&amp; ios)</span></span><br><span class="hljs-function"></span>&#123;<br>    Shape∗ ps = &amp;ios;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Unfortunately, deriving from the template argument precludes using <code>Io</code> for a built-in type:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> Io_date = Io&lt;Date&gt;; <span class="hljs-comment">// wrap concrete type</span><br><span class="hljs-keyword">using</span> Io_int = Io&lt;<span class="hljs-type">int</span>&gt;; <span class="hljs-comment">// error : cannot derive from built-in type</span><br></code></pre></td></tr></table></figure></li>
<li><p>This problem can be handled by making the user’s object a member of <code>Io_obj</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Io</span> :Io_obj &#123;<br>    T val;<br>    <br>    <span class="hljs-built_in">Io</span>(istream&amp;); <span class="hljs-comment">//initialize from input stream</span><br>    Io∗ <span class="hljs-built_in">clone</span>() <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Io&#123;∗<span class="hljs-keyword">this</span>&#125;; &#125;<br>    <span class="hljs-type">static</span> Io∗ <span class="hljs-built_in">new_io</span>(istream&amp; is) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Io&#123;is&#125;; &#125; <span class="hljs-comment">// for io_map</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>Now we can handle</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> Io_int = Io&lt;<span class="hljs-type">int</span>&gt;; <span class="hljs-comment">// wrap built-in type</span><br></code></pre></td></tr></table></figure></li>
<li><p>Having made the value a member rather than a base, we can no longer directly cast an <code>Io_obj&lt;X&gt;</code> to an <code>X</code>, so we provide a function to do that:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T∗ <span class="hljs-built_in">get_val</span>&lt;T&gt;(Io_obj∗ p)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> pp = <span class="hljs-keyword">dynamic_cast</span>&lt;Io&lt;T&gt;∗&gt;(p))<br>        <span class="hljs-keyword">return</span> &amp;pp−&gt;val;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The <code>user()</code> function now becomes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ... open file assumed to hold shapes, and attach ss as an istream for that file ...</span><br>    <br>    unique_ptr&lt;Io_obj&gt; p &#123;<span class="hljs-built_in">get_obj</span>(ss)&#125;; <span class="hljs-comment">// read object from stream</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sp = <span class="hljs-built_in">get_val</span>&lt;Shape&gt;(p.g <span class="hljs-built_in">et</span>())) &#123;<br>        sp−&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// use the Shape</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ... oops: cope with non-shape in Shape file ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="24">
<li><p>This simple object I/O system does not do everything anyone ever wanted, but it almost fits on a single page and the key mechanisms have many uses. </p>
<p>It is a blueprint for the ‘‘receiver end’’ of a system for transmitting arbitrary objects across a communication channel in a type-safe manner.</p>
<p>More generally, these techniques can be used to invoke a function based on a string supplied by a user and to manipulate objects of unknown type through interfaces discovered through run-time type identification.</p>
</li>
</ol>
<ol start="25">
<li><p>In general, the sender part of such an object I/O system will also use RTTI. </p>
<p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Face</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    Shape∗ outline;<br>    array&lt;Shape∗&gt; eyes;<br>    Shape∗ mouth;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>To correctly write out the <code>Shape</code> pointed to by outline, we need to figure out which kind of <code>Shape</code> it is. <ul>
<li>That’s a job for <code>typeid()</code> (§22.5). </li>
</ul>
</li>
<li>In general, we must also keep a table of (pointer,unique identifier) pairs to be able to transmit linked data structures and to avoid duplicating objects pointed to by more than one pointer (or reference).</li>
</ul>
</li>
</ol>
<h3 id="22-3-Double-Dispatch-and-Visitors"><a href="#22-3-Double-Dispatch-and-Visitors" class="headerlink" title="22.3 Double Dispatch and Visitors"></a>22.3 Double Dispatch and Visitors</h3><ol start="26">
<li><p>Classical object-oriented programming is based on selecting a virtual function based on the dynamic type (the type of the most derived class) of an object given only a pointer or a reference to an interface (a base class). </p>
<p>In particular, C++ can do this run-time lookup (also called a <em><strong>dynamic dispatch</strong></em>) for one type at a time. </p>
<ul>
<li>In this, C++ resembles Simula and Smalltalk and more recent languages, such as Java and C#. </li>
</ul>
<p>Not being able to select a function based on two dynamic types can be a serious limitation. </p>
<p>Also, a virtual function must be a member function. </p>
<ul>
<li><p>This implies that we cannot add a virtual function to a class hierarchy without modifying the base class(es) that provides<br>the interface and all derived classes that should be affected. </p>
</li>
<li><p>This too can be a serious problem.</p>
</li>
</ul>
<p>This section describes the basic workarounds for these problems:</p>
<ul>
<li><em><strong>Double Dispatch</strong></em> shows how to select a virtual function based on two types.</li>
<li><em><strong>Visitors</strong></em> shows how to use double dispatch to add multiple functions to a class hierarchy with only a single additional virtual function in the hierarchy.</li>
</ul>
</li>
</ol>
<ol start="27">
<li><p>Most realistic examples of these techniques occur when we deal with data structures, such as vectors or graphs or pointers to objects of polymorphic types. </p>
<p>In such cases, the actual type of an object (e.g., a vector element or a graph node) can only be known dynamically by (implicitly or explicitly) inspecting the interface provided by a base class.</p>
</li>
</ol>
<h4 id="22-3-1-Double-Dispatch"><a href="#22-3-1-Double-Dispatch" class="headerlink" title="22.3.1 Double Dispatch"></a>22.3.1 Double Dispatch</h4><ol start="28">
<li><p>Consider how to select a function based on two arguments. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_someting</span><span class="hljs-params">(Shape&amp; s1, Shape&amp; s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">intersect</span>(s2)) &#123;<br>        <span class="hljs-comment">// the two shapes overlap</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>We would like this to work for any two classes in the class hierarchy rooted in <code>Shape</code>, such as <code>Circle</code> and <code>Triangle</code>.</p>
</li>
<li><p>The basic strategy is to do a virtual function call to select the right function for <code>s1</code> and then do a second call to select the right function for <code>s2</code>. </p>
</li>
<li><p>To simplify, I will leave out the calculation of whether the two shapes actually intersect and just write the code skeleton for selecting the right functions. </p>
</li>
<li><p>First we define <code>Shape</code> with a function for intersection:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp;)</span> <span class="hljs-type">const</span> </span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Circle&amp;)</span> <span class="hljs-type">const</span> </span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Triangle&amp;)</span> <span class="hljs-type">const</span> </span>=<span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>Next we need to define <code>Circle</code> and <code>Triangle</code> to override those virtual functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Circle&amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Triangle&amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">&#125;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Circle&amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Triangle&amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>Now each class can handle all possible classes in the <code>Shape</code> hierarchy, so we just have to decide what should be done for each combination:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Circle::intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; s)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">intersect</span>(∗<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Circle::intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Circle&amp;)</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt;<span class="hljs-string">&quot;intersect(circle,circle)\n&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Circle::intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Triangle&amp;)</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt;<span class="hljs-string">&quot;intersect(circle,triangle)\n&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Triangle::intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; s)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">intersect</span>(∗<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Triangle::intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Circle&amp;)</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt;<span class="hljs-string">&quot;intersect(triangle ,circle)\n&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Triangle::intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Triangle&amp;)</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt;<span class="hljs-string">&quot;intersect(triangle ,triangle)\n&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The interesting functions here are <code>Circle::intersect(const Shape&amp;)</code> and <code>Triangle::intersect(const Shape&amp;)</code>.<ul>
<li>These need to handle a <code>Shape&amp;</code> argument because that argument must refer to a derived class. </li>
<li>The trick/technique is to simply do a virtual call with the arguments in the reverse order.</li>
</ul>
</li>
<li>That done, we are in one of the four functions that can actually do an intersection calculation.</li>
</ul>
</li>
<li><p>We can test this by making a vector of all pairs of <code>Shape∗</code> values and calling <code>intersect()</code> for those:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Triangle&amp; t, Circle&amp; c)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;pair&lt;Shape∗,Shape∗&gt;&gt; vs &#123; &#123;&amp;t,&amp;t&#125;, &#123;&amp;t,&amp;c&#125;, &#123;&amp;c,&amp;t&#125;, &#123;&amp;c,&amp;c&#125; &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : vs)<br>        p.first−&gt;<span class="hljs-built_in">intersect</span>(∗p.second);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Using <code>Shape∗</code>s ensures that we rely on run-time resolution of the types. </li>
</ul>
</li>
<li><p>We get:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">intersect(triangle ,triangle)<br>intersect(triangle ,circle)<br>intersect(circle,triangle)<br>intersect(circle,circle)<br></code></pre></td></tr></table></figure>

<ul>
<li>If you consider this elegant, you need to raise your standards, but it gets the task done. </li>
</ul>
</li>
<li><p>As the class hierarchy grows, the need for virtual functions grows exponentially. </p>
<ul>
<li>That is not acceptable in most cases. </li>
<li>Expanding this to three or more arguments is trivial, but tedious. </li>
<li>Worst of all, each new operation and each new derived class require a modification to every class in the hierarchy: this double-dispatch technique is highly intrusive. </li>
</ul>
</li>
<li><p>Ideally, I would have preferred a simple <code>intercept(Shape&amp;,Shape&amp;)</code> function with overriders specified for the desired combinations of particular shapes. That is possible [Pirkelbauer,2009], but not in C++11.</p>
</li>
</ul>
</li>
</ol>
<ol start="29">
<li><p>The awkwardness of double dispatch does not make the problem it is trying to address less important. </p>
<p>It is not unusual to want an action, such as <code>intersect(x,y)</code>, that depends on the types of two (or more) operands. Workarounds abound. </p>
<ul>
<li><p>For example, finding the intersection of rectangles is simple and efficient. </p>
</li>
<li><p>So, for many applications, people have found it sufficient to define a ‘‘bounding box’’ for each shape and then calculate intersections on bounding boxes. </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Rectangle <span class="hljs-title">box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// the rectangle encloses the shape</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Rectangle <span class="hljs-title">box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Rectangle <span class="hljs-title">box</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Rectangle&amp;, <span class="hljs-type">const</span> Rectangle&amp;)</span></span>; <span class="hljs-comment">// simple to calculate</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; s1, <span class="hljs-type">const</span> Shape&amp; s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(s1.<span class="hljs-built_in">box</span>(),s2.<span class="hljs-built_in">box</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Another technique is to precompute a lookup table for combinations of types [Stroustrup,1994]:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; s1, <span class="hljs-type">const</span> Shape&amp; s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">index</span>(<span class="hljs-built_in">type_id</span>(s1),<span class="hljs-built_in">type_id</span>(s2));<br>    <span class="hljs-keyword">return</span> intersect_tbl[i](s1,s2);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Variations of this idea are widely used. </li>
<li>Many variants use precomputed values stored in objects to speed up type identification (§27.4.2).</li>
</ul>
</li>
</ol>
<h4 id="22-3-2-Visitors"><a href="#22-3-2-Visitors" class="headerlink" title="22.3.2 Visitors"></a>22.3.2 Visitors</h4><ol start="30">
<li>The <strong>visitor pattern</strong> [Gamma,1994] is a partial solution to the exponential growth of virtual functions and overriders and the unpleasent intrusiveness of the (too) simple double-dispatch technique.</li>
</ol>
<ol start="31">
<li><p>Consider how to apply two (or more) operations to every class in a class hierarchy. </p>
<p>Basically, we will do a double dispatch for a hierarchy of nodes and a hierarchy of operations to select the correct operation for the correct node. </p>
<p>The operations are called <em><strong>visitors</strong></em>; here they are defined in classes derived from class <code>Visitor</code>. </p>
<ul>
<li><p>The nodes are a hierarchy of classes with a virtual function <code>accept()</code> that takes <code>Visitor&amp;</code>s. </p>
</li>
<li><p>For this example, I use a hierarchy of <code>Node</code>s that describe language constructs, as is common in tools based on abstract syntax trees (ASTs):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor&amp;)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Expr</span> : <span class="hljs-keyword">public</span> Node &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor&amp;)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stmt</span> : <span class="hljs-keyword">public</span> Node &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor&amp;)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>So far, so good: <strong>the <code>Node</code> hierarchy simply provides a virtual function <code>accept()</code> that takes a <code>Visitor&amp;</code> argument representing what should be done to a <code>Node</code> of a given type</strong>.</li>
<li>I do not use <code>const</code> here, because in general an operation from a <code>Visitor</code> may update either the <code>Node</code> ‘‘visited’’ or the <code>Visitor</code> itself.</li>
</ul>
</li>
<li><p><strong>Now the <code>Node</code>’s <code>accept()</code> performs the double-dispatch trick and passes the <code>Node</code> itself to the <code>Visitor</code>’s <code>accept()</code>:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Expr::accept</span><span class="hljs-params">(Visitor&amp; v)</span> </span>&#123; v.<span class="hljs-built_in">accept</span>(∗<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stmt::accept</span><span class="hljs-params">(Visitor&amp; v)</span> </span>&#123; v.<span class="hljs-built_in">accept</span>(∗<span class="hljs-keyword">this</span>); &#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>The <code>Visitor</code> declares a set of operations:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Expr&amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Stmt&amp;)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>We can then define sets of operations by deriving from <code>Visitor</code> and overriding its <code>accept()</code> functions.</strong></p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Do1_visitor</span> : <span class="hljs-keyword">public</span> Visitor &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Expr&amp;)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;do1 to Expr\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Stmt&amp;)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;do1 to Stmt\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Do2_visitor</span> : <span class="hljs-keyword">public</span> Visitor &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Expr&amp;)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;do2 to Expr\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Stmt&amp;)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;do2 to Stmt\n&quot;</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>We can test by making a vector of pairs of pointers to ensure that run-time type resolution is used:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Expr&amp; e, Stmt&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;pair&lt;Node∗,Visitor∗&gt;&gt; vn &#123;&amp;e,&amp;do1&#125;, &#123;&amp;s,&amp;do1&#125;, &#123;&amp;e,&amp;do2&#125;, &#123;&amp;s,&amp;do2&#125;&#125;;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : vn)<br>    	p.first−&gt;<span class="hljs-built_in">accept</span>(∗p.second);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>We  get:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">do1 to Expr<br>do1 to Stmt<br>do2 to Expr<br>do2 to Stmt<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="32">
<li><p>As opposed to the simple double dispatch, the visitor pattern is heavily used in real-world programming.</p>
<p>It is only mildly intrusive (the <code>accept()</code> function), and many variations on the basic idea are used. </p>
<p>However, many operations on class hierarchies are hard to express as visitors. </p>
<ul>
<li>For example, an operation that needs access to multiple nodes of different types in a graph cannot be trivially implemented as a visitor. </li>
</ul>
<p>So, I consider the visitor pattern an inelegant workaround. </p>
<ul>
<li>Alternatives exist, for example, [Solodkyy,2012], but not in plain C++11.</li>
</ul>
</li>
</ol>
<ol start="33">
<li><p>Most alternatives to visitors in C++ are based on the idea of explicit iteration over a homogeneous data structure (e.g., a vector or a graph of nodes containing pointers to polymorphic types).</p>
<p>At each element or node, a call of a virtual function can perform the desired operation, or some optimization based on stored data can be applied (e.g., see §27.4.2).</p>
</li>
</ol>
<h3 id="22-4-Construction-and-Destruction"><a href="#22-4-Construction-and-Destruction" class="headerlink" title="22.4 Construction and Destruction"></a>22.4 Construction and Destruction</h3><ol start="34">
<li><p>A class object is more than simply a region of memory (§6.4). </p>
<p>A class object is built from ‘‘raw memory’’ by its constructors, and it reverts to ‘‘raw memory’’ as its destructors are executed.</p>
<p>Construction is bottom-up, destruction is top-down, and a class object is an object to the extent that it has been constructed or destroyed. </p>
<ul>
<li><p>This order is necessary to ensure that an object is not accessed before it has been initialized. </p>
</li>
<li><p>It is unwise to try to access base and member objects early or out of order through ‘‘clever’’ pointer manipulation (§17.2.3).</p>
</li>
<li><p>The order of construction and destruction is reflected in the rules for RTTI, exception handling (§13.3), and virtual functions (§20.3.2).</p>
</li>
</ul>
</li>
</ol>
<ol start="35">
<li><p>It is unwise to rely on details of the order of construction and destruction, but you can observe that order by calling virtual functions, <code>dynamic_cast</code> (§22.2), or <code>typeid</code> (§22.5) at a point where the object isn’t complete. </p>
<p>At such a point in a constructor, the (dynamic) type of the object reflects only what is constructed so far. </p>
<ul>
<li><p>For example, if the constructor for <code>Component</code> in the hierarchy from §22.2.2 calls a virtual function, it will invoke a version defined for <code>Storable</code> or <code>Component</code>, but not one from <code>Receiver</code>, <code>Transmitter</code>, or <code>Radio</code>. </p>
</li>
<li><p>At that point of construction, the object isn’t yet a <code>Radio</code>. </p>
</li>
</ul>
<p>Similarly, calling a virtual function from a destructor will reflect only what is still not destroyed. </p>
<p>It is best to avoid calling virtual functions during construction and destruction.</p>
</li>
</ol>
<h3 id="22-5-Type-Identification"><a href="#22-5-Type-Identification" class="headerlink" title="22.5 Type Identification"></a>22.5 Type Identification</h3><ol start="36">
<li><p>The <code>dynamic_cast</code> operator serves most needs for information about the type of an object at run time. </p>
<p>Importantly, it ensures that code written using it works correctly with classes derived from those explicitly mentioned by the programmer. </p>
<p>Thus, <code>dynamic_cast</code> preserves flexibility and extensibility in a manner similar to virtual functions.</p>
</li>
</ol>
<ol start="37">
<li><p>However, it is occasionally essential to know the exact type of an object. </p>
<ul>
<li>For example, we might like to know the name of the object’s class or its layout. </li>
</ul>
<p>The <code>typeid</code> operator serves this purpose by yielding an object representing the type of its operand. </p>
<p>Had <code>typeid()</code> been a function, its declaration would have looked something like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">type_info</span>;<br><span class="hljs-function"><span class="hljs-type">const</span> type_info&amp; <span class="hljs-title">typeid</span><span class="hljs-params">(expression)</span></span>; <span class="hljs-comment">// pseudo declaration</span><br></code></pre></td></tr></table></figure>

<p>That is, <code>typeid()</code> returns a reference to a standard-library type called <code>type_info</code> defined in <code>&lt;typeinfo&gt;</code>:</p>
<ul>
<li>Given the name of a type as its operand, <code>typeid(type_name)</code> returns a reference to a <code>type_info</code> that represents the <code>type_name</code>; <code>type_name</code> must be a completely defined type (§8.2.2).</li>
<li>Given an expression as its operand, <code>typeid(expr)</code> returns a reference to a <code>type_info</code> that represents the type of the object denoted by the <code>expr</code>; the <code>expr</code> must refer to a completely defined type (§8.2.2). <ul>
<li>If the value of expr is <code>nullptr</code>, <code>typeid(expr)</code> throws a <code>std::bad_typeid</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="38">
<li><p>A <code>typeid()</code> can find the type of an object referred to by a reference or a pointer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Shape&amp; r, Shape∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">typeid</span>(r); <span class="hljs-comment">// type of the object referred to by r</span><br>    <span class="hljs-built_in">typeid</span>(∗p); <span class="hljs-comment">// type of the object pointed to by p</span><br>    <span class="hljs-built_in">typeid</span>(p); <span class="hljs-comment">// type of the pointer, that is, Shape* (uncommon, except as a mistake)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>If the operand of <code>typeid()</code> is a pointer or a reference of a polymorphic type with the value <code>nullptr</code>, <code>typeid()</code> throws a <code>std::bad_typeid</code>. </p>
<p>If the operand of <code>typeid()</code> has a nonpolymorphic type or is not an lvalue, the result is determined at compile time without evaluating the operand expression.</p>
</li>
</ol>
<ol start="39">
<li><p>If the object denoted by a dereferenced pointer or a reference to a polymorphic type, the <code>type_info</code> returned is that of the most derived class for the object, that is, the type used when the object was defined. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Poly</span> &#123; <span class="hljs-comment">// polymorphic base class</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Non_poly</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// no virtual functions</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D1</span><br>    : Poly &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D2</span><br>    : Non_poly &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Non_poly&amp; npr, Poly&amp; pr)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">typeid</span>(npr).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// writes something like &quot;Non_poly&quot;</span><br>    cout &lt;&lt; <span class="hljs-built_in">typeid</span>(pr).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// name of Poly or a class derived from Poly</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D1 d1;<br>    D2 d2;<br>    <span class="hljs-built_in">f</span>(d2,d1); <span class="hljs-comment">// writes &quot;Non_poly D1&quot;</span><br>    <span class="hljs-built_in">f</span>(∗<span class="hljs-built_in">static_cast</span>&lt;Poly∗&gt;(<span class="hljs-literal">nullptr</span>),∗<span class="hljs-built_in">static_cast</span>&lt;Null_poly∗&gt;(<span class="hljs-literal">nullptr</span>)); <span class="hljs-comment">// oops!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>That last call will print just <code>Non_poly</code> (because <code>typeid(npr)</code> is not evaluated) before throwing a <code>bad_typeid</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="40">
<li><p>The definition of <code>type_info</code> looks like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">type_info</span> &#123;<br>    <span class="hljs-comment">// data</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ˜<span class="hljs-built_in">type_info</span>(); <span class="hljs-comment">//is polymorphic</span><br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> type_info&amp;) <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// can be compared</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> type_info&amp;) <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">before</span><span class="hljs-params">(<span class="hljs-type">const</span> type_info&amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// ordering</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hash_code</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// for use by unordered_map and the like</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ <span class="hljs-built_in">name</span>() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// name of type</span><br>    <br>    <span class="hljs-built_in">type_info</span>(<span class="hljs-type">const</span> type_info&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// prevent copying</span><br>    type_info&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> type_info&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// prevent copying</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>before()</code> function allows <code>type_info</code>s to be sorted. <ul>
<li>In particular, it allows <code>type_id</code>s to be used as keys for ordered containers (such as <code>map</code>). </li>
</ul>
</li>
<li>There is no relation between the relationships defined by before and inheritance relationships. </li>
<li>The <code>hash_code()</code> function allows <code>type_id</code>s be used as keys for hash tables (such as <code>unordered_map</code>).</li>
</ul>
</li>
</ol>
<ol start="41">
<li><p>It is not guaranteed that there is only one <code>type_info</code> object for each type in the system. </p>
<p>In fact, where dynamically linked libraries are used, it can be hard for an implementation to avoid duplicate <code>type_info</code> objects. </p>
<p>Consequently, <strong>we should use <code>==</code> on <code>type_info</code> objects to test equality, rather than <code>==</code> on pointers to such objects</strong>.</p>
</li>
</ol>
<ol start="42">
<li><p>We sometimes want to know the exact type of an object so as to perform some service on the whole object (and not just on one of its bases). </p>
<ul>
<li><p>Ideally, such services are presented as virtual functions so that the exact type needn’t be known. </p>
</li>
<li><p>In some cases, no common interface can be assumed for every object manipulated, so the detour through the exact type becomes necessary (§22.5.1).</p>
</li>
</ul>
<p>Another, much simpler use has been to obtain the name of a class for diagnostic output:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Component∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">typeid</span>(∗p).<span class="hljs-built_in">name</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The character representation of a class’s name is implementation-defined. </li>
<li>This C-style string resides in memory owned by the system, so the programmer should not attempt to <code>delete[]</code> it.</li>
</ul>
</li>
</ol>
<h4 id="22-5-1-Extended-Type-Information"><a href="#22-5-1-Extended-Type-Information" class="headerlink" title="22.5.1 Extended Type Information"></a>22.5.1 Extended Type Information</h4><ol start="43">
<li><p>A <code>type_info</code> object contains only minimal information. </p>
<p>Therefore, finding the exact type of an object is often just the first step to acquiring and using more detailed information about that type.</p>
</li>
</ol>
<ol start="44">
<li><p>Consider how an implementation or a tool could make information about types available to users at run time. </p>
<p>Suppose I have a tool that generates descriptions of object layouts for each class used. </p>
<p>I can put these descriptors into a <code>map</code> to allow user code to find the layout information:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br>map&lt;string, Layout&gt; layout_table;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    Layout&amp; x = layout_table[<span class="hljs-built_in">typeid</span>(∗p).<span class="hljs-built_in">name</span>()]; <span class="hljs-comment">// find the Layout based on *p’s name</span><br>    <span class="hljs-comment">// ... use x ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The resulting data structure looks like this:</p>
<p><img src="image-20230209164220571.png" srcset="/img/loading.gif" lazyload alt="image-20230209164220571"></p>
<p>Someone else might provide a completely different kind of information:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">unordered_map&lt;type_index,Icon&gt; icon_table; <span class="hljs-comment">// §31.4.3.2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(B∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    Icon&amp; i = icon_table[type_index&#123;<span class="hljs-built_in">typeid</span>(∗p)&#125;];<br>    <span class="hljs-comment">// ... use i ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>type_index</code> is a standard-library type for comparing and hashing <code>type_info</code> objects (§35.5.4).</li>
</ul>
<p>The resulting data structure looks like this:</p>
<p><img src="image-20230209164405259.png" srcset="/img/loading.gif" lazyload alt="image-20230209164405259"></p>
<ul>
<li>Associating <code>typeid</code>s with information without modifying system headers allows several people or tools to associate different information with types independently of each other. <ul>
<li>This is important because the likelihood that someone can come up with a single set of information that satisfies<br>every user is close to zero.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="22-6-Uses-and-Misuses-of-RTTI"><a href="#22-6-Uses-and-Misuses-of-RTTI" class="headerlink" title="22.6 Uses and Misuses of RTTI"></a>22.6 Uses and Misuses of RTTI</h3><ol start="45">
<li><p>We should use explicit run-time type information only when necessary. </p>
<p>Static (compile-time) checking is safer, implies less overhead, and – where applicable – leads to better-structured programs.</p>
<p>Interfaces based on virtual functions combine static type checking with a run-time lookup in a way that gives both type safety and flexibility.</p>
</li>
</ol>
<ol start="46">
<li><p>However, programmers sometimes overlook these alternatives and use RTTI where it is unsuitable. </p>
<ul>
<li><p>For example, RTTI can be used to write thinly disguised <code>switch</code>-statements:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// misuse of run-time type infor mation:</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeid</span>(r) == <span class="hljs-built_in">typeid</span>(Circle)) &#123;<br>        <span class="hljs-comment">// do nothing</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeid</span>(r) == <span class="hljs-built_in">typeid</span>(Triangle)) &#123;<br>        <span class="hljs-comment">// ... rotate triangle ...</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeid</span>(r) == <span class="hljs-built_in">typeid</span>(Square)) &#123;<br>        <span class="hljs-comment">// ... rotate square ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Using <code>dynamic_cast</code> rather than <code>typeid</code> would improve this code only marginally. </li>
<li>Either way, this code is syntactically ugly and also inefficient in that it performs an expensive operation repeatedly.</li>
</ul>
</li>
</ul>
<p>Unfortunately, this is not a strawman example; such code really does get written. </p>
<ul>
<li><p>For many people trained in languages without equivalents to class hierarchies and virtual functions, there is an almost irresistible urge to organize software as a set of <code>switch</code>-statements. </p>
</li>
<li><p>This urge should usually be resisted. </p>
</li>
</ul>
<p><strong>Use virtual functions (§3.2.3, §20.3.2) rather than RTTI to handle most cases when run-time discrimination based on type is needed.</strong></p>
</li>
</ol>
<ol start="47">
<li><p>Many examples of <strong>proper use of RTTI arise when some service code is expressed in terms of one class and a user wants to add functionality through derivation</strong>. </p>
<ul>
<li>The use of <code>Ival_box</code> in §22.2 is an example of this. </li>
</ul>
<p>If the user is willing and able to modify the definitions of the library classes, say <code>BBwindow</code>, then the use of RTTI can be avoided; otherwise, it is needed. </p>
<p>Even if the user is willing to modify the base classes (e.g., to add a virtual function), such modification may cause its own problems. </p>
<ul>
<li>For example, it may be necessary to introduce dummy implementations of virtual functions in classes for which those functions are not needed or not meaningful. </li>
</ul>
<p>A use of RTTI to implement a simple object I/O system can be found in §22.2.4.</p>
</li>
</ol>
<ol start="48">
<li><p>For people with a background in languages that rely heavily on dynamic type checking, such as Smalltalk, pre-generics Java, or Lisp, it is tempting to use RTTI in conjunction with overly general types. </p>
<p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// misuse of run-time type information:</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123; <span class="hljs-comment">// polymorphic</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> : <span class="hljs-keyword">public</span> Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Object∗)</span></span>;<br>    Object∗ <span class="hljs-built_in">get</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span> : <span class="hljs-keyword">public</span> Object &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br>Ship∗ <span class="hljs-built_in">f</span>(Ship∗ ps, Container∗ c)<br>&#123;<br>    c−&gt;<span class="hljs-built_in">put</span>(ps); <span class="hljs-comment">//put the Ship into the container</span><br>    <span class="hljs-comment">// ...</span><br>    Object∗ p = c−&gt;<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// retrieve an Object from the container</span><br>    <span class="hljs-keyword">if</span> (Ship∗ q = <span class="hljs-built_in">dynamic_cast</span>&lt;Ship∗&gt;(p)) &#123; <span class="hljs-comment">// run-time check that the Object is a Ship</span><br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ... do something else (typically, error handling) ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Here, class <code>Object</code> is an unnecessary implementation artifact. </li>
<li>It is overly general because it does not correspond to an abstraction in the application domain and forces the application programmer to use an implementation-level abstraction (<code>Object</code>).</li>
</ul>
<p>Problems of this kind are often better solved by using container templates that hold only a single kind of pointer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Ship∗ <span class="hljs-built_in">f</span>(Ship∗ ps, vector&lt;Ship∗&gt;&amp; c)<br>&#123;<br>    c.<span class="hljs-built_in">push_back</span>(ps); <span class="hljs-comment">// put the Ship into the container</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// retrieve a Ship from the container</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This style of code is less error-prone (better statically type checked) and less verbose than a pure-Object-based alternative. </li>
<li>Combined with the use of virtual functions, this technique handles most cases. </li>
<li>In a template, a template argument <code>T</code> takes the place of <code>Object</code> and enables static type checking (§27.2).</li>
</ul>
</li>
</ol>
<h3 id="22-7-Advice"><a href="#22-7-Advice" class="headerlink" title="22.7 Advice"></a>22.7 Advice</h3><p>[1] Use virtual functions to ensure that the same operation is performed independently of which interface is used for an object; §22.1.<br>[2] Use <code>dynamic_cast</code> where class hierarchy navigation is unavoidable; §22.2.<br>[3] Use <code>dynamic_cast</code> for type-safe explicit navigation of a class hierarchy; §22.2.1.<br>[4] Use <code>dynamic_cast</code> to a reference type when failure to find the required class is considered a failure; §22.2.1.1.<br>[5] Use <code>dynamic_cast</code> to a pointer type when failure to find the required class is considered a valid alternative; §22.2.1.1.<br>[6] Use double dispatch or the visitor pattern to express operations on two dynamic types (unless you need an optimized lookup); §22.3.1.<br>[7] Don’t call virtual functions during construction or destruction; §22.4.<br>[8] Use <code>typeid</code> to implement extended type information; §22.5.1.<br>[9] Use <code>typeid</code> to find the type of an object (and not to find an interface to an object); §22.5.<br>[10] Prefer virtual functions to repeated <code>switch</code>-statements based on <code>typeid</code> or <code>dynamic_cast</code>; §22.6.</p>
<h2 id="Chapter-23-Templates"><a href="#Chapter-23-Templates" class="headerlink" title="Chapter 23. Templates"></a>Chapter 23. Templates</h2><ul>
<li>Introduction and Overview</li>
<li>A Simple String Template<ul>
<li>Defining a Template</li>
<li>Template Instantiation</li>
</ul>
</li>
<li>Type Checking<ul>
<li>Type Equivalence</li>
<li>Error Detection</li>
</ul>
</li>
<li>Class Template Members<ul>
<li>Data Members</li>
<li>Member Functions</li>
<li>Member Type Aliases</li>
<li><code>static</code> Members</li>
<li>Member Types</li>
<li>Member Template</li>
<li>Friends</li>
</ul>
</li>
<li>Function Templates<ul>
<li>Function Template Arguments</li>
<li>Function Template Argument Deduction</li>
<li>Function Template Overloading</li>
</ul>
</li>
<li>Template Aliases</li>
<li>Source Code Organization<ul>
<li>Linkage</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="23-1-Introduction-and-Overview"><a href="#23-1-Introduction-and-Overview" class="headerlink" title="23.1 Introduction and Overview"></a>23.1 Introduction and Overview</h3><ol>
<li><p>Templates provide direct support for generic programming (§3.4) in the form of programming using types as parameters. </p>
<p>The C++ template mechanism allows a type or a value to be a parameter in the definition of a class, a function, or a type alias.</p>
<ul>
<li><p>Templates provide a straightforward way to represent a wide range of general concepts and simple ways to combine them.</p>
</li>
<li><p>The resulting classes and functions can match handwritten, less general code in run-time and space efficiency.</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>A template depends only on the properties that it actually uses from its parameter types and does not require types used as arguments to be explicitly related. </p>
<p>In particular, the argument types used for a template need not be part of an inheritance hierarchy. </p>
<ul>
<li>Built-in types are acceptable and very common as template arguments.</li>
</ul>
</li>
</ol>
<ol start="3">
<li>The composition offered by templates is type-safe (no object can be implicitly used in a way that disagrees with its definition), but unfortunately, <strong>a template’s requirements on its arguments cannot be simply and directly stated in code</strong> (§24.3).</li>
</ol>
<ol start="4">
<li><p>Every major standard-library abstraction is represented as a template,</p>
<ul>
<li>for example, <code>string</code>, <code>ostream</code>, <code>regex</code>, <code>complex</code>, <code>list</code>, <code>map</code>, <code>unique_ptr</code>, <code>thread</code>, <code>future</code>, <code>tuple</code>, and <code>function</code>, </li>
</ul>
<p>and so are the key operations, </p>
<ul>
<li>for example, <code>string</code> comparisons, the output operator <code>&lt;&lt;</code>, <code>complex</code> arithmetic operations, <code>list</code> insertions and deletions, and <code>sort()</code>). </li>
</ul>
<p>This makes the library chapters (Part IV) of this book a rich source of examples of templates and programming techniques relying on them.</p>
</li>
</ol>
<ol start="5">
<li><p>Here, templates are introduced with the primary focus on techniques needed for the design, implementation, and use of the standard library. </p>
<p>The standard library requires a greater degree of generality, flexibility, and efficiency than does most software. </p>
<ul>
<li><p>Consequently, techniques that can be used in the design and implementation of the standard library are effective and efficient in the design of solutions to a wide variety of problems. </p>
</li>
<li><p>These techniques enable an implementer to hide sophisticated implementations behind simple interfaces and to expose complexity to the user when the user has a specific need for it.</p>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>Templates and the fundamental techniques for using them are the focus of this and the following six chapters. </p>
<p>This chapter focuses on the most basic template facilities and fundamental programming techniques for using them:</p>
<ul>
<li>§23.2 <em>A Simple String Template</em>: <ul>
<li>The basic mechanisms for defining and using class templates are introduced through the example of a string template.</li>
</ul>
</li>
<li>§23.3 <em>Type Checking</em>: <ul>
<li>The basic rules of type equivalence and type checking as they apply to templates.</li>
</ul>
</li>
<li>§23.4 <em>Class Template Members</em>: <ul>
<li>How members of a class template are defined and used.</li>
</ul>
</li>
<li>§23.5 <em>Function Templates</em>: <ul>
<li>How to define and use function templates. </li>
<li>How overloading is resolved for function templates and ordinary functions.</li>
</ul>
</li>
<li>§23.6 <em>Template Aliases</em>: <ul>
<li>Template aliases provide a powerful mechanism for hiding implementation details and cleaning up the notation used for templates.</li>
</ul>
</li>
<li>§23.7 <em>Source Code Organization</em>: <ul>
<li>How to organize templates into source files.</li>
</ul>
</li>
</ul>
<p>Chapter 24, <em>Generic Programming</em>, presents the basic technique of generic programming, and the fundamental idea of <em>concepts</em> (requirements on template arguments) is explored:</p>
<ul>
<li>§24.2 <em>Algorithms and Lifting</em>: <ul>
<li>An example of the basic technique for developing a generic algorithm from concrete examples.</li>
</ul>
</li>
<li>§24.3 <em>Concepts</em>: <ul>
<li>Introduces and discusses the fundamental notion of a <em>concept</em>, that is, a set of requirements that a template can impose on its template arguments.</li>
</ul>
</li>
<li>§24.4 <em>Making Concepts Concrete</em>: <ul>
<li>Presents techniques for using concepts expressed as compile-time predicates.</li>
</ul>
</li>
</ul>
<p>Chapter 25, <em>Specialization</em>, discusses template argument passing and the notion of specialization:</p>
<ul>
<li>§25.2 <em>Template Parameters and Arguments</em>: <ul>
<li>What can be a template argument: types, values, and templates. </li>
<li>How to specify and use default template arguments.</li>
</ul>
</li>
<li>§25.3 <em>Specialization</em>: <ul>
<li>Special versions, called <em>specializations</em>, of a template for a specific set of template arguments can be generated from the templates by the compiler or be provided by the programmer.</li>
</ul>
</li>
</ul>
<p>Chapter 26, <em>Instantiation</em>, presents issues related to generation of template specialization (instances) and name binding:</p>
<ul>
<li>§26.2 <em>Template Instantiation</em>: <ul>
<li>The rules for when and how a compiler generates specializations from a template definition and how to specify them manually.</li>
</ul>
</li>
<li>§26.3 <em>Name Binding</em>: <ul>
<li>The rules for determining to which entity a name used in a template definition refers.</li>
</ul>
</li>
</ul>
<p>Chapter 27, <em>Templates and Hierarchies</em>, discusses the relation between the generic programming techniques supported by templates and the object-oriented techniques supported by class hierarchies. </p>
<p>The emphasis is on how to use them in combination:</p>
<ul>
<li>§27.2 <em>Parameterization and Hierarchy</em>: <ul>
<li>Templates and class hierarchies are two ways of representing sets of related abstractions. </li>
<li>How do we choose between them?</li>
</ul>
</li>
<li>§27.3 <em>Hierarchies of Class Templates</em>: <ul>
<li>Why it is usually a bad idea simply to add template parameters to an existing class hierarchy?</li>
</ul>
</li>
<li>§27.4 <em>Template Parameters as Base Classes</em>: <ul>
<li>Presents techniques for composing interfaces and data structures for type safety and performance.</li>
</ul>
</li>
</ul>
<p>Chapter 28, <em>Metaprogramming</em>, concentrates on the use of templates as a means of generating functions and classes:</p>
<ul>
<li>§28.2 <em>Type Functions</em>: <ul>
<li>Functions that take types as arguments or return types as results.</li>
</ul>
</li>
<li>§28.3 <em>Compile-time Control Structures</em>: <ul>
<li>How to express selection and recursion for type functions, and some rules of thumb for their use.</li>
</ul>
</li>
<li>§28.4 <em>Conditional Definition</em>: <ul>
<li><code>enable_if</code>: <ul>
<li>How to conditionally define functions and overload templates using (almost) arbitrary predicates.</li>
</ul>
</li>
</ul>
</li>
<li>§28.5 <em>A Compile-time List</em>: <ul>
<li><code>Tuple</code>: <ul>
<li>How to build and access lists with elements of (almost) arbitrary types.</li>
</ul>
</li>
</ul>
</li>
<li>§28.6 <em>Variadic templates</em>: <ul>
<li>How (in a statically type-safe manner) to define templates that take arbitrary numbers of template arguments of arbitrary types.</li>
</ul>
</li>
<li>§28.7 <em>SI Units Example</em>: <ul>
<li>This example uses simple metaprogramming techniques in combination with other programming techniques to provide a library for computations that are (at compile time) checked for correct use of the meters, kilograms, and seconds system of units.</li>
</ul>
</li>
</ul>
<p>Chapter 29, <em>A Matrix Design</em>, demonstrates how various template features can be used in combination to address a challenging design task:</p>
<ul>
<li>§29.2 <em>A</em> <code>Matrix</code> <em>Template</em>: <ul>
<li>How to define an N-dimensional matrix with flexible and type-safe initialization, subscription, and submatrices.</li>
</ul>
</li>
<li>§29.3 <code>Matrix</code> <em>Arithmetic Operations</em>: <ul>
<li>How to provide simple arithmetic operations on an N-dimensional matrix.</li>
</ul>
</li>
<li>§29.4 <em>Matrix Implementation</em>: <ul>
<li>Some useful implementation techniques.</li>
</ul>
</li>
<li>§29.5 <em>Solving Linear Equations</em>: <ul>
<li>An example of simple matrix use.</li>
<li>Templates were introduced early (§3.4.1, §3.4.2) and used throughout this book, so I assume that you have some familiarity with them.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="23-2-A-Simple-String-Template"><a href="#23-2-A-Simple-String-Template" class="headerlink" title="23.2 A Simple String Template"></a>23.2 A Simple String Template</h3><ol start="7">
<li><p>Consider a string of characters. </p>
<p>A string is a class that holds characters and provides operations such as subscripting, concatenation, and comparison that we usually associate with the notion of a ‘‘string.’’ </p>
<p>We would like to provide that behavior for many different kinds of characters. </p>
<ul>
<li>For example, strings of signed characters, of unsigned characters, of Chinese characters, of Greek characters, etc., are useful in various contexts. </li>
</ul>
<p>Thus, we want to represent the notion of ‘‘string’’ with minimal dependence on a specific kind of character. </p>
<p>The definition of a string relies on the fact that a character can be copied, and little else (§24.3). </p>
<p>Thus, we can make a more general string type by taking the string of <code>char</code> from §19.3 and making the character type a parameter:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-type">const</span> C∗)</span></span>;<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp;);<br>    String <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp;);<br>    <span class="hljs-comment">// ...</span><br>    C&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> ptr[n]; &#125; <span class="hljs-comment">// unchecked element access</span><br>    String&amp; <span class="hljs-keyword">operator</span>+=(C c); <span class="hljs-comment">// add c at end</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> short_max = <span class="hljs-number">15</span>; <span class="hljs-comment">// for the short str ing optimization</span><br>    <span class="hljs-type">int</span> sz;<br>    C∗ ptr; <span class="hljs-comment">// ptr points to sz Cs</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>template&lt;typename C&gt;</code> prefix specifies that a template is being declared and that a type argument <code>C</code> will be used in the declaration. </li>
<li>After its introduction, <code>C</code> is used exactly like other type names. </li>
<li>The scope of <code>C</code> extends to the end of the declaration prefixed by <code>template&lt;typename C&gt;</code>.</li>
<li>You may prefer the shorter and equivalent form <code>template&lt;class C&gt;</code>. </li>
<li>In either case, <strong><code>C</code> is a type name; it need not be the name of a class.</strong> </li>
<li>Mathematicians will recognize <code>template&lt;typename C&gt;</code> as a variant of the traditional ‘‘for all <code>C</code>’’ or more specifically ‘‘for all types <code>C</code>’’ or even ‘‘for all <code>C</code>, such that <code>C</code> is a type.’’ <ul>
<li>If you think along those lines, you will note that C++ lacks a fully general mechanism for specifying the required properties of a template parameter <code>C</code>. </li>
<li>That is, we can’t say ‘‘for all <code>C</code>, such that …’’ where the ‘‘…’’ is a set of requirements for <code>C</code>. </li>
</ul>
</li>
<li>In other words, C++ does not offer a direct way to say what kind of type a template argument <code>C</code> is supposed to be (§24.3).</li>
</ul>
</li>
</ol>
<ol start="8">
<li><p>The name of a class template followed by a type bracketed by<code> &lt; &gt;</code> is the name of a class (as defined by the template) and can be used exactly like other class names. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&lt;<span class="hljs-type">char</span>&gt; cs;<br>String&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; us;<br>String&lt;<span class="hljs-type">wchar_t</span>&gt; ws;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Jchar</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// Japanese character</span><br>String&lt;Jchar&gt; js;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Except for the special syntax of its name, <code>String&lt;char&gt;</code> works exactly as if it had been defined using the definition of class <code>String</code> in §19.3. </p>
<p>Making String a template allows us to provide the facilities we had for <code>String</code> of char for <code>String</code>s of any kind of character.</p>
<ul>
<li><p>For example, if we use the standard-library <code>map</code> and the <code>String</code> template, the word-counting example from §19.2.1 becomes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// count the occurrences of each word on input</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;String&lt;<span class="hljs-type">char</span>&gt;,<span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (String&lt;<span class="hljs-type">char</span>&gt; buf; cin&gt;&gt;buf;)<br>        ++m[buf];<br>    <span class="hljs-comment">// ... write out result ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The version for our Japanese-character type <code>Jchar</code> would be:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// count the occurrences of each word on input</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;String&lt;Jchar&gt;,<span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (String&lt;Jchar&gt; buf; cin&gt;&gt;buf;)<br>        ++m[buf];<br>    <span class="hljs-comment">// ... write out result ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="9">
<li><p>The standard library provides the template class <code>basic_string</code> that is similar to the templatized <code>String</code> (§19.3, §36.3). </p>
<p>In the standard library, <code>string</code> is a synonym for <code>basic_string&lt;char&gt;</code> (§36.3):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> string = std::basic_string&lt;<span class="hljs-type">char</span>&gt;;<br></code></pre></td></tr></table></figure>

<p>This allows us to write the word-counting program like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// count the occurrences of each word on input</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;string,<span class="hljs-type">int</span>&gt; m; <span class="hljs-comment">// using string = std::basic_string&lt;char&gt;</span><br>    <span class="hljs-keyword">for</span> (string buf; cin&gt;&gt;buf;)<br>        ++m[buf];<br>    <span class="hljs-comment">// ... write out result ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>In general, type aliases (§6.5) are useful for shortening the long names of classes generated from templates. </p>
<p>Also, we often prefer not to know the details of how a type is defined, and an alias allows us to hide the fact that a type is generated from a template.</p>
</li>
</ol>
<h4 id="23-2-1-Defining-a-Template"><a href="#23-2-1-Defining-a-Template" class="headerlink" title="23.2.1 Defining a Template"></a>23.2.1 Defining a Template</h4><ol start="10">
<li><p>A class generated from a class template is a perfectly ordinary class. </p>
<p>Thus, use of a template does not imply any run-time mechanisms beyond what is used for an equivalent ‘‘handwritten’’ class.</p>
<p>In fact, using a template can lead to a decrease of code generated because code for a member function of a class template is only generated if that member is used (§26.2.1).</p>
</li>
</ol>
<ol start="11">
<li><p>In addition to class templates, C++ offers function templates (§3.4.2, §23.5). </p>
<ul>
<li>I will introduce most of the ‘‘mechanics’’ of templates in the context of class templates and postpone detailed discussion of function templates to §23.5. </li>
</ul>
<p>A template is a specification of how to generate something given suitable template arguments; the language mechanisms for doing that generation (instantiation (§26.2) and specialization (§25.3)) don’t care much whether a class or a function is generated.</p>
<ul>
<li>So, unless otherwise stated, the rules for templates apply equally to class templates and function templates. </li>
</ul>
<p>Templates can also be defined as aliases (§23.6), but other plausible constructs, such as namespace templates, are not provided.</p>
</li>
</ol>
<ol start="12">
<li><p>There are people who make semantic distinctions between the terms <em><strong>class template</strong></em> and <em><strong>template class</strong></em>. </p>
<p>I don’t; that would be too subtle: please consider those terms interchangeable. </p>
<p>Similarly, I consider <em><strong>function template</strong></em> interchangeable with <em><strong>template function</strong></em>.</p>
</li>
</ol>
<ol start="13">
<li><p>When designing a class template, it is usually a good idea to debug a particular class, such as <code>String</code>, before turning it into a template such as <code>String&lt;C&gt;</code>. </p>
<ul>
<li><p>By doing so, we handle many design problems and most of the code errors in the context of a concrete example. </p>
</li>
<li><p>This kind of debugging is familiar to all programmers, and most people cope better with a concrete example than with an abstract concept. </p>
</li>
<li><p>Later, we can deal with any problems that might arise from generalization without being distracted by more conventional errors. </p>
</li>
</ul>
<p>Similarly, when trying to understand a template, it is often useful to imagine its behavior for a particular type argument such as <code>char</code> before trying to comprehend the template in its full generality. </p>
<p>This also fits with the philosophy that a generic component should be developed as a generalization of one or more concrete examples, rather than simply being designed from first principles (§24.2).</p>
</li>
</ol>
<ol start="14">
<li><p>Members of a class template are declared and defined exactly as they would have been for a non-template class. </p>
<ul>
<li><p>A template member need not be defined within the template class itself. </p>
</li>
<li><p>In that case, its definition must be provided somewhere else, just as for non-template class members (§16.2.1). </p>
</li>
<li><p>Members of a template class are themselves templates parameterized by the parameters of their template class. </p>
</li>
</ul>
<p><strong>When such a member is defined outside its class, it must explicitly be declared a template.</strong> </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;<br>String&lt;C&gt;::<span class="hljs-built_in">String</span>() <span class="hljs-comment">// String&lt;C&gt;’s constructor</span><br>    :sz&#123;<span class="hljs-number">0</span>&#125;, ptr&#123;ch&#125;<br>&#123;<br>    ch[<span class="hljs-number">0</span>] = &#123;&#125;; <span class="hljs-comment">// terminating 0 of the appropriate character type</span><br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;<br>String&amp; String&lt;C&gt;::<span class="hljs-keyword">operator</span>+=(C c)<br>&#123;<br>    <span class="hljs-comment">// ... add c to the end of this string ...</span><br>    <span class="hljs-keyword">return</span> ∗<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>A template parameter, such as <code>C</code>, is a parameter rather than the name of a specific type. </p>
<ul>
<li><p>However, that doesn’t affect the way we write the template code using the name. </p>
</li>
<li><p>Within the scope of <code>String&lt;C&gt;</code>, qualification with <code>&lt;C&gt;</code> is redundant for the name of the template itself, so <code>String&lt;C&gt;::String</code> is the name for the constructor.</p>
</li>
</ul>
</li>
</ol>
<ol start="15">
<li><p>Just as there can be only one function defining a class member function in a program, <strong>there can be only one function template defining a class template member function in a program</strong>. </p>
<ul>
<li>However, specialization (§25.3) enables us to provide alternative implementations for a template given specific template arguments. </li>
</ul>
<p>For functions, we can also use overloading to provide different definitions for different argument types (§23.5.3).</p>
</li>
</ol>
<ol start="16">
<li><p>It is not possible to overload a class template name, so if a class template is declared in a scope, no other entity can be declared there with the same name. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// error : double definition</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>A type used as a template argument must provide the interface expected by the template. </p>
<ul>
<li>For example, a type used as an argument to <code>String</code> must provide the usual copy operations (§17.5, §36.2.2). </li>
</ul>
<p>Note that there is no requirement that different arguments for the same template parameter should be related by inheritance. </p>
<ul>
<li>See also §25.2.1 (template type parameters), §23.5.2 (template parameter deduction), and §24.3 (requirements on template arguments).</li>
</ul>
</li>
</ol>
<h4 id="23-2-2-Template-Instantiation"><a href="#23-2-2-Template-Instantiation" class="headerlink" title="23.2.2 Template Instantiation"></a>23.2.2 Template Instantiation</h4><ol start="18">
<li><p>The process of generating a class or a function from a template plus a template argument list is often called <em><strong>template instantiation</strong></em> (§26.2). </p>
<p>A version of a template for a specific template argument list is called a <em><strong>specialization</strong></em>.</p>
</li>
</ol>
<ol start="19">
<li><p>In general, it is the implementation’s job – not the programmer’s – to ensure that specializations of a template are generated for each template argument list used. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&lt;<span class="hljs-type">char</span>&gt; cs;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    String&lt;Jchar&gt; js;<br>    cs = <span class="hljs-string">&quot;It&#x27;s the implementation&#x27;s job to figure out what code needs to be generated&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>For this, the implementation generates declarations for classes <code>String&lt;char&gt;</code> and <code>String&lt;Jchar&gt;</code>, for their destructors and default constructors, and for <code>String&lt;char&gt;::operator=(char∗)</code>. </li>
</ul>
</li>
<li><p>Other member functions are not used and will not be generated. </p>
</li>
<li><p>Generated classes are perfectly ordinary classes that obey all the usual rules for classes. </p>
</li>
<li><p>Similarly, generated functions are ordinary functions that obey all the usual rules for functions.</p>
</li>
</ul>
</li>
</ol>
<ol start="20">
<li><p>Obviously, templates provide a powerful way of generating lots of code from relatively short definitions. </p>
<ul>
<li>Consequently, a certain amount of caution is in order to avoid flooding memory with almost identical function definitions (§25.3). </li>
</ul>
<p>On the other hand, templates can be written to enable otherwise unachievable quality of generated code. </p>
<ul>
<li>In particular, <strong>composition using templates combined with simple inlining</strong> can be used to eliminate many direct and indirect function calls. <ul>
<li>For example, that is how simple operations on critical data structures (such as <code>&lt;</code> in a <code>sort()</code> and <code>+</code> for scalars in a matrix computation) are reduced to single machine instructions in heavily parameterized libraries. </li>
</ul>
</li>
</ul>
<p>Thus, incautious use of templates leading to the generation of very similar large functions can cause code bloat, whereas use of templates to enable inlining of tiny functions can lead to significant code shrinkage (and speedup) compared to alternatives. </p>
<ul>
<li>In particular, the code generated for a simple <code>&lt;</code> or <code>[]</code> is often a single machine instruction, which is both much faster than any function call and smaller than the code needed to invoke a function and receive its result.</li>
</ul>
</li>
</ol>
<h3 id="23-3-Type-Checking"><a href="#23-3-Type-Checking" class="headerlink" title="23.3 Type Checking"></a>23.3 Type Checking</h3><ol start="21">
<li><p>Template instantiation takes a template plus a set of template arguments and generates code from them.</p>
<p>Because so much information is available at instantiation time, weaving together the information from the template definition and the template argument types provides wonderful degrees of flexibility and can yield unparalleled run-time performance. </p>
<p>Unfortunately, this flexibility also implies <strong>complexity of type checking and difficulties for accurate reporting of type errors</strong>.</p>
</li>
</ol>
<ol start="22">
<li><p>Type checking is done on the code generated by template instantiation (exactly as if the programmer had expanded the templates by hand). </p>
<p>This generated code may contain much that the user of a template has never heard of (such as names of details of a template implementation) and often happens uncomfortably late in the build process. </p>
<p>This mismatch between what the programmer sees/writes and what the compiler type checks can be a major problem, and we need to design our programs to minimize its consequences.</p>
</li>
</ol>
<ol start="23">
<li><p>The <strong>fundamental weakness of the template mechanism</strong> is that <strong>it is not possible to directly express requirements on a template argument</strong>. </p>
<ul>
<li><p>For example, we cannot say:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;Container Cont, <span class="hljs-keyword">typename</span> Elem&gt;<br><span class="hljs-keyword">requires</span> <span class="hljs-built_in">Equal_comparable</span>&lt;Cont::value_type ,Elem&gt;() <span class="hljs-comment">// requirements for types Cont and Elem</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_index</span><span class="hljs-params">(Cont&amp; c, Elem e)</span></span>; <span class="hljs-comment">// find the index of e in c</span><br></code></pre></td></tr></table></figure></li>
<li><p>That is, we have no way in C++ itself to directly say that <code>Cont</code> should be a type that can act as a container and that the type <code>Elem</code> should be a type that allows us to compare a value to an element of <code>Cont</code>. </p>
</li>
<li><p>Work is being done to make this possible in future versions of C++ (without loss of flexibility, without loss of run-time performance, and without significant increases in compile time [Sutton, 2011]), but for now we will have to do without.</p>
</li>
</ul>
</li>
</ol>
<ol start="24">
<li><p>The first step in dealing effectively with problems related to template argument passing is to establish a framework and vocabulary for discussing requirements. </p>
<p>Think of a set of requirements on template arguments as a predicate. </p>
<ul>
<li>For example, we can think of ‘‘<code>C</code> must be a container’’ as a predicate that takes a type, <code>C</code>, as an argument and returns true if <code>C</code> is a container (however we may have defined ‘‘container’’) and false if it is not. <ul>
<li>For example, <code>Container&lt;vector&lt;int&gt;&gt;()</code> and <code>Container&lt;list&lt;string&gt;&gt;()</code> should be true whereas <code>Container&lt;int&gt;()</code> and <code>Container&lt;shared_ptr&lt;string&gt;&gt;()</code> should be false. </li>
</ul>
</li>
</ul>
<p>We call such a predicate a <em><strong>concept</strong></em>. </p>
<ul>
<li>A concept is not (yet) a language construct in C++; it is a notion that we can use to reason about requirements on template arguments, use in comments, and sometimes support with our own code (§24.3).</li>
</ul>
</li>
</ol>
<ol start="25">
<li><p>For starters, think of a concept as a design tool: specify <code>Container&lt;T&gt;()</code> as a set of comments saying what properties a type <code>T</code> must have for <code>Container&lt;T&gt;()</code> to be true. </p>
<ul>
<li>For example:<ul>
<li><code>T</code> must have a subscript operator (<code>[]</code>).</li>
<li><code>T</code> must have a <code>size()</code> member function.</li>
<li><code>T</code> must have a member type <code>value_type</code> which is the type of its elements.</li>
</ul>
</li>
</ul>
<p>Note that this list is incomplete (e.g., what does <code>[]</code> take as an argument and what does it return?) and fails to address most semantic issues (e.g., what does <code>[]</code> actually do?). </p>
<ul>
<li><p>However, even a partial set of requirements can be useful; even something very simple allows us to hand-check our uses and catch obvious errors. </p>
</li>
<li><p>For example, <code>Container&lt;int&gt;()</code> is obviously false because <code>int</code> does not have a subscript operator. </p>
</li>
</ul>
<p>I will return to the design of concepts (§24.3), consider techniques for supporting concepts in code (§24.4), and give an example of a set of useful concepts (§24.3.2). </p>
<p>For now, just note that <strong>C++ does not directly support concepts</strong>, but that does not mean that concepts don’t exist: for every working template, the designer had some concepts in mind for its arguments.</p>
<p>Dennis Ritchie famously said, ‘‘C is a strongly typed, weakly checked language.’’ </p>
<p>You could say the same about C++’s templates, except that <strong>the checking of template argument requirements (concepts) is actually done, but it is done too late in the compilation process and at an unhelpfully low level of abstraction</strong>.</p>
</li>
</ol>
<h4 id="23-3-1-Type-Equivalence"><a href="#23-3-1-Type-Equivalence" class="headerlink" title="23.3.1 Type Equivalence"></a>23.3.1 Type Equivalence</h4><ol start="26">
<li><p>Given a template, we can generate types by supplying template arguments. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&lt;<span class="hljs-type">char</span>&gt; s1;<br>String&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; s2;<br>String&lt;<span class="hljs-type">int</span>&gt; s3;<br><br><span class="hljs-keyword">using</span> Uchar = <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>;<br><span class="hljs-keyword">using</span> uchar = <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>;<br><br>String&lt;Uchar&gt; s4;<br>String&lt;uchar&gt; s5;<br>String&lt;<span class="hljs-type">char</span>&gt; s6;<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt; <span class="hljs-comment">// §25.2.2</span><br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span>;<br><br>Buffer&lt;String&lt;<span class="hljs-type">char</span>&gt;,<span class="hljs-number">10</span>&gt; b1;<br>Buffer&lt;<span class="hljs-type">char</span>,<span class="hljs-number">10</span>&gt; b2;<br>Buffer&lt;<span class="hljs-type">char</span>,<span class="hljs-number">20</span>−<span class="hljs-number">10</span>&gt; b3;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>When using the same set of template arguments for a template, we always refer to the same generated type.</p>
<p> However, what does ‘‘the same’’ mean in this context? </p>
<ul>
<li><p>Aliases do not introduce new types, so <code>String&lt;Uchar&gt;</code> and <code>String&lt;uchar&gt;</code> are the same type as <code>String&lt;unsigned char&gt;</code>. </p>
</li>
<li><p>Conversely, because <code>char</code> and <code>unsigned char</code> are different types (§6.2.3), <code>String&lt;char&gt;</code> and <code>String&lt;unsigned char&gt;</code> are different types.</p>
</li>
<li><p>The compiler can evaluate constant expressions (§10.4), so <code>Buffer&lt;char,20−10&gt;</code> is recognized to be the same type as <code>Buffer&lt;char,10&gt;</code>.</p>
</li>
</ul>
<p>Types generated from a single template by different template arguments are different types. </p>
<ul>
<li><p>In particular, generated types from related arguments are not automatically related. </p>
</li>
<li><p>For example, assume that a <code>Circle</code> is a kind of <code>Shape</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">Shape∗ p &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>(p,<span class="hljs-number">100</span>)&#125;; <span class="hljs-comment">//Circle* converts to Shape*</span><br>vector&lt;Shape&gt;∗ q &#123;<span class="hljs-keyword">new</span> vector&lt;Circle&gt;&#123;&#125;&#125;; <span class="hljs-comment">// error : no vector&lt;Circle&gt;* to vector&lt;Shape&gt;* conversion</span><br>vector&lt;Shape&gt; vs &#123;vector&lt;Circle&gt;&#123;&#125;&#125;; <span class="hljs-comment">// error : no vector&lt;Circle&gt; to vector&lt;Shape&gt; conversion</span><br>vector&lt;Shape∗&gt; vs &#123;vector&lt;Circle∗&gt;&#123;&#125;&#125;; <span class="hljs-comment">// error : no vector&lt;Circle*&gt; to vector&lt;Shape*&gt; conversion</span><br></code></pre></td></tr></table></figure></li>
<li><p>Had such conversions been allowed, type errors would have resulted (§27.2.1). </p>
</li>
<li><p>If conversions between generated classes are needed, the programmer can define them (§27.2.2).</p>
</li>
</ul>
</li>
</ol>
<h4 id="23-3-2-Error-Detection"><a href="#23-3-2-Error-Detection" class="headerlink" title="23.3.2 Error Detection"></a>23.3.2 Error Detection</h4><ol start="27">
<li><p>A template is defined and then later used in combination with a set of template arguments. </p>
<p>When the template is defined, the definition is checked for <strong>syntax errors</strong> and <strong>possibly also for other errors that can be detected in isolation from a particular set of template arguments</strong>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Link</span> &#123;<br>    Link∗ pre;<br>    Link∗suc <span class="hljs-comment">//	syntax error: missing semicolon</span><br>    T val;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br>    Link&lt;T&gt;∗ head;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">List</span>() :head&#123;<span class="hljs-number">7</span>&#125; &#123; &#125; <span class="hljs-comment">// error : pointer initialized with int</span><br>    <span class="hljs-built_in">List</span>(<span class="hljs-type">const</span> T&amp; t) : head&#123;<span class="hljs-keyword">new</span> Link&lt;T&gt;&#123;<span class="hljs-number">0</span>,o,t&#125;&#125; &#123; &#125; <span class="hljs-comment">// error : undefined identifier o</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">void</span> <span class="hljs-built_in">print_all</span>() <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>A compiler can catch simple semantic errors at the point of definition or later at the point of use.</p>
<ul>
<li>Users generally prefer early detection, but not all ‘‘simple’’ errors are easy to detect. </li>
</ul>
</li>
<li><p>Here, I made three ‘‘mistakes’’:</p>
<ul>
<li><em>A simple syntax error</em>: <ul>
<li>Leaving out a semicolon at the end of a declaration.</li>
</ul>
</li>
<li><em>A simple type error</em>: <ul>
<li>Independently of what the template parameter is, a pointer cannot be initialized by the integer <code>7</code>.</li>
</ul>
</li>
<li><em>A name lookup error</em>: The identifier <code>o</code> (a mistyped <code>0</code>, of course) cannot be an argument to <code>Link&lt;T&gt;</code>’s constructor because there is no such name in scope.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="28">
<li><p>A name used in a template definition must either be in scope or in some reasonably obvious way depend on a template parameter (§26.3). </p>
<p>The most common and obvious ways of depending on a template parameter <code>T</code> are to explicitly use the name <code>T</code>, to use a member of a <code>T</code>, and to take an argument of type <code>T</code>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> List&lt;T&gt;::<span class="hljs-built_in">print_all</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (Link&lt;T&gt;∗ p = head; p; p=p−&gt;suc) <span class="hljs-comment">// p depends on T</span><br>        cout &lt;&lt; ∗p; <span class="hljs-comment">// &lt;&lt; depends on T</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Errors that relate to the use of template parameters cannot be detected until the template is used.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rec</span> &#123;<br>    string name;<br>    string address;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> List&lt;<span class="hljs-type">int</span>&gt;&amp; li, <span class="hljs-type">const</span> List&lt;Rec&gt;&amp; lr)</span></span><br><span class="hljs-function"></span>&#123;<br>    li.<span class="hljs-built_in">print_all</span>();<br>    lr.<span class="hljs-built_in">print_all</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>li.print_all()</code> checks out fine, but <code>lr.print_all()</code> gives a type error because there is no <code>&lt;&lt;</code> output operator defined for <code>Rec</code>. </li>
<li>The earliest that errors relating to a template parameter can be detected is at the first point of use of the template for a particular template argument. <ul>
<li>That point is called the first <em><strong>point of instantiation</strong></em> (§26.3.3). </li>
</ul>
</li>
<li>The implementation is allowed to postpone essentially all checking until the program is linked, and for some errors link time is also the earliest point when complete checking is possible. </li>
<li>Independently of when checking is done, the same set of rules is checked. </li>
<li>Naturally, users prefer early checking.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="23-4-Class-Template-Members"><a href="#23-4-Class-Template-Members" class="headerlink" title="23.4 Class Template Members"></a>23.4 Class Template Members</h3><ol start="29">
<li><p>Exactly like a class, a template class can have members of several kinds:</p>
<ul>
<li>Data members (variable and constant); §23.4.1</li>
<li>Member functions; §23.4.2</li>
<li>Member type aliases; §23.6</li>
<li><code>static</code> members (function and data); §23.4.4</li>
<li>Member types (e.g., a member class); §23.4.5</li>
<li>Member templates (e.g., a member class template); §23.4.6.3</li>
</ul>
<p>In addition, a class template can declare <code>friend</code>s, just as an ‘‘ordinary class’’ can; §23.4.7.</p>
<p>The rules for class template members are those for their generated classes. </p>
<ul>
<li>That is, if you want to know what the rules of a template member are, just look for the rules for a member of an ordinary class (Chapter 16, Chapter 17, and Chapter 20); that will answer most questions.</li>
</ul>
</li>
</ol>
<h4 id="23-4-1-Data-Members"><a href="#23-4-1-Data-Members" class="headerlink" title="23.4.1 Data Members"></a>23.4.1 Data Members</h4><ol start="30">
<li><p>As for an ‘‘ordinary class,’’ a class template can have data members of any type. </p>
<p>A non-<code>static</code> data member can be initialized in its definition (§17.4.4) or in a constructor (§16.2.5). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">int</span> m1 = <span class="hljs-number">7</span>; <span class="hljs-comment">// In-class initializer</span><br>    T m2;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> T&amp; x) :m2&#123;x&#125; &#123; &#125; <span class="hljs-comment">// constructor</span><br>&#125;;<br><br>X&lt;<span class="hljs-type">int</span>&gt; xi &#123;<span class="hljs-number">9</span>&#125;;<br>X&lt;string&gt; xs &#123;<span class="hljs-string">&quot;Rapperswil&quot;</span>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Non-<code>static</code> data members can be <code>const</code>, but unfortunately not <code>constexpr</code>.</p>
</li>
</ol>
<h4 id="23-4-2-Member-Functions"><a href="#23-4-2-Member-Functions" class="headerlink" title="23.4.2 Member Functions"></a>23.4.2 Member Functions</h4><ol start="31">
<li><p>As for an ‘‘ordinary class,’’ a non-<code>static</code> member function of a class template can be defined in-class or outside the class. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// defined in-class</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> X&lt;T&gt;::<span class="hljs-built_in">mf2</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// defined out of class</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>Similarly, a member function of a template can be virtual or not. </p>
<p>However, a virtual member function cannot also be a member function template (§23.4.6.2).</p>
</li>
</ol>
<h4 id="23-4-3-Member-Type-Aliases"><a href="#23-4-3-Member-Type-Aliases" class="headerlink" title="23.4.3 Member Type Aliases"></a>23.4.3 Member Type Aliases</h4><ol start="32">
<li><p>Member type aliases, whether introduced using <code>using</code> or <code>typedef</code> (§6.5), play a major role in the design of class templates. </p>
<p>They define related types of a class in a way that is easy to access from outside the class. </p>
<ul>
<li><p>For example, we specify a container’s iterator and element types as aliases:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-keyword">using</span> iterator = Vector_iter&lt;T&gt;; <span class="hljs-comment">// Vector_iter is defined elsewhere</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>The template argument name, <code>T</code>, is only accessible to the template itself, so for other code to refer to the element type, we must provide an alias.</p>
<p>Type aliases play a major role in generic programming by allowing the designer of classes to provide common names for types in different classes (and class templates) with common semantics. </p>
<p>Type names as member aliases are often referred to as <em><strong>associated types</strong></em>. </p>
<p>The <code>value_type</code> and <code>iterator</code> names are borrowed from the standard library’s container design (§33.1.3). </p>
<p>If a class is missing a desired member alias, a trait can be used to compensate (§28.2.4).</p>
</li>
</ol>
<h4 id="23-4-4-static-Members"><a href="#23-4-4-static-Members" class="headerlink" title="23.4.4 static Members"></a>23.4.4 <code>static</code> Members</h4><ol start="33">
<li><p>A <code>static</code> data or function member that is not defined in-class must have a unique definition in a program.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> Point p &#123;<span class="hljs-number">100</span>,<span class="hljs-number">250</span>&#125;; <span class="hljs-comment">// Point must be a literal type (§10.4.3)</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m1 = <span class="hljs-number">7</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m2 = <span class="hljs-number">8</span>; <span class="hljs-comment">// error : not const</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m3;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">int</span> X&lt;T&gt;::m1 = <span class="hljs-number">88</span>; <span class="hljs-comment">// error : two initializers</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">int</span> X&lt;T&gt;::m3 = <span class="hljs-number">99</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> X::&lt;T&gt;::<span class="hljs-built_in">f2</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;    <br></code></pre></td></tr></table></figure></li>
</ul>
<p>As for non-template classes, a <code>const</code> or <code>conexpr</code> <code>static</code> data member of literal type can be initialized in-class and need not be defined outside the class (§17.4.5, §iso.9.2).</p>
</li>
</ol>
<ol start="34">
<li><p>A <code>static</code> member need only be defined if it is used (§iso.3.2, §iso.9.4.2, §16.2.12). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-type">int</span>∗ p = &amp;X&lt;<span class="hljs-type">int</span>&gt;::a;<br></code></pre></td></tr></table></figure></li>
<li><p>If this is all the mention of <code>X&lt;int&gt;</code> in a program, we will get a ‘‘not defined’’ error for <code>X&lt;int&gt;::a</code>, but not for <code>X&lt;int&gt;::b</code>.</p>
</li>
</ul>
</li>
</ol>
<h4 id="23-4-5-Member-Types"><a href="#23-4-5-Member-Types" class="headerlink" title="23.4.5 Member Types"></a>23.4.5 Member Types</h4><ol start="35">
<li><p>As for an ‘‘ordinary class,’’ we can define types as members. </p>
<p>As usual, such a type can be a class or an enumeration. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">E1</span> &#123; a, b &#125;;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">E2</span>; <span class="hljs-comment">// error : underlying type not known</span><br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">E3</span>;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">E4</span> : <span class="hljs-type">char</span>; <span class="hljs-comment">// specify the underlying type is char</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C1</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">C2</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">X</span>&lt;T&gt;::E3 &#123; a, b &#125;; <span class="hljs-comment">// needed</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">X</span>&lt;T&gt;::E4 : <span class="hljs-type">char</span> &#123; x, y &#125;; <span class="hljs-comment">// needed</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span>&lt;T&gt;::C2 &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// needed</span><br></code></pre></td></tr></table></figure></li>
<li><p>The out-of-class definition of a member enumeration is only allowed for an enumeration for which we know the underlying type (§8.4).</p>
</li>
<li><p>As usual, the enumerators of a non-class <code>enum</code> are placed in the scope of the enumeration; that is, for a member enumeration, the enumerators are in the scope of its class.</p>
</li>
</ul>
</li>
</ol>
<h4 id="23-4-6-Member-Templates"><a href="#23-4-6-Member-Templates" class="headerlink" title="23.4.6 Member Templates"></a>23.4.6 Member Templates</h4><ol start="36">
<li><p>A class or a class template can have members that are themselves templates. </p>
<ul>
<li><p>This allows us to represent related types with a pleasing degree of control and flexibility. </p>
</li>
<li><p>For example, complex numbers are best represented as pairs of values of some scalar type:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Scalar&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br>    Scalar re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>() :re&#123;&#125;, im&#123;&#125; &#123;&#125; <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-title">complex</span><span class="hljs-params">(T rr, T ii =<span class="hljs-number">0</span>)</span> :re&#123;</span>rr&#125;, im&#123;ii&#125; &#123; &#125;<br>    <br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">const</span> complex&amp;) = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// copy constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">const</span> complex&lt;T&gt;&amp; c)</span> : re&#123;</span>c.<span class="hljs-built_in">real</span>()&#125;, im&#123;c.<span class="hljs-built_in">imag</span>()&#125; &#123; &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>This allows mathematically meaningful conversions among complex types, while <strong>prohibiting the undesirable narrowing conversions</strong> (§10.5.2.6):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex&lt;<span class="hljs-type">float</span>&gt; cf; <span class="hljs-comment">// default value</span><br>complex&lt;<span class="hljs-type">double</span>&gt; cd &#123;cf&#125;; <span class="hljs-comment">// OK: uses float to double conversion</span><br>complex&lt;<span class="hljs-type">float</span>&gt; cf2 &#123;cd&#125;; <span class="hljs-comment">// error : no implicit double-&gt;float conversion</span><br><br>complex&lt;<span class="hljs-type">float</span>&gt; cf3 &#123;<span class="hljs-number">2.0</span>,<span class="hljs-number">3.0</span>&#125;; <span class="hljs-comment">// error : no implicit double-&gt;float conversion</span><br>complex&lt;<span class="hljs-type">double</span>&gt; cd2 &#123;<span class="hljs-number">2.0F</span>,<span class="hljs-number">3.0F</span>&#125;; <span class="hljs-comment">// OK: uses float to double conversion</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quad</span> &#123;<br>    <span class="hljs-comment">// no conversion to int</span><br>&#125;;<br><br>complex&lt;Quad&gt; cq;<br>complex&lt;<span class="hljs-type">int</span>&gt; ci &#123;cq&#125;; <span class="hljs-comment">// error : no Quad to int conversion</span><br></code></pre></td></tr></table></figure></li>
<li><p>Given this definition of <code>complex</code>, we can construct a <code>complex&lt;T1&gt;</code> from a <code>complex&lt;T2&gt;</code> or from a pair of <code>T2</code> values if and only if we can construct a <code>T1</code> from a <code>T2</code>. </p>
<p>That seems reasonable.</p>
</li>
<li><p>Be warned that the narrowing error in the <code>complex&lt;double&gt;</code> to <code>complex&lt;float&gt;</code> case will not be caught until the instantiation of <code>complex&lt;float&gt;</code>’s template constructors and then only because I used the <code>&#123;&#125;</code> initialization syntax (§6.3.5) in the constructor’s member initializers. </p>
<ul>
<li>That syntax does not allow narrowing.</li>
</ul>
</li>
<li><p>Using the (old) <code>()</code> syntax would leave us open to narrowing errors. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Scalar&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123; <span class="hljs-comment">// old style</span><br>    Scalar re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>() :<span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-title">complex</span><span class="hljs-params">(T rr, T ii =<span class="hljs-number">0</span>)</span> :re(rr), im(ii) &#123;</span> &#125;<br>    <br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">const</span> complex&amp;) = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// copy constructor</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">const</span> complex&lt;T&gt;&amp; c)</span> : re(c.real()), im(c.imag()) &#123;</span> &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br>complex&lt;<span class="hljs-type">float</span>&gt; cf4 &#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">2.9</span>&#125;; <span class="hljs-comment">// ouch! narrows</span><br>complex&lt;<span class="hljs-type">float</span>&gt; cf5 &#123;cd&#125;; <span class="hljs-comment">// ouch! narrows</span><br></code></pre></td></tr></table></figure></li>
<li><p>I consider this yet another reason to be consistent in the use of the <code>&#123;&#125;</code> notation for initialization.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="23-4-6-1-Templates-and-Constructors"><a href="#23-4-6-1-Templates-and-Constructors" class="headerlink" title="23.4.6.1 Templates and Constructors"></a>23.4.6.1 Templates and Constructors</h5><ol start="37">
<li><p>To minimize the chances of confusion, I explicitly added a default copy constructor. </p>
<ul>
<li>Leaving it out would not change the meaning of the definition: <code>complex</code> would still get a default copy constructor.</li>
</ul>
<p>For technical reasons, <strong>a template constructor is never used to generate a copy constructor</strong>, so <strong>without the explicitly declared copy constructor</strong>, a <strong>default copy constructor would have been generated</strong>.</p>
<p>Similarly, <strong>copy assignments</strong>, <strong>move constructors</strong>, and <strong>move assignments</strong> (§17.5.1, §17.6, §19.3.1) must be defined as non-template operators or the default versions will be generated.</p>
</li>
</ol>
<h5 id="23-4-6-2-Templates-and-virtual"><a href="#23-4-6-2-Templates-and-virtual" class="headerlink" title="23.4.6.2 Templates and virtual"></a>23.4.6.2 Templates and <code>virtual</code></h5><ol start="38">
<li><p>A member template cannot be <code>virtual</code>. </p>
<ul>
<li><p>For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// error: virtual template</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>This must be illegal. </p>
<ul>
<li>If it were allowed, the traditional virtual function table technique for implementing virtual functions (§3.2.3) could not be used. <ul>
<li>The linker would have to add a new entry to the virtual table for class <code>Shape</code> each time someone called <code>intersect()</code> with a new argument type.</li>
<li>Complicating the implementation of the linker in this way was considered unacceptable. </li>
</ul>
</li>
<li>In particular, handling dynamic linking would require implementation techniques rather different from what is most commonly used.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="23-4-6-3-Use-of-Nesting"><a href="#23-4-6-3-Use-of-Nesting" class="headerlink" title="23.4.6.3 Use of Nesting"></a>23.4.6.3 Use of Nesting</h5><ol start="39">
<li><p>In general, it is a good idea to keep information as local as possible. </p>
<ul>
<li><p>That way, a name is easier to find and less likely to interfere with anything else in a program. </p>
</li>
<li><p>This line of thinking leads to types being defined as members. </p>
</li>
<li><p>Doing so is often a good idea. </p>
</li>
</ul>
<p>However, for members of class templates we must consider if the parameterization is appropriate for a member type. </p>
<ul>
<li><p>Formally, a member of a template depends on all of a template’s arguments. </p>
</li>
<li><p>That can have <strong>unfortunate side effects</strong> in cases where the behavior of <strong>the member does not in fact use every template argument</strong>. </p>
</li>
<li><p>A famous example is a link type of a linked list. </p>
</li>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Link</span> &#123;<br>        T val;<br>        Link∗ succ;<br>        Link∗ prev;<br>    &#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Here, <code>Link</code> is an implementation detail of <code>List</code>. </li>
<li>Thus, it seems a perfect example of a type best defined in the scope of <code>List</code> and even kept <code>private</code>. <ul>
<li>This has been a popular design and generally works very well. </li>
<li>But surprisingly, it can imply performance cost compared to using a nonlocal <code>Link</code> type. </li>
</ul>
</li>
<li>Assume that no member of <code>Link</code> depends on the <code>Allocator</code> parameter, and that we need<br><code>List&lt;double ,My_allocator&gt;</code> and <code>List&lt;double ,Your_allocator&gt;</code>. <ul>
<li>Now <code>List&lt;double ,My_allocator&gt;::Link</code> and <code>List&lt;double, Your_allocator&gt;::Link</code> are different types, so code using them cannot (without clever optimizers) be identical. </li>
<li>That is, making <code>Link</code> a member when it uses only one of <code>List</code>’s two template parameters implies some code bloat. </li>
</ul>
</li>
</ul>
</li>
<li><p>This leads us to consider a design where <code>Link</code> isn’t a member:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Link</span> &#123;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> A&gt;<br>    	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;<br>    T val;<br>    Link∗ succ;<br>    Link∗ prev;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>I made all members of <code>Link</code> <code>private</code> and granted <code>List</code> access. </li>
<li>Except for making the name <code>Link</code> nonlocal, this preserves the design intent that <code>Link</code> is an implementation detail of <code>List</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="40">
<li><p>But what if a nested class is not considered an implementation detail? </p>
<ul>
<li><p>That is, what if we need an associated type that is meant for a variety of users? </p>
</li>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>        Link&lt;T&gt;∗ current_position;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// ... usual iterator operations ...</span><br>    &#125;;<br>    <br>    <span class="hljs-function">Iterator&lt;T,A&gt; <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterator&lt;T,A&gt; <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Here, the member type <code>List&lt;T,A&gt;::Iterator</code> (obviously) does not use the second template argument <code>A</code>.</p>
</li>
<li><p>However, because <code>Iterator</code> is a member and therefore formally depends on <code>A</code> (the compiler doesn’t know anything to the contrary), we can’t write a function to process <code>List</code>s independently of how they were constructed using allocators:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fct</span><span class="hljs-params">(List&lt;<span class="hljs-type">int</span>&gt;::Iterator b, List&lt;<span class="hljs-type">int</span>&gt;::Iterator e)</span> <span class="hljs-comment">// error : List takes two arguments</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">find</span>(b,e,<span class="hljs-number">17</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">(List&lt;<span class="hljs-type">int</span>,My_allocator&gt;&amp; lm, List&lt;<span class="hljs-type">int</span>,Your_allocator&gt;&amp; ly)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fct</span>(lm.<span class="hljs-built_in">begin</span>(),lm.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">fct</span>(ly.<span class="hljs-built_in">begin</span>(),ly.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Instead, we need to write a function template with a dependence on the allocator argument:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fct</span><span class="hljs-params">(List&lt;<span class="hljs-type">int</span>,My_allocator&gt;::Iterator b, 			 </span></span><br><span class="hljs-params"><span class="hljs-function">         List&lt;<span class="hljs-type">int</span>,My_allocator&gt;::Iterator e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">find</span>(b,e,<span class="hljs-number">17</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>However, that breaks our <code>user()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">(List&lt;<span class="hljs-type">int</span>,My_allocator&gt;&amp; lm, List&lt;<span class="hljs-type">int</span>,Your_allocator&gt;&amp; ly)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fct</span>(lm.<span class="hljs-built_in">begin</span>(),lm.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">fct</span>(ly.<span class="hljs-built_in">begin</span>(),ly.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// error : fct takes </span><br>    							<span class="hljs-comment">// List&lt;int,My_allocator&gt;::Iterators</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>We could make <code>fct</code> a template and generate separate specializations for each allocator. </p>
<ul>
<li>However, that would generate a new specialization for every use of <code>Iterator</code>, so this could lead to significant code bloat [Tsafrir,2009]. </li>
</ul>
</li>
<li><p>Again, we solve the problem by moving <code>Link</code> out of the class template:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    Link&lt;T&gt;∗ current_position;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This makes iterators for every <code>List</code> with the same first template argument interchangeable as far as their types are concerned. <ul>
<li>In this case, that was exactly what we wanted. </li>
<li>Our <code>user()</code> now works as defined. </li>
</ul>
</li>
<li>Had <code>fct()</code> been defined to be a function template, there would have been only one copy (instantiation) of the definition of <code>fct()</code>. </li>
<li>My rule of thumb is ‘‘<strong>A void nested types in templates unless they genuinely rely on every template parameter</strong>.’’ <ul>
<li>This is a special case of the general rule to avoid unnecessary dependencies in code.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="23-4-7-Friends"><a href="#23-4-7-Friends" class="headerlink" title="23.4.7 Friends"></a>23.4.7 Friends</h4><ol start="41">
<li><p>As shown in §23.4.6.3, a template class can designate functions as friends. </p>
<p>Consider the <code>Matrix</code> and <code>Vector</code> example from §19.4. </p>
<ul>
<li><p>Typically, both <code>Matrix</code> and <code>Vector</code> will be templates:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br>    T v[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> Vector <span class="hljs-keyword">operator</span>∗&lt;&gt;(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp;, <span class="hljs-type">const</span> Vector&amp;);<span class="hljs-comment">//&lt;&gt; is needed</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span> &#123;<br>    Vector&lt;T&gt; v[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> Vector&lt;T&gt; <span class="hljs-keyword">operator</span>∗&lt;&gt;(<span class="hljs-type">const</span> Matrix&amp;, <span class="hljs-type">const</span> Vector&lt;T&gt;&amp;);<span class="hljs-comment">// &lt;&gt; </span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>The <code>&lt;&gt;</code> after the name of the friend function is needed</strong> to make clear that the friend is a template function. </li>
<li>Without the <code>&lt;&gt;</code>, a non-template function would be assumed. </li>
</ul>
</li>
<li><p>The multiplication operator can then be defined to access data from <code>Vector</code> and <code>Matrix</code> directly:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Vector&lt;T&gt; <span class="hljs-keyword">operator</span>∗(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; m, <span class="hljs-type">const</span> Vector&lt;T&gt;&amp; v)<br>&#123;<br>    Vector&lt;T&gt; r;<br>    <span class="hljs-comment">// ... use m.v[i] and v.v[i] for direct access to elements ...</span><br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="42">
<li><p>Friends do not affect the scope in which the template class is defined, nor do they affect the scope in which the template is used. </p>
<ul>
<li>Instead, friend functions and operators are found using a lookup based on their argument types (§14.2.4, §18.2.5, §iso.11.3). </li>
</ul>
<p>Like a member function, <strong>a friend function is instantiated only if it is used</strong> (§26.2.1).</p>
</li>
</ol>
<ol start="43">
<li><p>Like other classes, a class template can designate other classes as <code>friend</code>s. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>;<br><span class="hljs-keyword">using</span> C2 = C;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_class</span> &#123;<br>    <span class="hljs-keyword">friend</span> C; <span class="hljs-comment">// OK: C is a class</span><br>    <span class="hljs-keyword">friend</span> C2; <span class="hljs-comment">// OK: C2 is an alias for a class</span><br>    <span class="hljs-keyword">friend</span> C3; <span class="hljs-comment">// error : no class C3 in scope</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C4</span>; <span class="hljs-comment">// OK: introduces a new class C4</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Naturally, the interesting cases are those where the friend depends on a template argument. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_other_class</span> &#123;<br>    <span class="hljs-keyword">friend</span> T; <span class="hljs-comment">// my argument is my friend!</span><br>    <span class="hljs-keyword">friend</span> My_class&lt;T&gt;; <span class="hljs-comment">// My_class with the corresponding argument is</span><br>    					<span class="hljs-comment">// my friend</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>; <span class="hljs-comment">// error : redundant ‘ class’’</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>As ever, <strong>friendship is neither inherited nor transitive</strong> (§19.4). </p>
<ul>
<li>For example, <code>C</code> has not become a friend of <code>My_other_class&lt;int&gt;</code> even though <code>My_class&lt;int&gt;</code> is a friend and <code>C</code> is a friend of <code>My_class&lt;int&gt;</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="44">
<li><p>We cannot directly make a template a friend of a class, but we can make a friend declaration a template. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Link</span> &#123;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> A&gt;<br>    	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>Unfortunately, there is no way of saying that <code>Link&lt;X&gt;</code> should only be a friend of <code>List&lt;X&gt;</code>.</p>
</li>
</ul>
</li>
</ol>
<ol start="45">
<li><p>Friend classes are designed to allow the representation of small clusters of closely related concepts.</p>
<p>A complicated pattern of friendship is almost certainly a design error.</p>
</li>
</ol>
<h3 id="23-5-Function-Templates"><a href="#23-5-Function-Templates" class="headerlink" title="23.5 Function Templates"></a>23.5 Function Templates</h3><ol start="46">
<li><p>For many people, the first and most obvious use of templates is to define and use container classes such as <code>vector</code> (§31.4), <code>list</code> (§31.4.2), and <code>map</code> (§31.4.3). </p>
<p>Soon after, the need for function templates to manipulate such containers arises. </p>
<ul>
<li><p>Sorting a vector is a simple example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;T&gt;&amp;)</span></span>; <span class="hljs-comment">// declaration</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vi, vector&lt;string&gt;&amp; vs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(vi); <span class="hljs-comment">// sort(vector&lt;int&gt;&amp;);</span><br>    <span class="hljs-built_in">sort</span>(vs); <span class="hljs-comment">// sort(vector&lt;str ing&gt;&amp;);</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>When a function template is called, <strong>the types of the function arguments determine which version of</strong><br><strong>the template is used</strong>.</p>
<ul>
<li>That is, the template arguments are deduced from the function arguments (§23.5.2).</li>
</ul>
<p>Naturally, the function template must be defined somewhere (§23.7):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;T&gt;&amp; v)</span> <span class="hljs-comment">// definition</span></span><br><span class="hljs-function">	<span class="hljs-comment">// Shell sort (Knuth, Vol. 3, pg. 84)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> n = v.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap=n/<span class="hljs-number">2</span>; <span class="hljs-number">0</span>&lt;gap; gap/=<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=gap; i&lt;n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i−gap; <span class="hljs-number">0</span>&lt;=j; j−=gap)<br>                <span class="hljs-keyword">if</span> (v[j+gap]&lt;v[j]) &#123; <span class="hljs-comment">// swap v[j] and v[j+gap]</span><br>                    T temp = v[j];<br>                    v[j] = v[j+gap];<br>                    v[j+gap] = temp;<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Please compare this definition to the <code>sort()</code> defined in §12.5. <ul>
<li>This templatized version is cleaner and shorter because it can rely on more information about the type of the elements it sorts. </li>
<li>Typically, it is also faster because it doesn’t rely on a pointer to function for the comparison. <ul>
<li>This implies that no indirect function calls are needed and that inlining a simple <code>&lt;</code> is easy.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A further simplification is to use the standard-library template <code>swap()</code> (§35.5.2) to reduce the action to its natural form:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (v[j+gap]&lt;v[j])<br>    <span class="hljs-built_in">swap</span>(v[j],v[j+gap]);<br></code></pre></td></tr></table></figure>

<ul>
<li>This does not introduce any new overhead. </li>
<li>Better yet, the standard-library <code>swap()</code> uses move semantics, so we may see a speedup (§35.5.2).</li>
</ul>
</li>
</ol>
<ol start="47">
<li><p>In this example, operator <code>&lt;</code> is used for comparison. </p>
<p>However, not every type has a <code>&lt;</code> operator.</p>
<p>This limits the use of this version of <code>sort()</code>, but the limitation is easily avoided by adding an argument (see §25.2.3). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Compare = std::less&lt;T&gt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">sort</span>(vector&lt;T&gt;&amp; v) <span class="hljs-comment">// definition</span><br>	<span class="hljs-comment">// Shell sort (Knuth, Vol. 3, pg. 84)</span><br>&#123;<br>    Compare cmp; <span class="hljs-comment">// make a default Compare object</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> n = v.siz <span class="hljs-built_in">e</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap=n/<span class="hljs-number">2</span>; <span class="hljs-number">0</span>&lt;gap; gap/=<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=gap; i&lt;n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i−gap; <span class="hljs-number">0</span>&lt;=j; j−=gap)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(v[j+gap],v[j]))<br>                    <span class="hljs-built_in">swap</span>(v[j],v[j+gap]);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>We can now sort using the default comparison operation (<code>&lt;</code>) or supply our own:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">No_case</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; a, <span class="hljs-type">const</span> string&amp; b)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// compare case insensitive</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vi, vector&lt;string&gt;&amp; vs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(vi); <span class="hljs-comment">// sort(vector&lt;int&gt;&amp;)</span><br>    sort&lt;<span class="hljs-type">int</span>,std::greater&lt;<span class="hljs-type">int</span>&gt;&gt;(vi); <span class="hljs-comment">// sort(vector&lt;int&gt;&amp;) using greater</span><br>    <br>    <span class="hljs-built_in">sort</span>(vs); <span class="hljs-comment">// sort(vector&lt;str ing&gt;&amp;)</span><br>    <span class="hljs-built_in">sort</span>&lt;string,No_case&gt;(vs); <span class="hljs-comment">// sor t(vector&lt;string&gt;&amp;) using No_case</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Unfortunately, the rule that <strong>only trailing template arguments can be specified</strong> leads us to have to specify (rather than deduce) the element type when we specify the comparison operations.</p>
<ul>
<li>只有argument list中的末尾参数可以被指定默认值，因此使用自己指定的comparison operation的时候，必须要显示指定element type.</li>
<li>The explicit specification of function template arguments is explained in §23.5.2.</li>
</ul>
</li>
</ol>
<h4 id="23-5-1-Function-Template-Arguments"><a href="#23-5-1-Function-Template-Arguments" class="headerlink" title="23.5.1 Function Template Arguments"></a>23.5.1 Function Template Arguments</h4><ol start="48">
<li><p>Function templates are essential for writing generic algorithms to be applied to a wide variety of container types (§3.4.2, §32.2). </p>
<p>The ability to deduce template arguments for a call from the function arguments is crucial.</p>
<p>A compiler can deduce type and non-type arguments from a call, provided the function argument list uniquely identifies the set of template arguments. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> max&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Buffer</span> &#123;<br>    T buf[max];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> max&gt;</span><br><span class="hljs-function">T&amp; <span class="hljs-title">lookup</span><span class="hljs-params">(Buffer&lt;T,max&gt;&amp; b, <span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ p)</span></span>;<br><br><span class="hljs-function">Record&amp; <span class="hljs-title">f</span><span class="hljs-params">(Buffer&lt;string,<span class="hljs-number">128</span>&gt;&amp; buf, <span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lookup</span>(buf,p); <span class="hljs-comment">// use the lookup() where T is string and i is 128</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Here, <code>lookup()</code>’s <code>T</code> is deduced to be <code>string</code> and <code>max</code> is deduced to be <code>128</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="49">
<li><p>Note that class template parameters are never deduced. </p>
<ul>
<li>The reason is that the flexibility provided by several constructors for a class would make such deduction impossible in many cases and obscure in many more. </li>
</ul>
<p>Instead, specialization (§25.3) provides a mechanism for implicitly choosing between alternative definitions of a template. </p>
<p><strong>If we need to create an object of a deduced type, we can often do that by calling a function to do the deduction (and creation)</strong>. </p>
<ul>
<li><p>For example, consider a simple variant of the standard library’s <code>make_pair()</code> (§34.2.4.1):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function">pair&lt;T1,T2&gt; <span class="hljs-title">make_pair</span><span class="hljs-params">(T1 a, T2 b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;a,b&#125;;<br>&#125;<br><br><span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// x is a pair&lt;int,int&gt;</span><br><span class="hljs-keyword">auto</span> y = <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;New York&quot;</span>),<span class="hljs-number">7.7</span>); <span class="hljs-comment">// y is a pair&lt;string,double&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>If a template argument cannot be deduced</strong> from the function arguments (§23.5.2), we must <strong>specify it explicitly</strong>.</p>
<p>This is done in the same way that template arguments are explicitly specified for a template class (§25.2, §25.3). </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T∗ <span class="hljs-built_in">create</span>(); <span class="hljs-comment">//make a T and return a pointer to it</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v; <span class="hljs-comment">// class, template argument int</span><br>    <span class="hljs-type">int</span>∗ p = <span class="hljs-built_in">create</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// function, template argument int</span><br>    <span class="hljs-type">int</span>∗ q = <span class="hljs-built_in">create</span>(); <span class="hljs-comment">// error : can’t deduce template argument</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>This use of explicit specification to provide a return type for a function template is very common.</p>
<ul>
<li>It allows us to define families of object creation functions (e.g., <code>create()</code>) and conversion functions (e.g., §27.2.2). </li>
</ul>
</li>
<li><p>The syntax for <code>static_cast</code>, <code>dynamic_cast</code>, etc. (§11.5.2, §22.2.1), matches the explicitly qualified function template syntax.</p>
</li>
</ul>
</li>
</ol>
<ol start="50">
<li>Default template arguments can be used to simplify explicit qualification in some cases (§25.2.5.1).</li>
</ol>
<h4 id="23-5-2-Function-Template-Argument-Deduction"><a href="#23-5-2-Function-Template-Argument-Deduction" class="headerlink" title="23.5.2 Function Template Argument Deduction"></a>23.5.2 Function Template Argument Deduction</h4><ol start="51">
<li><p>A compiler can deduce a type template argument, <code>T</code> or <code>TT</code>, and a non-type template argument, <code>I</code>, from a template function argument with a type composed of the following constructs (§iso.14.8.2.1):</p>
<p><img src="image-20230213144019458.png" srcset="/img/loading.gif" lazyload alt="image-20230213144019458"></p>
<ul>
<li>Here, <code>args_TI</code> is a parameter list from which a <code>T</code> or an <code>I</code> can be determined by recursive application of these rules, and <code>args</code> is a parameter list that does not allow deduction. </li>
</ul>
<p>If not all parameters can be deduced in this way, a call is ambiguous. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T∗, U(∗)(U))</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>∗ p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(p,g); <span class="hljs-comment">// T is char, U is int</span><br>    <span class="hljs-built_in">f</span>(p,h); <span class="hljs-comment">// error : can’t deduce U</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Looking at the arguments of the first call of <code>f()</code>, we easily deduce the template arguments. </li>
<li>Looking at the second call of <code>f()</code>, we see that <code>h()</code> doesn’t match the pattern <code>U(∗)(U)</code> because <code>h()</code>’s argument and return types differ.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="52">
<li><p><strong>If a template parameter can be deduced from more than one function argument, the same type must be the result of each deduction</strong>. </p>
<p>Otherwise, the call is an error. </p>
<ul>
<li><p>如果由多个参数可以用于deduce模板参数，那么所有的参数deduce的类型必须是一致，否则就是错的。</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T i, T∗ p)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(i,&amp;i); <span class="hljs-comment">//OK</span><br>    <span class="hljs-built_in">f</span>(i,<span class="hljs-string">&quot;Remember!&quot;</span>); <span class="hljs-comment">// error, ambiguous: T is int or T is const char?</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="23-5-2-1-Reference-Deduction"><a href="#23-5-2-1-Reference-Deduction" class="headerlink" title="23.5.2.1 Reference Deduction"></a>23.5.2.1 Reference Deduction</h5><ol start="53">
<li><p>It can be useful to have different actions taken for lvalues and rvalues. </p>
<p>Consider a class for holding an {integer,pointer} pair:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Xref</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Xref</span>(<span class="hljs-type">int</span> i, T∗ p) <span class="hljs-comment">// store a pointer: Xref is the owner</span><br>        :index&#123;i&#125;, elem&#123;p&#125;, owner&#123;<span class="hljs-literal">true</span>&#125;<br>    &#123; &#125;<br>    <span class="hljs-built_in">Xref</span>(<span class="hljs-type">int</span> i, T&amp; r) <span class="hljs-comment">// store a pointer to r, owned by someone else</span><br>        :index&#123;i&#125;, elem&#123;&amp;r&#125;, owner&#123;<span class="hljs-literal">false</span>&#125;<br>    &#123; &#125;<br>    <span class="hljs-built_in">Xref</span>(<span class="hljs-type">int</span> i, T&amp;&amp; r) <span class="hljs-comment">// move r into Xref, Xref is the owner</span><br>        :index&#123;i&#125;, elem&#123;<span class="hljs-keyword">new</span> T&#123;<span class="hljs-built_in">move</span>(r)&#125;&#125;, owner&#123;<span class="hljs-literal">true</span>&#125;<br>    &#123; &#125;<br>    ˜<span class="hljs-built_in">Xref</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(owned) <span class="hljs-keyword">delete</span> elem;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> index;<br>    T∗ elem;<br>    <span class="hljs-type">bool</span> owned;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>So:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">string x &#123;<span class="hljs-string">&quot;There and back again&quot;</span>&#125;;<br><br>Xref&lt;string&gt; r1 &#123;<span class="hljs-number">7</span>,<span class="hljs-string">&quot;Here&quot;</span>&#125;; <span class="hljs-comment">// r1 owns a copy of string&#123;&quot;Here&quot;&#125;</span><br>Xref&lt;string&gt; r2 &#123;<span class="hljs-number">9</span>,x&#125;; <span class="hljs-comment">// r2 just refers to x</span><br>Xref&lt;string&gt; r3 &#123;<span class="hljs-number">3</span>,<span class="hljs-keyword">new</span> string&#123;<span class="hljs-string">&quot;There&quot;</span>&#125;&#125;; <span class="hljs-comment">// r3 owns the string&#123;&quot;There&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Here, <code>r1</code> picks <code>Xref(int,string&amp;&amp;)</code> because <code>&quot;Here&quot;</code> is an rvalue.</li>
<li>Similarly, <code>r2</code> picks <code>Xref(int,string&amp;)</code> because <code>x</code> is an lvalue.</li>
</ul>
<p>Lvalues and rvalues are distinguished by template argument deduction: <strong>an lvalue of type <code>X</code> is deduced as an <code>X&amp;</code></strong> and <strong>an rvalue as <code>X</code></strong>. </p>
<ul>
<li><p>This differs from the binding of values to non-template argument rvalue references (§12.2.1) but is especially useful for argument forwarding (§35.5.1). </p>
</li>
<li><p>Consider writing a factory function that make <code>Xref</code>s on the free store and returns <code>unique_ptr</code>s to them:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">std::forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp; t)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// §35.5.1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">std::forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TT, <span class="hljs-keyword">typename</span> A&gt;</span><br><span class="hljs-function">unique_ptr&lt;TT&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(<span class="hljs-type">int</span> i, A&amp;&amp; a)</span> </span><br><span class="hljs-function">	<span class="hljs-comment">// simple variant of make_shared (§34.3.2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> unique_ptr&lt;TT&gt;&#123;<span class="hljs-keyword">new</span> TT&#123;i,forward&lt;A&gt;(a)&#125;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>We want <code>make_unique&lt;T&gt;(arg)</code> to construct a <code>T</code> from an <code>arg</code> without making any spurious copies. </p>
<p>To do that, it is essential that the lvalue/rvalue distinction is maintained. </p>
<p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> p1 = make_unique&lt;Xref&lt;string&gt;&gt;(<span class="hljs-number">7</span>,<span class="hljs-string">&quot;Here&quot;</span>); <span class="hljs-comment">// TT is Xref</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>&quot;Here&quot;</code> is an rvalue, so <code>forward(string&amp;&amp;)</code> is called, passing along an rvalue, so that <code>Xref(int,string&amp;&amp;)</code> is called to move from the <code>string</code> holding <code>&quot;Here&quot;</code>.</li>
</ul>
</li>
<li><p>The more interesting (subtle) case is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> p2 = make_unique&lt;Xref&lt;string&gt;&gt;(<span class="hljs-number">9</span>,x); <span class="hljs-comment">// TT is Xref</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Here, <code>x</code> is an lvalue, so <code>forward(string&amp;)</code> is called, passing along an lvalue: <code>forward()</code>’s <code>T</code> is deduced to <code>string&amp;</code> so that the return value becomes <code>string&amp; &amp;&amp;</code>, which means <code>string&amp;</code> (§7.7.3). </li>
<li>Thus, <code>Xref(int,string&amp;)</code> is called for the lvalue <code>x</code>, so that <code>x</code> is copied.</li>
</ul>
</li>
<li><p>Unfortunately, <code>make_unique()</code> is not part of the standard library, but it is widely supported nevertheless.</p>
<ul>
<li>Defining a <code>make_unique()</code> that can take arbitrary arguments is relatively easy using a variadic template for forwarding (§28.6.3).</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="23-5-3-Function-Template-Overloading"><a href="#23-5-3-Function-Template-Overloading" class="headerlink" title="23.5.3 Function Template Overloading"></a>23.5.3 Function Template Overloading</h4><ol start="54">
<li><p>We can declare several function templates with the same name and even declare a combination of function templates and ordinary functions with the same name. </p>
<p>When an overloaded function is called, overload resolution is necessary to find the right function or function template to invoke.</p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// function template</span><br><span class="hljs-function">T <span class="hljs-title">sqrt</span><span class="hljs-params">(T)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">complex&lt;T&gt; <span class="hljs-title">sqrt</span><span class="hljs-params">(complex&lt;T&gt;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>; <span class="hljs-comment">// ordinary function</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(complex&lt;<span class="hljs-type">double</span>&gt; z)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// sqrt&lt;int&gt;(int)</span><br>    <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.0</span>); <span class="hljs-comment">// sqrt(double)</span><br>    <span class="hljs-built_in">sqrt</span>(z); <span class="hljs-comment">// sqrt&lt;double&gt;(complex&lt;double&gt;)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>In the same way that a function template is a generalization of the notion of a function, the rules for resolution in the presence of function templates are generalizations of the function overload resolution rules. </p>
</li>
<li><p>Basically, <strong>for each template we find the specialization that is best for the set of function arguments</strong>. （首先对于参数匹配的模板，找到对应的specialization）</p>
<p><strong>Then, we apply the usual function overload resolution rules to these specializations and all ordinary functions</strong> (§iso.14.8.3)（再应用function overload resolution）:</p>
<ol>
<li><p>Find the set of function template specializations (§23.2.2) that will take part in overload resolution. </p>
<p>Do this by considering each function template and deciding which template arguments, if any, would be used if no other function templates or functions of the same name were in scope. </p>
<ul>
<li>For the call <code>sqrt(z)</code>, this makes <code>sqrt&lt;double&gt;(complex&lt;double&gt;)</code> and <code>sqrt&lt;complex&lt;double&gt;&gt;(complex&lt;double&gt;)</code> candidates. </li>
</ul>
<p>See also §23.5.3.2.</p>
</li>
<li><p>If two function templates can be called and one is more specialized than the other (§25.3.3), consider only the most specialized template function in the following steps.</p>
<ul>
<li><p>For the call <code>sqrt(z)</code>, this means that <code>sqrt&lt;double&gt;(complex&lt;double&gt;)</code> is preferred over <code>sqrt&lt;complex&lt;double&gt;&gt;(complex&lt;double&gt;)</code>: any call that matches <code>sqrt&lt;T&gt;(complex&lt;T&gt;)</code> also matches <code>sqrt&lt;T&gt;(T)</code>.</p>
</li>
<li><p>选择最specialized template function。</p>
<ul>
<li><p><code>sqrt&lt;double&gt;(complex&lt;double&gt;)</code>更加specialized，因为匹配<code>sqrt&lt;double&gt;(complex&lt;double&gt;)</code>的一定都匹配<code>sqrt&lt;T&gt;(T)</code>。</p>
<p>但是反之则不然。</p>
<p>所以选择<code>sqrt&lt;double&gt;(complex&lt;double&gt;)</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Do overload resolution for this set of functions, plus any ordinary functions, as for ordinary functions (§12.3). </p>
<p>If <strong>a function template’s argument has been determined by template argument deduction</strong> (§23.5.2), that <strong>argument cannot also have promotions, standard conversions, or user-defined conversions applied</strong>. </p>
<ul>
<li>For <code>sqrt(2)</code>, <code>sqrt&lt;int&gt;(int)</code> is an exact match, so it is preferred over <code>sqrt(double)</code>.</li>
<li>通过template argument deduction出来的function’s template argument不能是进行过promotion、standard conversion或者user-defined conversion之后的参数。</li>
</ul>
</li>
<li><p>If a function and a specialization are equally good matches, the function is preferred.</p>
<ul>
<li>Consequently, <code>sqrt(double)</code> is preferred  over <code>sqrt&lt;double&gt;(double)</code> for <code>sqrt(2.0)</code>.</li>
</ul>
</li>
<li><p>If no match is found, the call is an error. </p>
<p>If we end up with two or more equally good matches, the call is ambiguous and is an error.</p>
</li>
</ol>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T,T)</span></span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> s = <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">k</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// max&lt;int&gt;(1,2)</span><br>    <span class="hljs-built_in">max</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">// max&lt;char&gt;(’a’,’b’)</span><br>    <span class="hljs-built_in">max</span>(<span class="hljs-number">2.7</span>,<span class="hljs-number">4.9</span>); <span class="hljs-comment">// max&lt;double&gt;(2.7,4.9)</span><br>    <span class="hljs-built_in">max</span>(s,<span class="hljs-number">7</span>); <span class="hljs-comment">// max&lt;int&gt;(int&#123;s&#125;,7) (trivial conversion used)</span><br>    <span class="hljs-built_in">max</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// error : ambiguous: max&lt;char,char&gt;() or max&lt;int,int&gt;()?</span><br>    <span class="hljs-built_in">max</span>(<span class="hljs-number">2.7</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">// error : ambiguous: max&lt;double,double&gt;() or max&lt;int,int&gt;()?</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The problem with the last two calls is that we don’t apply promotions and standard conversions until after template parameters have been uniquely determined. </li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="55">
<li><p>There is no rule telling the compiler to prefer one resolution over the other. </p>
<ul>
<li>In most cases, it is probably good that the language rules leave subtle decisions in the hands of the programmer. </li>
</ul>
<p>The alternative to surprising ambiguity errors is surprising results from unexpected resolutions. </p>
<p>People’s ‘‘intuitions’’ about overload resolution differ dramatically, so it is impossible to design a perfectly intuitive set of overload resolution rules.</p>
</li>
</ol>
<h5 id="23-5-3-1-Ambiguity-Resolution"><a href="#23-5-3-1-Ambiguity-Resolution" class="headerlink" title="23.5.3.1 Ambiguity Resolution"></a>23.5.3.1 Ambiguity Resolution</h5><ol start="56">
<li><p>We could resolve the two ambiguities by explicit qualification:</p>
<ul>
<li>使用explicit qualification来消除ambiguities。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// max&lt;int&gt;(int(’a’),1)</span><br>    <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">2.7</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">// max&lt;double&gt;(2.7,double(4))</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Alternatively, we could add suitable declarations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">int</span>&gt;(i,j); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> d)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">double</span>&gt;(i,d); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">double</span> d, <span class="hljs-type">int</span> i)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">double</span>&gt;(d,i); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">double</span>&gt;(d1,d2); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">max</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// max(int(’a’),1), using promotion</span><br>    <span class="hljs-built_in">max</span>(<span class="hljs-number">2.7</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">// max(2.7,4)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>For ordinary functions, ordinary overloading rules (§12.3) apply, and the use of <code>inline</code> ensures that no extra overhead is imposed.</li>
</ul>
</li>
</ol>
<ol start="57">
<li><p>The definition of <code>max()</code> is trivial, so we could have implemented the comparison directly rather than calling a specialization of <code>max()</code>. </p>
<p>However, using an explicit specialization of the template is an easy way of defining such resolution functions and can help maintenance by avoiding almost identical code in several functions.</p>
</li>
</ol>
<h5 id="23-5-3-2-Argument-Substitution-Failure"><a href="#23-5-3-2-Argument-Substitution-Failure" class="headerlink" title="23.5.3.2 Argument Substitution Failure"></a>23.5.3.2 Argument Substitution Failure</h5><ol start="58">
<li><p>When looking for a best match for a set of arguments for a function template, the compiler considers whether the argument can be used in the way required by the complete function template declaration (including the return type). </p>
<ul>
<li><p>匹配function template的argument的时候，compiler比较的是argument是否可以用于整个function template declaration。</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">typename</span> Iter::value_type <span class="hljs-title">mean</span><span class="hljs-params">(Iter first, Iter last)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span>∗ p, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">mean</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// OK</span><br>    <span class="hljs-keyword">auto</span> y = <span class="hljs-built_in">mean</span>(p,p+n); <span class="hljs-comment">// error</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Here, the initialization of <code>x</code> succeeds because the arguments match and <code>vector&lt;int&gt;::iterator</code> has a member called <code>value_type</code>. </p>
</li>
<li><p>The initialization of <code>y</code> fails because even though the arguments match, <code>int∗</code> does not have a member called <code>value_type</code>, so we cannot say:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>∗::<span class="hljs-function">value_type <span class="hljs-title">mean</span><span class="hljs-params">(<span class="hljs-type">int</span>∗,<span class="hljs-type">int</span>∗)</span></span>; <br><span class="hljs-comment">//int* does not have a member called value_type</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>However, what if there were another definition of <code>mean()</code>?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">typename</span> Iter::value_type <span class="hljs-title">mean</span><span class="hljs-params">(Iter first, Iter last)</span></span>; <span class="hljs-comment">// #1</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">mean</span><span class="hljs-params">(T∗,T∗)</span></span>; <span class="hljs-comment">//#2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span>∗ p, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">mean</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// OK: call #1</span><br>    <span class="hljs-keyword">auto</span> y = <span class="hljs-built_in">mean</span>(p,p+n); <span class="hljs-comment">// OK: call #2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>This works: both initializations succeed. </p>
</li>
<li><p>But why didn’t we get an error when trying to match <code>mean(p,p+n)</code> with the first template definition? </p>
<ul>
<li><p>The arguments match perfectly, but by substituting in the actual template argument <code>(int∗)</code>, we get the function declaration:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>∗::<span class="hljs-function">value_type <span class="hljs-title">mean</span><span class="hljs-params">(<span class="hljs-type">int</span>∗,<span class="hljs-type">int</span>∗)</span></span>; <br><span class="hljs-comment">// int* does not have a member called value_type</span><br></code></pre></td></tr></table></figure></li>
<li><p>That is garbage, of course: a pointer does not have a member <code>value_type</code>. </p>
</li>
<li><p>Fortunately, <strong>considering this possible declaration is not by itself an error</strong>. </p>
<ul>
<li>There is a language rule (§iso.14.8.2) that says that such a substitution failure is not an error. </li>
<li>It simply causes the template to be ignored; that is, the template does not contribute a specialization to the overload set. </li>
</ul>
</li>
</ul>
</li>
<li><p>That done, <code>mean(p,p+n)</code> matches declaration #2, which is called.</p>
</li>
</ul>
</li>
<li><p>Without the ‘‘substitution error is not a failure’’ rule, we would get compile-time errors even when error-free alternatives (such as #2) are available. </p>
<p>More, this rule gives us a general tool for selecting among templates. </p>
</li>
<li><p>Techniques based on this rule are described in §28.4. </p>
</li>
<li><p>In particular, the standard library provides <code>enable_if</code> to simplify conditional definition of templates (§35.4.2).</p>
</li>
</ul>
</li>
</ol>
<ol start="59">
<li><p>The rule is known under the unpronounceable acronym <strong>SFINAE (Substitution Failure Is Not An Error)</strong>. </p>
<p>SFINAE is often used as a verb with the ‘‘F’’ pronounced as a ‘‘v’’: ‘‘I SFINAEd away that constructor.’’ </p>
<p>That sounds quite impressive, but I tend to avoid this jargon. </p>
<p>‘‘The constructor was eliminated by a substitution failure’’ is clearer for most people and does less violence to the English language.</p>
</li>
</ol>
<ol start="60">
<li><p>So, if – in the process of generating a candidate function to resolve a function call – the compiler finds itself generating a template specialization that would be nonsensical, that candidate is not entered into the overloading set. </p>
<ul>
<li>生成的一个template specialization如果是nonsensical，则改specialization就不会进入candida overloading set。</li>
</ul>
<p>A template specialization is considered nonsensical if it would lead to a type error. </p>
<ul>
<li>如果一个template specialization会导致type error，那么它就是nonsensical。</li>
</ul>
<p>In this, we consider only a declaration; template function definitions and the definition of class members are not considered (or generated) unless they are actually used. </p>
<ul>
<li><p>在这里仅仅考虑的是declaration。</p>
<ul>
<li>template function definitions和definition of class members都不会考虑（或是生成）（除非最终使用的时候）。</li>
</ul>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt;</span><br><span class="hljs-function">Iter <span class="hljs-title">mean</span><span class="hljs-params">(Iter first, Iter last)</span> <span class="hljs-comment">// #1</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typename</span> Iter::value_type = ∗first;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T∗ <span class="hljs-built_in">mean</span>(T∗,T∗);					<span class="hljs-comment">// #2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span>∗ p, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">mean</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// OK: call #1</span><br>    <span class="hljs-keyword">auto</span> y = <span class="hljs-built_in">mean</span>(p,p+n); <span class="hljs-comment">// error : ambiguous</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The declaration of <code>mean()</code> #1 is fine for <code>mean(p,p+n)</code>. <ul>
<li>The compiler does not start to instantiate the body of that <code>mean()</code> and eliminate it because of the type error.</li>
</ul>
</li>
<li>Here, the result is an ambiguity error. <ul>
<li>Had <code>mean()</code> #2 not been present, declaration #1 would have been chosen and we would have suffered an instantiation-time error. <ul>
<li><code>mean()</code>并没有给出定义，所以选择#1，但是再instantiation的时候会出错。一次对于<code>int*</code>而言，并没有<code>int*::value_type</code>成员。</li>
</ul>
</li>
<li>Thus, a function may be chosen as the best match yet still fail to compile.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="23-5-3-3-Overloading-and-Derivation"><a href="#23-5-3-3-Overloading-and-Derivation" class="headerlink" title="23.5.3.3 Overloading and Derivation"></a>23.5.3.3 Overloading and Derivation</h5><ol start="61">
<li><p>The overload resolution rules ensure that function templates interact properly with inheritance:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B&lt;T&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B&lt;T&gt;∗)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(B&lt;<span class="hljs-type">int</span>&gt;∗ pb, D&lt;<span class="hljs-type">int</span>&gt;∗ pd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(pb); <span class="hljs-comment">//f&lt;int&gt;(pb) of course</span><br>    <span class="hljs-built_in">f</span>(pd); <span class="hljs-comment">//f&lt;int&gt;(static_cast&lt;B&lt;int&gt;*&gt;(pd));</span><br>    <span class="hljs-comment">// standard conversion D&lt;int&gt;* to B&lt;int&gt;* used</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>In this example, the function template <code>f()</code> accepts a <code>B&lt;T&gt;∗</code> for any type <code>T</code>. </li>
<li>We have an argument of type <code>D&lt;int&gt;∗</code>, so the compiler easily deduces that by choosing <code>T</code> to be <code>int</code>, the call can be uniquely resolved to a call of f(<code>B&lt;int&gt;∗</code>).</li>
</ul>
</li>
</ol>
<h5 id="23-5-3-4-Overloading-and-Non-Deduced-Parameters"><a href="#23-5-3-4-Overloading-and-Non-Deduced-Parameters" class="headerlink" title="23.5.3.4 Overloading and Non-Deduced Parameters"></a>23.5.3.4 Overloading and Non-Deduced Parameters</h5><ol start="62">
<li><p>A function argument that is not involved in the deduction of a template parameter is treated exactly as an argument of a non-template function. </p>
<ul>
<li><p>In particular, the usual conversion rules hold. </p>
</li>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function">T <span class="hljs-title">get_nth</span><span class="hljs-params">(C&amp; p, <span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// get the nth element</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>This function presumably returns the value of the <code>n</code>th element of a container of type <code>C</code>. </p>
</li>
<li><p>Because <code>C</code> has to be deduced from an actual argument of <code>get_nth()</code> in a call, conversions are not applicable to the first argument. </p>
</li>
<li><p>However, the second argument is perfectly ordinary, so the full range of possible conversions is considered. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Index</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// section 18.4.1 conversion operator</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, shor t s, Index i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i1 = <span class="hljs-built_in">get_nth</span>&lt;<span class="hljs-type">int</span>&gt;(v,<span class="hljs-number">2</span>); <span class="hljs-comment">// exact match</span><br>    <span class="hljs-type">int</span> i2 = <span class="hljs-built_in">get_nth</span>&lt;<span class="hljs-type">int</span>&gt;(v,s); <span class="hljs-comment">// standard conversion: short to int</span><br>    <span class="hljs-type">int</span> i3 = <span class="hljs-built_in">get_nth</span>&lt;<span class="hljs-type">int</span>&gt;(v,i); <span class="hljs-comment">// user-defined conversion: Index to int</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This notation is sometimes called <em><strong>explicit specialization</strong></em> (§23.5.1).</p>
</li>
</ol>
<h3 id="23-6-Template-Aliases"><a href="#23-6-Template-Aliases" class="headerlink" title="23.6 Template Aliases"></a>23.6 Template Aliases</h3><ol start="63">
<li><p>We can define an alias for a type with the <code>using</code> syntax or with the <code>typedef</code> syntax (§6.5). </p>
<p>The <code>using</code> syntax is more general in the important sense that it can be used to define an alias for a template with some of its arguments bound. </p>
<ul>
<li><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator = allocator&lt;T&gt;&gt; vector;<br><br><span class="hljs-keyword">using</span> Cvec = vector&lt;<span class="hljs-type">char</span>&gt;; <span class="hljs-comment">// both arguments are bound</span><br><br>Cvec vc = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;; <span class="hljs-comment">// vc is a vector&lt;char,allocator&lt;char&gt;&gt;</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = vector&lt;T,My_alloc&lt;T&gt;&gt;; <span class="hljs-comment">// vector using my allocator (2nd argument is bound)</span><br><br>Vec&lt;<span class="hljs-type">int</span>&gt; fib = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>&#125;; <span class="hljs-comment">// fib is a vector&lt;int,My_alloc&lt;int&gt;&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>In general, if we <strong>bind all arguments of a template</strong>, we get a <strong>type</strong>, but if we <strong>bind only some</strong>, we get a <strong>template</strong>. </p>
</li>
<li><p>Note that what we get from <code>using</code> in an alias definition is always an alias. </p>
<ul>
<li><p>That is, when we use the alias, it is completely equivalent to a use of the original template. </p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">char</span>,alloc&lt;<span class="hljs-type">char</span>&gt;&gt; vc2 = vc; <span class="hljs-comment">// vc2 and vc are of the same type</span><br>vector&lt;<span class="hljs-type">int</span>,My_alloc&lt;<span class="hljs-type">int</span>&gt;&gt; verbose = fib; <span class="hljs-comment">// verbose and fib are of the same type</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>The equivalence of the alias and the original template implies that <strong>if you specialize the template, you (correctly) get the specializations when you use the alias</strong>. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">int_exact_traits</span> &#123; <br>    <span class="hljs-comment">// idea: int_exact_traits&lt;N&gt;::type is a type with exactly N bits</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">int</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">int_exact_traits</span>&lt;<span class="hljs-number">8</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">char</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">int_exact_traits</span>&lt;<span class="hljs-number">16</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-type">short</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">using</span> int_exact = <span class="hljs-keyword">typename</span> int_exact_traits&lt;N&gt;::type; <br><span class="hljs-comment">// define alias for convenient notation</span><br><br>int_exact&lt;<span class="hljs-number">8</span>&gt; a = <span class="hljs-number">7</span>; <span class="hljs-comment">// int_exact&lt;8&gt; is an int with 8 bits</span><br></code></pre></td></tr></table></figure></li>
<li><p>If specializations did not get used through the alias, we couldn’t claim that <code>int_exact</code> was simply an alias for <code>int_exact_traits&lt;N&gt;::type</code>; they would behave differently. </p>
<ul>
<li>使用alias的时候，就会得到specialization。如果没有specialization，<code>int_exact</code>与<code>int_exact_traits&lt;N&gt;::type</code>不同。</li>
</ul>
</li>
<li><p>On the other hand, you cannot define a specialization of an alias. </p>
<ul>
<li>If you had been able to, it would have been rather easy for a human reader to get confused about what was specialized, so no syntax is provided for specializing an alias.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="23-7-Source-Code-Organization"><a href="#23-7-Source-Code-Organization" class="headerlink" title="23.7 Source Code Organization"></a>23.7 Source Code Organization</h3><ol start="64">
<li><p>There are three reasonably obvious ways of organizing code using templates:</p>
<ul>
<li>[1] Include template definitions before their use in a translation unit.</li>
<li>[2] Include template declarations (only) before their use in a translation unit. <ul>
<li>Include definitions of templates later in the translation unit (potentially after their use).</li>
</ul>
</li>
<li>[3] Include template declarations (only) before their use in a translation unit. <ul>
<li>Define the templates in some other translation unit.</li>
</ul>
</li>
</ul>
<p>For technical and historical reasons, option [3], the separate compilation of template definitions and their uses, is not offered.</p>
<p>By far the most common approach is to include (usually <code>#include</code>) the definition of the templates you use in every translation unit in which you use them and rely on your implementation to optimize compile times and eliminate object code duplication. </p>
<ul>
<li><p>For example, I might provide a template <code>out()</code> in a header <code>out.h</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file out.h:</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cerr &lt;&lt; t;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>We would <code>#include</code> this header wherever <code>out()</code> was needed. </p>
<ul>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file user1.cpp:</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;out.h&quot;</span></span><br><span class="hljs-comment">// use out()</span><br></code></pre></td></tr></table></figure></li>
<li><p>and</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file user2.cpp:</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;out.h&quot;</span></span><br><span class="hljs-comment">// use out()</span><br></code></pre></td></tr></table></figure></li>
<li><p>That is, the definition of <code>out()</code> and all declarations on which it depends are <code>#include</code>d in several different compilation units.</p>
<ul>
<li><code>out()</code>的定义和其所有的declaration在不同的compilation units。</li>
</ul>
</li>
<li><p>It is up to the compiler to generate code when needed (only) and to optimize the process of reading redundant definitions. </p>
<ul>
<li>This strategy treats template functions the same way as inline functions.</li>
</ul>
</li>
</ul>
</li>
<li><p>An obvious problem with this strategy is that users may accidentally come to depend on declarations included only for the benefit of the definition of <code>out()</code>. </p>
<ul>
<li><p>This danger can be limited by taking approach [2] ‘‘include template definitions later,’’ by using namespaces, by avoiding macros, and generally by reducing the amount of information included. </p>
</li>
<li><p>The ideal is to minimize a template definition’s dependency on its environment.</p>
</li>
<li><p>To use the ‘‘include template definitions later’’ approach for our simple <code>out()</code> example, we first split <code>out.h</code> into two. </p>
<p>The declarations go into a <code>.h</code> file:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file outdecl.h:</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; t)</span></span>;<br></code></pre></td></tr></table></figure>

<p>The definitions go into <code>out.cpp</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file out.cpp:</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cerr &lt;&lt; t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>A user now <code>#include</code>s both:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file user3.cpp:</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;out.h&quot;</span></span><br><span class="hljs-comment">// use out()</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;out.cpp&quot;</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>This minimizes the chances of the implementation of the templates having undesirable effects on the user code. </li>
<li>Unfortunately, it also increases the chances that something in the user code (say, a macro) will have an undesirable effect on the template definitions.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="65">
<li><p>As ever, non-<code>inline</code>, non-template functions and <code>static</code> members (§16.2.12) must have a unique definition in some compilation unit. </p>
<ul>
<li>This implies that such members are best not used for templates that are otherwise included in many translation units. </li>
</ul>
<p>As shown with <code>out()</code>, the definition of a template function may be replicated in different translation units, so <strong>beware of contexts that might subtly change the meaning of a definition</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file user1.cpp:</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;out.h&quot;</span></span><br><span class="hljs-comment">// use out()</span><br></code></pre></td></tr></table></figure>

<p>and</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file user4.cpp:</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> std MyLib</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;out.c&quot;</span></span><br><span class="hljs-comment">// use out()</span><br></code></pre></td></tr></table></figure>

<ul>
<li>This sneaky and error-prone use of a macro changes the definition of <code>out</code> so that <code>user4.cpp</code>’s definition differs from <code>user1.cpp</code>’s. <ul>
<li>This is an error, but it is an error that an implementation may not catch. </li>
<li>This kind of error can be very hard to detect in large programs, so be careful to minimize context dependencies of templates and be very suspicious about macros (§12.6).</li>
</ul>
</li>
</ul>
<p>If you need more control over the context of instantiation, you can use explicit instantiation and <code>extern template</code>s (§26.2.2).</p>
</li>
</ol>
<h4 id="23-7-1-Linkage"><a href="#23-7-1-Linkage" class="headerlink" title="23.7.1 Linkage"></a>23.7.1 Linkage</h4><ol start="66">
<li>The rules for linkage of templates are the rules for linkage of the generated classes and functions (§15.2, §15.2.3). <ul>
<li>This implies that if the layout of a class template or the definition of an inline function template changes, all code that uses that class or function must be recompiled.</li>
</ul>
</li>
</ol>
<ol start="67">
<li>For templates defined in header files and included ‘‘everywhere’’ this can imply a lot of recompilation because templates tend to include a lot of information in header files, more than non-template code using <code>.cpp</code> files.<ul>
<li>In particular, if dynamically linked libraries are used, care has to be taken that all uses of a template are consistently defined.</li>
</ul>
</li>
</ol>
<ol start="68">
<li><p>Sometimes, it is possible to minimize the exposure to changes in complicated template libraries by encapsulating their use in functions with non-template interfaces. </p>
<ul>
<li>For example, I might like to implement some computations using a general numerical library supporting a wide variety of types (e.g., Chapter 29, §40.4, §40.5, §40.6). </li>
</ul>
<p>However, I often know the type used for my calculations.</p>
<ul>
<li><p>For example, in a program I may consistently use <code>double</code>s and <code>vector&lt;double&gt;</code>. </p>
</li>
<li><p>In that case, I could define:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">accum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">double</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Given that, I can use the simple non-templated declaration of <code>accum()</code> in my code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">accum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">double</span>&gt;&amp; v)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>The dependence on <code>std::accumulate</code> has disappeared into a <code>.cpp</code> file that is not seen by the rest of my code.</li>
<li>Also, I suffer the compilation-time overhead of a <code>#include&lt;numeric&gt;</code> only in that <code>.cpp</code> file.</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="69">
<li><p>Note that I took the opportunity to simplify the interface to <code>accum()</code> compared to <code>std::accumulate()</code>.</p>
<p>The generality that is a key attribute of good template libraries can be seen as a source of complexity in a particular application.</p>
</li>
</ol>
<ol start="70">
<li><p>I suspect that I would not use this technique for standard-library templates. </p>
<p>Those are stable over years and known to the implementations. </p>
<ul>
<li>In particular, I did not bother to try to encapsulate <code>vector&lt;double&gt;</code>. </li>
</ul>
<p>However, for more complex, esoteric, or frequently changing template libraries, such encapsulation can be useful.</p>
</li>
</ol>
<h3 id="23-8-Advice"><a href="#23-8-Advice" class="headerlink" title="23.8 Advice"></a>23.8 Advice</h3><p>[1] Use templates to express algorithms that apply to many argument types; §23.1.<br>[2] Use templates to express containers; §23.2.<br>[3] Note that <code>template&lt;class T&gt;</code> and <code>template&lt;typename T&gt;</code> are synonymous; §23.2.<br>[4] When defining a template, first design and debug a non-template version; later generalize by adding parameters; §23.2.1.<br>[5] Templates are type-safe, but checking happens too late; §23.3.<br>[6] When designing a template, carefully consider the concepts (requirements) assumed for its template arguments; §23.3.<br>[7] If a class template should be copyable, give it a non-template copy constructor and a non-template copy assignment; §23.4.6.1.<br>[8] If a class template should be movable, give it a non-template move constructor and a non-template move assignment; §23.4.6.1.<br>[9] A virtual function member cannot be a template member function; §23.4.6.2.<br>[10] Define a type as a member of a template only if it depends on all the class template’s arguments; §23.4.6.3.<br>[11] Use function templates to deduce class template argument types; §23.5.1.<br>[12] Overload function templates to get the same semantics for a variety of argument types; §23.5.3.<br>[13] Use argument substitution failure to provide just the right set of functions for a program; §23.5.3.2.<br>[14] Use template aliases to simplify notation and hide implementation details; §23.6.<br>[15] There is no separate compilation of templates: <code>#include</code> template definitions in every translation unit that uses them; §23.7.<br>[16] Use ordinary functions as interfaces to code that cannot deal with templates; §23.7.1.<br>[17] Separately compile large templates and templates with nontrivial context dependencies; §23.7.</p>
<h2 id="Chapter-24-Generic-Programming"><a href="#Chapter-24-Generic-Programming" class="headerlink" title="Chapter 24. Generic Programming"></a>Chapter 24. Generic Programming</h2><h2 id="Chapter-25-Specialization"><a href="#Chapter-25-Specialization" class="headerlink" title="Chapter 25. Specialization"></a>Chapter 25. Specialization</h2><h2 id="Chapter-26-Instantiation"><a href="#Chapter-26-Instantiation" class="headerlink" title="Chapter 26. Instantiation"></a>Chapter 26. Instantiation</h2><h2 id="Chapter-27-Templates-and-Hierachies"><a href="#Chapter-27-Templates-and-Hierachies" class="headerlink" title="Chapter 27. Templates and Hierachies"></a>Chapter 27. Templates and Hierachies</h2><h2 id="Chapter-28-Metaprogramming"><a href="#Chapter-28-Metaprogramming" class="headerlink" title="Chapter 28. Metaprogramming"></a>Chapter 28. Metaprogramming</h2><h2 id="Chapter-29-A-Matrix-Design"><a href="#Chapter-29-A-Matrix-Design" class="headerlink" title="Chapter 29. A Matrix Design"></a>Chapter 29. A Matrix Design</h2><h1 id="The-C-Programming-Language-Part-Ⅳ-The-Standard-Liberary"><a href="#The-C-Programming-Language-Part-Ⅳ-The-Standard-Liberary" class="headerlink" title="The C++ Programming Language  Part Ⅳ : The Standard Liberary"></a>The C++ Programming Language  Part Ⅳ : The Standard Liberary</h1><h2 id="Chapter-30-Standard-Library-Summary"><a href="#Chapter-30-Standard-Library-Summary" class="headerlink" title="Chapter 30. Standard Library Summary"></a>Chapter 30. Standard Library Summary</h2><h2 id="Chapter-31-STL-container"><a href="#Chapter-31-STL-container" class="headerlink" title="Chapter 31. STL container"></a>Chapter 31. STL container</h2><h2 id="Chapter-32-STL-Algorithms"><a href="#Chapter-32-STL-Algorithms" class="headerlink" title="Chapter 32. STL Algorithms"></a>Chapter 32. STL Algorithms</h2><h2 id="Chapter-33-STL-Iterators"><a href="#Chapter-33-STL-Iterators" class="headerlink" title="Chapter 33. STL Iterators"></a>Chapter 33. STL Iterators</h2><h2 id="Chapter-34-Memory-and-Resources"><a href="#Chapter-34-Memory-and-Resources" class="headerlink" title="Chapter 34. Memory and Resources"></a>Chapter 34. Memory and Resources</h2><h2 id="Chapter-35-Utilities"><a href="#Chapter-35-Utilities" class="headerlink" title="Chapter 35. Utilities"></a>Chapter 35. Utilities</h2><h2 id="Chapter-36-Strings"><a href="#Chapter-36-Strings" class="headerlink" title="Chapter 36. Strings"></a>Chapter 36. Strings</h2><h2 id="Chapter-37-Regular-Expressions"><a href="#Chapter-37-Regular-Expressions" class="headerlink" title="Chapter 37. Regular Expressions"></a>Chapter 37. Regular Expressions</h2><h2 id="Chapter-38-I-O-Streams"><a href="#Chapter-38-I-O-Streams" class="headerlink" title="Chapter 38. I/O Streams"></a>Chapter 38. I/O Streams</h2><h2 id="Chapter-39-Locales"><a href="#Chapter-39-Locales" class="headerlink" title="Chapter 39. Locales"></a>Chapter 39. Locales</h2><h2 id="Chapter-40-Numberics"><a href="#Chapter-40-Numberics" class="headerlink" title="Chapter 40. Numberics"></a>Chapter 40. Numberics</h2><h2 id="Chapter-41-Concurrency"><a href="#Chapter-41-Concurrency" class="headerlink" title="Chapter 41. Concurrency"></a>Chapter 41. Concurrency</h2><h2 id="Chapter-42-Threads-and-Tasks"><a href="#Chapter-42-Threads-and-Tasks" class="headerlink" title="Chapter 42. Threads and Tasks"></a>Chapter 42. Threads and Tasks</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ Programming Languge</div>
      <div>http://example.com/2023/02/21/C-Programming-Languge/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>V. Louis</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 21, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/17/Professional-C/" title="Professional C++">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Professional C++</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/08/%E5%89%91%E6%8C%87offer/" title="剑指offer">
                        <span class="hidden-mobile">剑指offer</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
