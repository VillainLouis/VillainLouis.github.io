

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="V. Louis">
  <meta name="keywords" content="">
  
    <meta name="description" content="CS 144: Introduction to Computer NetworkingLab 0 ByteStream 【cs144】Lab0 : networking warmingup - 知乎 (zhihu.com)  get_URL()函数实现 利用提供的TCPSocket接口实现  12345678910111213141516171819202122232425void get_URL">
<meta property="og:type" content="article">
<meta property="og:title" content="Stanford CS144: Computer Network Notes">
<meta property="og:url" content="http://example.com/2023/06/02/Stanford-CS144-Computer-Network-Notes/index.html">
<meta property="og:site_name" content="V. Louis">
<meta property="og:description" content="CS 144: Introduction to Computer NetworkingLab 0 ByteStream 【cs144】Lab0 : networking warmingup - 知乎 (zhihu.com)  get_URL()函数实现 利用提供的TCPSocket接口实现  12345678910111213141516171819202122232425void get_URL">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/06/02/Stanford-CS144-Computer-Network-Notes/image-20230523095224000.png">
<meta property="og:image" content="http://example.com/2023/06/02/Stanford-CS144-Computer-Network-Notes/image-20230523095532075.png">
<meta property="og:image" content="http://example.com/2023/06/02/Stanford-CS144-Computer-Network-Notes/image-20230526105913205.png">
<meta property="og:image" content="http://example.com/2023/06/02/Stanford-CS144-Computer-Network-Notes/image-20230601113538216.png">
<meta property="article:published_time" content="2023-06-02T08:03:40.000Z">
<meta property="article:modified_time" content="2023-06-02T08:06:25.685Z">
<meta property="article:author" content="V. Louis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/06/02/Stanford-CS144-Computer-Network-Notes/image-20230523095224000.png">
  
  
  
  <title>Stanford CS144: Computer Network Notes - V. Louis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Villian Louis&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Stanford CS144: Computer Network Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-02 16:03" pubdate>
          June 2, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          443 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Stanford CS144: Computer Network Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="CS-144-Introduction-to-Computer-Networking"><a href="#CS-144-Introduction-to-Computer-Networking" class="headerlink" title="CS 144: Introduction to Computer Networking"></a><a target="_blank" rel="noopener" href="https://cs144.github.io/">CS 144: Introduction to Computer Networking</a></h1><h2 id="Lab-0-ByteStream"><a href="#Lab-0-ByteStream" class="headerlink" title="Lab 0 ByteStream"></a>Lab 0 ByteStream</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/586285278">【cs144】Lab0 : networking warmingup - 知乎 (zhihu.com)</a></li>
</ul>
<h3 id="get-URL-函数实现"><a href="#get-URL-函数实现" class="headerlink" title="get_URL()函数实现"></a><code>get_URL()</code>函数实现</h3><ul>
<li>利用提供的<code>TCPSocket</code>接口实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">( <span class="hljs-type">const</span> string&amp; host, <span class="hljs-type">const</span> string&amp; path )</span></span><br><span class="hljs-function"></span>&#123;<br>  cerr &lt;&lt; <span class="hljs-string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>  <span class="hljs-comment">// cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span><br>  <span class="hljs-comment">// 首先获取一个本地的TCPsocket</span><br>  TCPSocket client_sock;<br>  <span class="hljs-comment">// 获取服务器的地址，需要host信息和service信息</span><br>  <span class="hljs-function">Address <span class="hljs-title">server_addr</span><span class="hljs-params">(host, <span class="hljs-string">&quot;http&quot;</span>)</span></span>;<br>  <span class="hljs-comment">// 利用TCPsocket与host建立连接</span><br>  client_sock.<span class="hljs-built_in">connect</span>(server_addr);<br>  <span class="hljs-comment">// 建立连接之后，根据path，利用http的GET方法，获取对应的文件</span><br>  <span class="hljs-comment">//  通过向client_sock中写入报文，来向server发送请求</span><br>  client_sock.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>); <span class="hljs-comment">// 注意空格</span><br>  client_sock.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Host: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>  client_sock.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// HTTP报文的空白行</span><br>  <span class="hljs-comment">// 客户端只需要获取对应的文件，请求发送完成之后直接关闭写，TCP的全双工通信客户端到服务端的写关闭</span><br>  client_sock.<span class="hljs-built_in">shutdown</span>(SHUT_WR);<br><br>  <span class="hljs-comment">// 等待读取来自server的文件信息，直到文件末尾EOF</span><br>  <span class="hljs-keyword">while</span> (!client_sock.<span class="hljs-built_in">eof</span>()) &#123;<br>    string buffer;<br>    client_sock.<span class="hljs-built_in">read</span>(buffer);<br>    cout &lt;&lt; buffer;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="基于ByteStream的Writer和Reader的实现"><a href="#基于ByteStream的Writer和Reader的实现" class="headerlink" title="基于ByteStream的Writer和Reader的实现"></a>基于<code>ByteStream</code>的<code>Writer</code>和<code>Reader</code>的实现</h3><ul>
<li><code>Writer</code>和<code>Reader</code>都是基于<code>ByteStream</code>实现，一个往缓冲区写数据，一个读取数据</li>
<li>根据实验手册实现对应的功能即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// byte_stream.hh</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteStream</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-type">uint64_t</span> capacity_; <span class="hljs-comment">// ByteStream的最大容量，限制缓冲区的最大长度。</span><br>  <span class="hljs-comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span><br>  std::string buffer_;<br>  <span class="hljs-type">size_t</span> read_total_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">size_t</span> wirte_total_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">bool</span> eof_&#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-type">bool</span> error_&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ByteStream</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> capacity )</span></span>;<br><br>  <span class="hljs-comment">// Helper functions (provided) to access the ByteStream&#x27;s Reader and Writer interfaces</span><br>  <span class="hljs-function">Reader&amp; <span class="hljs-title">reader</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Reader&amp; <span class="hljs-title">reader</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">Writer&amp; <span class="hljs-title">writer</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Writer&amp; <span class="hljs-title">writer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Writer</span> : <span class="hljs-keyword">public</span> ByteStream<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/** Wirter向stream内的缓冲区写入数据。*/</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">( std::string data )</span></span>; <span class="hljs-comment">// Push data to stream, but only as much as available capacity allows.</span><br><br>  <span class="hljs-comment">/** stream已经到达末尾了，关闭stream，没有更多的数据了。*/</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// Signal that the stream has reached its ending. Nothing more will be written.</span><br>  <span class="hljs-comment">/** stream出错了，设置stream出错。*/</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_error</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// Signal that the stream suffered an error.</span><br><br>  <span class="hljs-comment">/** 检查stream是否关闭*/</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;              <span class="hljs-comment">// Has the stream been closed?</span><br>  <span class="hljs-comment">/** 检查stream还可以写入的容量。*/</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">available_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// How many bytes can be pushed to the stream right now?</span><br>  <span class="hljs-comment">/** 检查往该stream中push的总的字节长度*/</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">bytes_pushed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// Total number of bytes cumulatively pushed to the stream</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span> : <span class="hljs-keyword">public</span> ByteStream<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/** peek（读取）一下buffer中的字节（可以读出的字节全部读出）。*/</span><br>  <span class="hljs-function">std::string_view <span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// Peek at the next bytes in the buffer</span><br>  <span class="hljs-comment">/** 从buffer中移除指定数目的字节*/</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> len )</span></span>;      <span class="hljs-comment">// Remove `len` bytes from the buffer</span><br>  <br>  <span class="hljs-comment">/** stream是否结束，即到达eof并且buffer中的内容已经全部读完*/</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_finished</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// Is the stream finished (closed and fully popped)?</span><br>  <span class="hljs-comment">/** stream是否出错。*/</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">has_error</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// Has the stream had an error?</span><br><br>  <span class="hljs-comment">/** 当前buffer中没有读取的字节数。*/</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">bytes_buffered</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// Number of bytes currently buffered (pushed and not popped)</span><br>  <span class="hljs-comment">/** 当前stream中pop的总的字节数。*/</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">bytes_popped</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// Total number of bytes cumulatively popped from stream</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// byte_stream.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::push</span><span class="hljs-params">( string data )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 可以写入的数据长度可能受ByteStream最大容量限制</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len&#123;<span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">available_capacity</span>())&#125;;<br>  <span class="hljs-comment">// 将可写入长度的数据，写入数据到缓冲区</span><br>  buffer_.<span class="hljs-built_in">append</span>(data, <span class="hljs-number">0</span>, len);<br>  <span class="hljs-comment">// 更新stream的写入信息</span><br>  wirte_total_ += len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  eof_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::set_error</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  error_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Writer::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> eof_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Writer::available_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> capacity_ - buffer_.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Writer::bytes_pushed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> wirte_total_;<br>&#125;<br><br><span class="hljs-function">string_view <span class="hljs-title">Reader::peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> buffer_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reader::is_finished</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> eof_ &amp;&amp; buffer_.<span class="hljs-built_in">empty</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reader::has_error</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> error_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reader::pop</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> len )</span></span><br><span class="hljs-function"></span>&#123;<br>  buffer_.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, len);<br>  <span class="hljs-comment">// 计数读出字节的总长度</span><br>  read_total_ += len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reader::bytes_buffered</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> buffer_.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reader::bytes_popped</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> read_total_;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h2 id="Lab-1-StreamReassembler"><a href="#Lab-1-StreamReassembler" class="headerlink" title="Lab 1 StreamReassembler"></a>Lab 1 StreamReassembler</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout b454ffd9e0b19186ccdc0b33933ab9f2d42b7928<br></code></pre></td></tr></table></figure>

<ul>
<li>依靠不可靠的数据报传输，实现可靠的字节流传输的数据结构-<code>Reassembler</code>。<ul>
<li>收到若干字符串：<ul>
<li>包含字符串；</li>
<li>以及该字符串在整个stream中的首字节index。</li>
</ul>
</li>
<li>每个字节流都有其自己的index，从0开始不断增长。</li>
</ul>
</li>
<li>两个接口：<ul>
<li><code>insert()</code>:<ul>
<li>向当前的<code>Reassembler</code>中插入一个substring，等待被reassembled。</li>
<li>即刚接收到的没有超过<code>Reassembler</code>的最大容量，但是不能被写入（前面的字节还是未知的），因此存入<code>Reassembler</code>内部。</li>
</ul>
</li>
<li><code>bytes_pending()</code>：<ul>
<li>存在<code>Reassembler</code>内部的数据的字节数。</li>
<li>只有落在当前stream的available capacity范围内，还不确定的子串会保留，其他的都会被丢弃。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>Program Structure and Design of the Reassembler:</p>
<ul>
<li>包含一个内部的哈希表<code>std::map</code>，有序记录在可接收的范围内，但是前面子串还没有接收完成的串。</li>
<li>维护内部未写入数据的总长度，即<code>unassembled_bytes_</code>，等于内部哈希表记录的子串长度总和。</li>
<li>维护内部待写入的第一个字节的位置，即<code>unasssmebled_idx</code>。</li>
</ul>
<p>Implementation Challenges:</p>
<ul>
<li>为了方便说明，使用<code>dataIdx</code>和<code>data</code>表示当前待插入的数据。<code>idx</code>和<code>str</code>表示待与当前插入数据拼接的数据。实现的思路是拿着当前待插入的数据掐头去尾，拼接，插入内部或是写入。</li>
<li>实现的思路主要是分为三步：<ol>
<li>首先是需要预处理当前插入的子串。<ul>
<li>如果子串一整个都没有在$[unassembledIdx,unacceptableIdx - 1]$，则直接丢弃，无需处理；</li>
<li>如果子串完全或是部分落在$[unassembledIdx,unacceptableIdx - 1]$，则需要预处理，即掐头去尾。$[dataIndex, unassembledIdx - 1]$部分的数据已经写入了，不需要；$[unacceptable, dataIdx + dataSize - 1]$的数据超出了可接收的范围，不能接收。</li>
</ul>
</li>
<li>预处理完成之后，需要考虑当前待插入的数据<code>data</code>是否与已经存在内部的数据重叠，或是连续，因为这两种情况下，我们都需要将数据进行拼接，从而避免重复接收以及一次写入所有可以写入的数据。<ul>
<li>为了简化处理，将拼接的过程分成两部分：首先向后尝试拼接（可能多次，当前数据比较长，涵盖了多个之之前存在但是不相交的子串）；在向前进行拼接（最多一次，因为最多存在一个与当前数据重叠的内部子串）。</li>
<li>往后拼接：内部维护的哈希表是有序的，因此只需要从第一个大于等于当前<code>dataIdx</code>的子串开始拼接，直到子串没有交集，就结束；</li>
<li>往前拼接：只需要找出第一个小于当前<code>dataIdx</code>位置的子串进行拼接，可能找不到。找到了与往后拼接类似。</li>
<li>在拼接的同时，及时处理已经拼接的数据，将其从内部数据中删除。</li>
</ul>
</li>
<li>完成拼接之后，根据首位置确定试将当前的数据写入到<code>output</code>还是继续存在内部。</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;byte_stream.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_last_substring) &#123;<br>        closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (first_index &gt;= unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>        first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index_ || <span class="hljs-comment">/* Data have been transferred */</span><br>        data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_closed</span>()) &#123;<br>            output.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">uint64_t</span> data_index = first_index; <span class="hljs-comment">// new_index actually distinguish where the current data start, the start index</span><br>    <span class="hljs-type">uint64_t</span> unaccepteable_idx = unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>();<br><br>    <span class="hljs-comment">// 1. 将数据掐头去尾</span><br>    <span class="hljs-comment">// Data needs to fit the capability limitation</span><br>    <span class="hljs-keyword">if</span> (first_index &lt;= unassembled_index_) &#123;<br>        <span class="hljs-comment">// 掐头</span><br>        data_index = unassembled_index_;<br>        <span class="hljs-type">uint64_t</span> overlapped_length = unassembled_index_ - first_index;<br>        <span class="hljs-comment">// 去尾</span><br>        <span class="hljs-keyword">if</span> (data_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= unaccepteable_idx) &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(overlapped_length, data.<span class="hljs-built_in">size</span>() - ((data_index + data.<span class="hljs-built_in">size</span>()) - unaccepteable_idx));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(overlapped_length);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 去尾</span><br>        <span class="hljs-keyword">if</span> (data_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= unaccepteable_idx) &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - ((data_index + data.<span class="hljs-built_in">size</span>()) - unaccepteable_idx));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), output.<span class="hljs-built_in">available_capacity</span>()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 尝试与内部保留的字符串做拼接</span><br>    vector&lt;<span class="hljs-type">size_t</span>&gt; outdated; <span class="hljs-comment">// 记录过期的子串（已经拼接了）</span><br>    <span class="hljs-comment">// 连接后面可能重叠或是连续的子串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(data_index); iter != unassembled_substrings_.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>      <span class="hljs-keyword">auto</span> &amp;[idx, str] = *iter;<br>      <span class="hljs-comment">// data与str既没有重叠，也不连续</span><br>      <span class="hljs-keyword">if</span> (data_index + data.<span class="hljs-built_in">size</span>() &lt; idx) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      outdated.<span class="hljs-built_in">emplace_back</span>(idx);<br>      <span class="hljs-comment">// 比较data与str子串的最右端字符位置：data右端更大，则str被包含，删除就行；str右端更大，则data需要拼接str后半部分</span><br>      <span class="hljs-comment">//    这种情况包含了连续与有重叠的情况</span><br>      <span class="hljs-keyword">if</span> (data_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; idx + str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123; <br>        <span class="hljs-comment">// 需要拼接</span><br>        <span class="hljs-keyword">auto</span> dup = data_index + data.<span class="hljs-built_in">size</span>() - idx; <span class="hljs-comment">// 计算重叠的字符数，data_index+data.size()-1 - idx + 1</span><br>        data.<span class="hljs-built_in">append</span>(str.<span class="hljs-built_in">substr</span>(dup));<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> idx : outdated) &#123;<br>        unassembled_bytes_ -= unassembled_substrings_[idx].<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">erase</span>(idx);<br>    &#125;<br>    outdated.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">if</span> (first_index &gt; unassembled_index_) &#123;<br>      <span class="hljs-comment">// 这种情况下需要查看是否需要与前面的拼接</span><br>      <span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">upper_bound</span>(data_index);<br>      <span class="hljs-keyword">if</span> (iter != unassembled_substrings_.<span class="hljs-built_in">begin</span>()) &#123;<br>        iter = <span class="hljs-built_in">prev</span>(iter);<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[idx, str] = *iter;<br>        <span class="hljs-comment">// 首先判断str与data是否有重叠或是连续关系</span><br>        <span class="hljs-keyword">if</span> (idx + str.<span class="hljs-built_in">size</span>() &lt; data_index) &#123;<br>            ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 重叠或是连续</span><br>            <span class="hljs-comment">// 比较str与data子串的最右端字符位置：str右端更大，则data被包含，更新data；data右端更大，则str需要拼接data后半部分</span><br>            outdated.<span class="hljs-built_in">emplace_back</span>(idx);<br>            <span class="hljs-keyword">if</span> (idx + str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt;= data_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 需要拼接</span><br>                <span class="hljs-keyword">auto</span> dup = idx + str.<span class="hljs-built_in">size</span>() - data_index;<br>                data = str + data.<span class="hljs-built_in">substr</span>(dup);<br>                data_index = idx;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// str更长，并且idx更小</span><br>                data = str;<br>                data_index = idx;<br>            &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!outdated.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> idx = outdated.<span class="hljs-built_in">front</span>();<br>        unassembled_bytes_ -= unassembled_substrings_[idx].<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">erase</span>(outdated.<span class="hljs-built_in">front</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (data_index == unassembled_index_) &#123;<br>        output.<span class="hljs-built_in">push</span>(data);<br>        unassembled_index_ += data.<span class="hljs-built_in">size</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        unassembled_substrings_.<span class="hljs-built_in">emplace</span>(pair&#123;data_index, data&#125;);<br>        unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_closed</span>()) &#123;<br>        output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> unassembled_bytes_;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;byte_stream.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reassembler</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    std::map&lt;<span class="hljs-type">uint64_t</span>, std::string&gt; unassembled_substrings_ &#123;&#125;;<br>    <span class="hljs-type">uint64_t</span> unassembled_bytes_ &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">uint64_t</span> unassembled_index_ &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// bufferred bytes locate at here</span><br>    <span class="hljs-type">bool</span> closed_ &#123;<span class="hljs-literal">false</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Reassembler</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Insert a new substring to be reassembled into a ByteStream.</span><br><span class="hljs-comment">     *   `first_index`: the index of the first byte of the substring</span><br><span class="hljs-comment">     *   `data`: the substring itself</span><br><span class="hljs-comment">     *   `is_last_substring`: this substring represents the end of the stream</span><br><span class="hljs-comment">     *   `output`: a mutable reference to the Writer</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The Reassembler&#x27;s job is to reassemble the indexed substrings (possibly out-of-order</span><br><span class="hljs-comment">     * and possibly overlapping) back into the original ByteStream. As soon as the Reassembler</span><br><span class="hljs-comment">     * learns the next byte in the stream, it should write it to the output.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * If the Reassembler learns about bytes that fit within the stream&#x27;s available capacity</span><br><span class="hljs-comment">     * but can&#x27;t yet be written (because earlier bytes remain unknown), it should store them</span><br><span class="hljs-comment">     * internally until the gaps are filled in.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The Reassembler should discard any bytes that lie beyond the stream&#x27;s available capacity</span><br><span class="hljs-comment">     * (i.e., bytes that couldn&#x27;t be written even if earlier gaps get filled in).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The Reassembler should close the stream after writing the last byte.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, std::string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span>;<br><br>    <span class="hljs-comment">// How many bytes are stored in the Reassembler itself?</span><br>    <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>









<h2 id="Lab-2-The-TCP-Receiver"><a href="#Lab-2-The-TCP-Receiver" class="headerlink" title="Lab 2 The TCP Receiver"></a>Lab 2 The TCP Receiver</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">commit 0b65a1017cea69ce74c16989cefc6d16311bf1b1<br></code></pre></td></tr></table></figure>



<p>Translating between <strong>64-bit indexes</strong> and <strong>32-bit seqnos</strong>.</p>
<ul>
<li>之前实现的<code>Reassembler</code>整合的子串都是64-bit stream index。</li>
<li>在TCP header中，空间非常珍贵，都是使用的32-bit “sequence number” or “seqno”。</li>
</ul>
<p>This adds three complexities:</p>
<ul>
<li>Your implementation needs to plan for 32-bit integers to wrap around. <ul>
<li>$2^{32} = 4 GiB$ 内容，不够大；</li>
<li>Once a 32-bit sequence number counts up to $2^{32}-1$, the next byte in the stream will have the sequence number zero.</li>
</ul>
</li>
<li>TCP sequence numbers start at a random value：<ul>
<li>为了提高鲁棒性避免被一些旧的分片数据困扰；</li>
<li>TCP尽力保证sequence number是不能被猜测或是重复的；</li>
<li>因此，一个stream的sequence number并不是以0开始的；</li>
<li>stream中的第一个sequence number是一个随机的32bit number，称为Initial Sequence Number (ISN)。</li>
<li>ISN代表了”zero point”，或者是SYN（stream的开始）。</li>
<li>之后的sequence number不断递增，与一般情况一致。</li>
</ul>
</li>
<li>The logical beginning and ending each occupy one sequence number：<ul>
<li>为了保证所有数据的正确解释，TCP需要保证stream的开始和结束是被接收者可靠地接收了。</li>
<li>因此，在TCP中，SYN（beginning-of-stream）和FIN（end-of-stream）这两个control flags被赋予了sequence number。</li>
<li>SYN和FIN都有占据了一个sequence number。SYN占据的sequence number就是ISN。</li>
<li>SYN和FIN并不是stream本身，也不是数据，只是代表stream的开始与结束。</li>
</ul>
</li>
</ul>
<p>seqnos包含在TCP segment的header中进行传输。</p>
<p>一个TCP连接包含两个stream，每个方向的sequence number 和 ISN都不一样。</p>
<p>为了方便说明，引入absolute sequence number和stream index：</p>
<ul>
<li>absolute sequence number:<ul>
<li>从0开始，没有包装</li>
</ul>
</li>
<li>stream index：<ul>
<li>即在Reassembler中使用的index，对应stream中的每个字节是从0开始的</li>
</ul>
</li>
</ul>
<p>举一个简单的例子。<code>cat</code>字符串如果其SYN具有seqno $2^{32}-2$，则其对应的stream中每个字节有：</p>
<ul>
<li><img src="image-20230523095224000.png" srcset="/img/loading.gif" lazyload alt="image-20230523095224000"></li>
</ul>
<p>TCP中三种不同的index区别：</p>
<ul>
<li><img src="image-20230523095532075.png" srcset="/img/loading.gif" lazyload alt="image-20230523095532075"></li>
</ul>
<p>absolute sequence number与stream index之间的转换很简单，只需要加减一1。</p>
<p>sequence number与absolute sequence number之间的转换稍微复杂，为了系统地避免出现bug，</p>
<ul>
<li>用一个<code>Wrap32</code>来表示sequence number；</li>
<li>并且是实现<code>Wrap32</code>与absolute sequence number (<code>uint_64</code>)之间的转换。</li>
</ul>
<h3 id="Wrap32实现"><a href="#Wrap32实现" class="headerlink" title="Wrap32实现"></a><code>Wrap32</code>实现</h3><p>需要实现的函数：</p>
<ol>
<li><code>static Wrap32 Wrap32::wrap( uint64_t n, Wrap32 zero_point )</code><ul>
<li>Convert absolute seqno -&gt; seqno.</li>
<li>给定absolute sequence number <code>n</code>和ISN，生成<code>n</code>的（relative）sequence number。</li>
</ul>
</li>
<li><code>uint64 t unwrap( Wrap32 zero_point, uint64_t checkpoint ) const</code><ul>
<li>Convert seqno -&gt; absolute seqno.</li>
<li>给定sequence number (the <code>Wrap32</code>)和ISN （zero point），以及一个absolute <em><strong>checkpoint</strong></em> sequence number，找出对应的最接近checkpoint的absolute sequnce number。<ul>
<li>A checkpoint is required because any given seqno corresponds to many absolute seqnos.</li>
<li>E.g. with an ISN of zero, the seqno “17” corresponds to the absolute seqno of 17, but also $2^{32} + 17$, or $2^{33} + 17$, or ${2^{33} + 2^{32}+ 17}$, or $2^{34} + 17$, or $2^{34} + 2^{32} + 17$, etc.</li>
<li>The checkpoint helps resolve the ambiguity: it’s an absolute seqno that the user of this class knows is “in the ballpark” of the correct answer.</li>
<li>In your TCP implementation, you’ll <strong>use the first unassembled index as the checkpoint.</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Hint：</p>
<ul>
<li>使用提供的helper functions。<em>wrap/unwrap</em> operations 应该保留offsets，即absolute sequence number之间相差的值，转化成seqno，offset应该是不变的。</li>
<li>wrap使用一行代码，unwrap不超过十行。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The Wrap32 type represents a 32-bit unsigned integer that:</span><br><span class="hljs-comment"> *    - starts at an arbitrary &quot;zero point&quot; (initial value), and</span><br><span class="hljs-comment"> *    - wraps back to zero when it reaches 2^32 - 1.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wrap32</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-type">uint32_t</span> raw_value_ &#123;&#125;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Wrap32</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> raw_value )</span> : raw_value_( raw_value ) &#123;</span>&#125;<br><br>  <span class="hljs-comment">/* Construct a Wrap32 given an absolute sequence number n and the zero point. */</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> Wrap32 <span class="hljs-title">wrap</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> n, Wrap32 zero_point )</span></span>;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * The unwrap method returns an absolute sequence number that wraps to this Wrap32, given the zero point</span><br><span class="hljs-comment">   * and a &quot;checkpoint&quot;: another absolute sequence number near the desired answer.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * There are many possible absolute sequence numbers that all wrap to the same Wrap32.</span><br><span class="hljs-comment">   * The unwrap method should return the one that is closest to the checkpoint.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">( Wrap32 zero_point, <span class="hljs-type">uint64_t</span> checkpoint )</span> <span class="hljs-type">const</span></span>;<br><br><br>  Wrap32 <span class="hljs-keyword">operator</span>+( <span class="hljs-type">uint32_t</span> n ) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> Wrap32 &#123; raw_value_ + n &#125;; &#125;<br>  <br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==( <span class="hljs-type">const</span> Wrap32&amp; other ) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> raw_value_ == other.raw_value_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">getRawValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> raw_value_; &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrapping_integers.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">Wrap32 <span class="hljs-title">Wrap32::wrap</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> n, Wrap32 zero_point )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Wrap32</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(n) + zero_point.<span class="hljs-built_in">getRawValue</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Wrap32::unwrap</span><span class="hljs-params">( Wrap32 zero_point, <span class="hljs-type">uint64_t</span> checkpoint )</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 关键在于offset不变</span><br>  <span class="hljs-comment">// 将checkpoint映射到Wrap32，求出该this-&gt;raw_val与checkpoint之间的offset</span><br>  <span class="hljs-comment">// 再根据offset和checkpoint求出原始的absolute sequence number</span><br>  <span class="hljs-comment">//    因为offset可能会大于checkpoint，要保证其不会下溢。</span><br>  <span class="hljs-type">int32_t</span> offset = <span class="hljs-built_in">getRawValue</span>() - Wrap32::<span class="hljs-built_in">wrap</span>(checkpoint, zero_point).<span class="hljs-built_in">getRawValue</span>();<br>  <span class="hljs-type">int64_t</span> result = checkpoint + offset;<br>  <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;<br>    result += (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h3 id="TCP-receiver实现"><a href="#TCP-receiver实现" class="headerlink" title="TCP receiver实现"></a>TCP receiver实现</h3><p><code>TCPReceiver</code>:</p>
<ul>
<li>利用<code>Reassembler</code>重新整合从发送者来的信息</li>
<li>向发送者发送<code>ackno</code>和<code>window size</code>。</li>
</ul>
<p>15行代码</p>
<p>首先回顾TCP “sender message”:</p>
<ul>
<li><p>包含<code>ByteStream</code>的信息</p>
</li>
<li><p>由<code>TCPSender</code>发送给<code>TCPReceiver</code>。</p>
</li>
<li><p>```C++<br>struct TCPSenderMessage<br>{</p>
<pre><code class="hljs">Wrap32 seqno &#123; 0 &#125;;
bool SYN &#123; false &#125;;
Buffer payload &#123;&#125;;
bool FIN &#123; false &#125;;
// How many sequence numbers does this segment use?
size_t sequence_length() const &#123; return SYN + payload.size() + FIN; &#125;
</code></pre>
<p>};</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>`TCPReceiver`生成自己的信息返回给`TCPSender`:<br><br>- ```C++<br>  struct TCPReceiverMessage<br>  &#123;<br><span class="hljs-title">      std::</span>optional&lt;Wrap32&gt; ackno &#123;&#125;<span class="hljs-comment">;</span><br>      uint16_t window_size &#123;&#125;<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>TCPReceiver</code>要完成的工作就是接收上述的信息，并发送确认信息。</p>
<h4 id="receive-函数实现"><a href="#receive-函数实现" class="headerlink" title="receive()函数实现"></a><code>receive()</code>函数实现</h4><p>该函数在新的数据segment接收到的时候调用，需要完成两件事：</p>
<ol>
<li>在必要的时候，设置ISN。<ul>
<li>具有SYN control flag的segment中包含的sequence number就是ISN。</li>
<li>ISN在进行32-bit的<code>seqnos/acknos</code>与对应的absolute equivalents转换的时候需要。</li>
</ul>
</li>
<li>将任何收到的数据交给<code>Reassembler</code>处理。<ul>
<li>如果<code>TCPSegment</code>的头部中包含了FIN control flag，意味着payload中的数据是整个stream最后的字节。</li>
<li><code>Reassembler</code>需要的是从0开始的stream index，因此需要unwrap <code>seqnos</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_receiver_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_sender_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrapping_integers.hh&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPReceiver</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * The TCPReceiver receives TCPSenderMessages, inserting their payload into the Reassembler</span><br><span class="hljs-comment">   * at the correct stream index.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receive</span><span class="hljs-params">( TCPSenderMessage message, Reassembler&amp; reassembler, Writer&amp; inbound_stream )</span></span>;<br><br>  <span class="hljs-comment">/* The TCPReceiver sends TCPReceiverMessages back to the TCPSender. */</span><br>  <span class="hljs-function">TCPReceiverMessage <span class="hljs-title">send</span><span class="hljs-params">( <span class="hljs-type">const</span> Writer&amp; inbound_stream )</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  Wrap32 zero_point_&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// ISN</span><br>  <span class="hljs-type">bool</span> is_syn_&#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// 当前是否已经完成同步</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_receiver.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_receiver_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrapping_integers.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPReceiver::receive</span><span class="hljs-params">( TCPSenderMessage message, Reassembler&amp; reassembler, Writer&amp; inbound_stream )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 等待第一个SYN control flag，并设置ISN</span><br>  <span class="hljs-keyword">if</span> (!is_syn_) &#123;<br>    <span class="hljs-comment">// 还没有收到SYN，等待SYN，期间收到的非SYN的segment都丢弃</span><br>    <span class="hljs-keyword">if</span> (!message.SYN) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    is_syn_ = <span class="hljs-literal">true</span>;<br>    zero_point_ = message.seqno;<br>  &#125;<br>  <span class="hljs-comment">// 任何数据都交给reassembler处理</span><br>  <span class="hljs-comment">// 首先需要完成seqnos到absolute sequence number的转换，并进一步转换为stream index</span><br>  <span class="hljs-type">uint64_t</span> checkpoint = inbound_stream.<span class="hljs-built_in">bytes_pushed</span>() + <span class="hljs-number">1</span>; <span class="hljs-comment">// 有SYN占用了多一个字节号</span><br>  <span class="hljs-type">uint64_t</span> absoluteSeqNo = message.seqno.<span class="hljs-built_in">unwrap</span>(zero_point_, checkpoint);<br>  <span class="hljs-type">uint64_t</span> streamIdx = absoluteSeqNo + message.SYN - <span class="hljs-number">1</span>; <span class="hljs-comment">// 首个SYN报文的区分处理</span><br>  reassembler.<span class="hljs-built_in">insert</span>(streamIdx, message.payload, message.FIN, inbound_stream);<br>&#125;<br><br><span class="hljs-function">TCPReceiverMessage <span class="hljs-title">TCPReceiver::send</span><span class="hljs-params">( <span class="hljs-type">const</span> Writer&amp; inbound_stream )</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  TCPReceiverMessage message;<br>  <span class="hljs-keyword">if</span> (!is_syn_) &#123;<br>    message.ackno = <span class="hljs-literal">nullopt</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">uint64_t</span> checkpoint = inbound_stream.<span class="hljs-built_in">bytes_pushed</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (inbound_stream.<span class="hljs-built_in">is_closed</span>()) &#123;<br>      <span class="hljs-comment">// stream关闭，说明已经收到了FIN报文，此时需要将ackno加一，因为以SYN类似，FIN也会占用一个字节号</span><br>      ++checkpoint;<br>    &#125;<br>    message.ackno = Wrap32::<span class="hljs-built_in">wrap</span>(checkpoint, zero_point_);<br>  &#125;<br>  message.window_size = inbound_stream.<span class="hljs-built_in">available_capacity</span>() &gt; <span class="hljs-number">65535</span> ? <span class="hljs-number">65535</span> : inbound_stream.<span class="hljs-built_in">available_capacity</span>();<br>  <span class="hljs-keyword">return</span> message;<br>&#125;<br><br></code></pre></td></tr></table></figure>









<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Program Structure and Design of the TCPReceiver and wrap/unwrap routines:</p>
<ol>
<li><p><code>seqnos</code>与<code>absolute seqnos</code>的转换：</p>
<ul>
<li>从<code>uint64_t</code>到<code>Wrap32</code>的转换，本质上就是取余操作，区别在于有了ISN之后，我们需要做一个平移。而取余操作完全可以由<em><strong>narrow conversion</strong></em>来完成何实现。</li>
<li>从<code>Wrap32</code>到<code>uint64_t</code>的转换，转换的关键在于我们需要选择离checkpoint最近的结果，因为可能有多个结果(<code>uint64_t</code>)对应的到相同的<code>Wrap32</code>。<ul>
<li>关键抓住转化前后，两个数的<strong>offset</strong>是不变的，我们可以将checkpoint转化为<code>Wrap32</code>之后，计算offset，再根据checkpoint，再两个位置（左右）中选择最近的作为结果；</li>
<li>为了获取最近的结果，我们对两个无符号整数<code>uint32_t</code>做减法，相减的结果转化为有符号整数，恰好就是我们想要的最近的offset；</li>
<li>但是offset + checkpoint可能小于0，因此这种情况下需要加上一个模(<code>1UL &lt;&lt; 32</code>)长，来防止下溢。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>TCPReceiver</code>的实现：</p>
<ul>
<li>对于一个TCP连接的首发信息的关键是在是否建立连接，而建立连接的标志就是收到SYN control flag；</li>
<li>需要记录当前的连接状态，是否同步；</li>
<li>每个TCP连接都有不同的ISN，因此需要记录ISN。</li>
</ul>
</li>
</ol>
<p>Implementation Challenges:</p>
<ul>
<li>从<code>Wrap32</code>到<code>uint64_t</code>的转换中，<code>int32_t offset = getRawValue() - Wrap32::wrap(checkpoint, zero_point).getRawValue();</code>十分精妙。</li>
<li>实现<code>TCPReceiver::receive()</code>:<ul>
<li>未成功建立连接之前，什么都不做；</li>
<li>建立连接时，设置ISN，设置连接状态；</li>
<li>对于所有的数据，在转换为stream index之后，全部交给<code>Reassembler</code>进行处理。</li>
<li>转换stream index的时候需要注意，<code>seqnos</code>和<code>absolute seqnos</code>中，SYN 和 FIN都是占一个字节位，因此需要注意；</li>
<li>当前的checkpoint的值等于写入到stream中的字节数，加1（即期待的下一字节，加1是因为SYN占用了一位）；</li>
<li>根据checkpoint转化的<code>absolute seqnos</code>需要根据是否包含SYN区别处理。包含SYN的时候，数据还没有写入，因此为了防止下溢，需要特别注意。<code>uint64_t streamIdx = absoluteSeqNo + message.SYN - 1; </code>。</li>
</ul>
</li>
<li>实现<code>TCPReceiver::send()</code>:<ul>
<li>需要注意在没有建立连接之前，<code>ackno</code>应该是None，我们应该返回的是<code>nullopt</code>;</li>
<li>对于期望待收到的下一字节，应该是包含SYN字符和FIN字符的<code>seqnos</code>，根据stream的写入状态可以判读是否已经收到FIN。</li>
<li>窗口的大小应该是<code>min(65535, inbound_stream.available_capacity())</code>。</li>
</ul>
</li>
</ul>
<h2 id="Lab-3-The-TCP-Sender"><a href="#Lab-3-The-TCP-Sender" class="headerlink" title="Lab 3 The TCP Sender"></a>Lab 3 The TCP Sender</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/628432616">【CS144 Lab3】实现一个TCP网络栈之发送端 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/625573364">CS144 计算机网络导论 实验 lab3 TCP Sender 实验记录 - 知乎 (zhihu.com)</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">e6746e247f42e7e0a1cae03c2b8c6e355c58d8f1<br></code></pre></td></tr></table></figure>



<p>TCP sender：</p>
<ul>
<li>负责从<code>ByteStream</code>（created and written to by some sender-side application）读取数据，并将读取到的stream转化为一系列的TCP segments。</li>
</ul>
<p><code>TCPSender</code>的职责：</p>
<ul>
<li>Keep track of the receiver’s window;</li>
<li>尽可能将window填满（通过从<code>ByteStream</code>读取数据，创建新的TCP segments）。在窗口满之前，或是<code>ByteStream</code>没有数据发送之前，sender都应该尽可能地发送segment。</li>
<li>Keep track of which segments have been sent but not yet acknowledged by the receiver，这样地segment称为”outstanding” segments。</li>
<li>重发超时的”outstanding” segments。</li>
</ul>
<p><code>TCPSender</code>发送a bunch of <code>TCPSenderMessage</code>s。</p>
<ul>
<li>每个message包含来自outgoing <code>ByteStream</code>的子串，由sequence number指导其在整个stream中的位置；</li>
<li>SYN flag指示stream的开始；</li>
<li>FIN flag指示stream的结束。</li>
<li>除此之外，<code>TCPSender</code>还需要keep track of its outstanding segments，直到被这些outstanding segments占据的sequence number被确认接收了。</li>
<li><code>TCPSender</code>的拥有者会周期性地调用<code>TCPSender</code>的 <code>tick</code>方法，用来指示经过的时间。<code>TCPSender</code>需要负责检查outstanding <code>TCPSenderMessage</code>，以决定最久发送的outstanding segment是否是超时了。</li>
</ul>
<p>实验要点：</p>
<ol>
<li>时间相关的只能使用<code>tick</code>方法。</li>
<li><code>TCPSender</code>构造的时候，会指定retransmission timeout （RTO）的”initial value”。<ul>
<li>RTO是以milliseconds为单位的重传outstanding TCP segment的时间。</li>
<li>RTO的值可能随着时间变化，但是初始值不变。</li>
</ul>
</li>
<li>需要实现一个重传计时器<code>timer</code>。<ul>
<li>一个开始于某个时间的闹钟</li>
<li>当RTO时间过去之后自动终止。</li>
</ul>
</li>
<li>每当包含数据（nonzero length in sequence space）的segment被发送之后，如果timer没有开始运行，需要启动timer，计时在RTO ms之后终止。</li>
<li>当所有的outstanding data被确认接收的时候，停止retransmission timer。</li>
<li>如果<code>tick</code>被调用了，但是retranssmission timer终止了：<ol>
<li>重传最早的没有被TCP receiver接收的segment。</li>
<li>如果窗口非零：<ol>
<li>记录<strong>连续重传的次数</strong>，重传之后增加计数。<code>TCPConnection</code>将用于决策当前的连接是否是有希望的。</li>
<li>Double the value of RTO。</li>
</ol>
</li>
<li>重置retranssmission timer，RTO ms之后超时。</li>
</ol>
</li>
<li>当receiver给sender发送一个<code>ackno</code>要新数据的时候（比之前所有的<code>ackno</code>都要大）的时候：<ol>
<li>将RTO设置回”initial value”；</li>
<li>如果sender有任何outstanding data，重启retransmission timer。</li>
<li>重置连续重传的次数为0。</li>
</ol>
</li>
</ol>
<h3 id="Program-Structure-and-Design-of-the-TCPSender"><a href="#Program-Structure-and-Design-of-the-TCPSender" class="headerlink" title="Program Structure and Design of the TCPSender:"></a>Program Structure and Design of the TCPSender:</h3><p>需要对整个流程有一个全面的把握，对于一个TCP sender而言，需要维护的信息包括：</p>
<ol>
<li><p>当前<code>TCPSender</code>的状态信息：</p>
<ul>
<li>为了区分连接建立前，连接成功建立后正常发送数据，数据发送结束，三个状态，维护两个变量记录SYN和FIN发送与否，来区分状态：<ul>
<li>SYN没发送，三次握手没有完成，需要发送包含SYN的数据包；</li>
<li>SYN已经发送，正常发送数据；</li>
<li>FIN已经发送，数据发送完毕，单向关闭连接。</li>
</ul>
</li>
<li>使用变量<code>syn_sent_</code>和<code>fin_sent_</code>记录。</li>
</ul>
</li>
<li><p>segment发送相关的信息：</p>
<ul>
<li>ISN，构造<code>TCPSender</code>的时候会提供：<ul>
<li>使用变量<code>isn_</code>记录。</li>
</ul>
</li>
<li>当前收到接收者的最大ackno，以及窗口大小，用于确认可以发送的数据范围：<ul>
<li>使用变量<code>ackno_</code>记录ackno。</li>
<li>使用变量<code>receiver_window_</code>记录。</li>
</ul>
</li>
<li>已经发送还没有被接受的字节数：<ul>
<li>方便确认还可以发送的字节数（接收者窗口范围内）；</li>
<li>利用变量<code>outstanding_window_</code>。</li>
</ul>
</li>
<li>下一可以发送的序列号：<ul>
<li>直接作为下一可发送消息的起始索引；</li>
<li>可以与ackno和窗口大小，确认当前是否还可以发送消息；</li>
<li>使用变量<code>next_seqno</code>记录。</li>
</ul>
</li>
<li>已经分片好等待发送的segments：<ul>
<li>使用<code>std::queue&lt;TCPSenderMessage&gt;</code>记录。</li>
<li>发送消息消耗该队列；发送完成并不代表被接收了。</li>
</ul>
</li>
<li>需要<strong>注意</strong>，segment发送需要的都是<code>uint64</code>的<strong>absolute sequence number</strong>，在打包消息的时候需要利用<code>Wrap32</code>进行转换。</li>
</ul>
</li>
<li><p>segment超时重传相关：</p>
<ul>
<li>已经发送但还没有接收的segments：<ul>
<li>利用<code>std::queue&lt;TCPSenderMessage&gt;</code>记录；</li>
<li>收到新的ackno，消耗该队列，需要将已经确认的消息从该队列中移除。</li>
</ul>
</li>
<li>初始的RTO，即初始的超时重传时间间隔：<ul>
<li>如果超时需要重传，并且等待重传的时间翻倍，不能一直发；</li>
<li>利用变量<code>initial_RTO_ms_</code>记录。</li>
</ul>
</li>
<li>当前的超时重传时间：<ul>
<li>在成功接收到新的ackno的时候，需要重置为`initial_RTO_ms_；</li>
<li>在超时重传的时候需要不断×2；</li>
<li>利用变量<code>retransmission_timeout</code>记录。</li>
</ul>
</li>
<li>一个计时器timer：<ul>
<li>需要在计时事件到达时间戳的时候提醒时间到达；</li>
<li>计时时间只与当前以发送最早的消息有关；</li>
<li>timer不断通过tick调用来实现时间的不断推移，需要能够判断当前时间是否超时；</li>
<li><strong>特别注意</strong>：时间是一条单独的线，时间的流逝是通过不断累加<code>tick(uint64_t ms_since_last_tick)</code>给的值来判断的，不需要手动调用其他时间函数。<ul>
<li>第一个消息准备好发送的时候发送的时候还是计时，后面的消息只需要查看当前计时器是否开始计时，没有开始计时要及时开启；</li>
<li>收到新的ackno的时候，如果当前有消息发出还未被接收，则重置计时器；否则关闭计时器，因为没有消息发了还未被接收。</li>
</ul>
</li>
</ul>
</li>
<li>维护连续重传的次数，<code>TCPConnection</code>会用于判断连接是否有问题；<ul>
<li>给上层使用的信息，利用<code>consecutive_retransmission_</code>记录；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Implementation-Challenges"><a href="#Implementation-Challenges" class="headerlink" title="Implementation Challenges:"></a>Implementation Challenges:</h3><ol>
<li><p>void TCPSender::push( Reader&amp; outbound_stream )</p>
<ul>
<li>如果当前的发送已经结束（FIN已经发送过了），则不需要再处理。</li>
<li>正常生成发送消息：<ul>
<li>获取可以发送数据的长度<code>[ackno_, ...,以及发送的字节,next_seqno_, ..., ackno + recever_window - 1]</code>。<code>next_seqno</code>到窗口最右端就是当前还可以发送的最大字节数。<ul>
<li>特殊情况，”When filling window, treat a ‘0’ window size as equal to ‘1’ but don’t back off RTO”，窗口的下界是0，但是0要按照1对待。</li>
</ul>
</li>
<li>可以发送数据长度不为0，并且当前还有数据待发，则循环生成待发送消息：<ul>
<li>连接建立的第一个报文（绝对序列号=0）需要包含SYN，SYN也消耗序列号；</li>
<li>生成序列号，需要用到<code>Wrap32</code>提供的<code>wrap()</code>函数；</li>
<li>生成payload，利用<code>ByteStream::read()</code>函数；保证消息上限。</li>
<li>如果当前stream已经结束了，则需要考虑加入FIN，需要保证还可以添加字节到当前的消息中；</li>
<li>如果生成的消息为空，直接丢弃；</li>
<li>将生成的消息添加到待发送队列，等待发送；同时也加入发送但还未接收的队列，确定其成功接收；</li>
<li>更新下一消息的序列号，<code>next_seqno_</code>和已经发送但还未接收的字节数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>optional<TCPSenderMessage> TCPSender::maybe_send()</p>
<ul>
<li>没有消息等待发送，则不需要处理；</li>
<li>超时重传阶段不能发送新的数据，而是将等待当前窗口内的数据重新发送；<ul>
<li>超时重传阶段会重置计时器，用计时器==0，表示正在超时重传发了未被接收的数据；</li>
<li>超时重传，计时器&gt;0，表示当前正在重传最早发但未被接受的消息。等待最早的消息被接受之前，不会发送任何消息。</li>
</ul>
</li>
<li>正常发送数据，取出待发送消息，发送消息，并开始计时器。</li>
</ul>
</li>
<li><p>TCPSenderMessage TCPSender::send_empty_message() </p>
<ul>
<li>只需要正确地设置seqno就可以，没有数据。</li>
</ul>
</li>
<li><p>void TCPSender::receive( const TCPReceiverMessage&amp; msg )</p>
<ul>
<li>收到来自receiver的消息中，如果包含了ackno：<ul>
<li>ackno只在意最大的，小的不用管；</li>
<li>大于还未发送的序列号也应该丢弃；</li>
</ul>
</li>
<li>更新接收者的接收窗口；</li>
<li>从发送但未被接受的队列中删除已经确认的消息；维护其他相关的信息</li>
<li>如果有消息被确认：<ul>
<li>重置超时重传相关的数据</li>
<li>当前没有发了没接收到的消息，则停止计时器；</li>
<li>当前有发了没接收的消息，则重置计时器。</li>
</ul>
</li>
</ul>
</li>
<li><p>void TCPSender::tick( const size_t ms_since_last_tick )</p>
<ul>
<li>tick的流程代表了超时引起的事件，相当于定时任务；</li>
<li>tick累加时间，一旦过去的时间超过了当前的RTO时间，则需要将最早发了还未被接收的数据重新加入待发送队列，重新发送；</li>
<li>如果超时的时候接收者的窗口不为0，则说明网络可能有拥塞，需要调整RTO；</li>
<li>累计超时重传的次数，每次开始重传的时候需要重置计时器。</li>
</ul>
</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;byte_stream.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_receiver_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_sender_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrapping_integers.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_packet.h&gt;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br>  <span class="hljs-type">uint64_t</span> ticks&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">bool</span> running_&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/** Timer是否正在运行*/</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_running</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> running_; &#125;<br><br>  <span class="hljs-comment">/** Timer是否已经超时*/</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_expired</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> ms_since_last_tick, <span class="hljs-type">uint64_t</span> timeout)</span> </span>&#123;<br>    ticks += ms_since_last_tick;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">is_running</span>() &amp;&amp; (ticks &gt;= timeout);<br>  &#125;<br><br>  <span class="hljs-comment">/** 当前的tick*/</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">now</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ticks; &#125;<br><br>  <span class="hljs-comment">/** 启动时钟*/</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    ticks = <span class="hljs-number">0</span>;<br>    running_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/** 关闭时钟*/</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    running_ = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPSender</span><br>&#123;<br>  <span class="hljs-comment">/** ISN*/</span><br>  Wrap32 isn_;<br>  <br>  <span class="hljs-comment">/** 初始的超时重传时间*/</span><br>  <span class="hljs-type">uint64_t</span> initial_RTO_ms_;<br><br>  <span class="hljs-comment">/** 连续超时重传的次数*/</span><br>  <span class="hljs-type">uint64_t</span> consecutive_retransmission_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-comment">/** 当前超时重传时间*/</span><br>  <span class="hljs-type">uint64_t</span> retransmission_timeout&#123;initial_RTO_ms_&#125;;<br><br>  <span class="hljs-comment">/** 记录SYN和FIN是否发送来确认当前的应该执行的操作*/</span><br>  <span class="hljs-type">bool</span> syn_sent_&#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-type">bool</span> fin_sent_&#123;<span class="hljs-literal">false</span>&#125;;<br><br>  <span class="hljs-comment">/** 记录累计确认的序列号*/</span><br>  <span class="hljs-type">uint64_t</span> ackno_&#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-comment">/** 记录当前可发送窗口内的下一带发送字节号*/</span><br>  <span class="hljs-type">uint64_t</span> next_seqno_&#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-comment">/** 已经发送但还没有被接受的字节数*/</span><br>  <span class="hljs-type">uint64_t</span> outstanding_window_&#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-comment">/** 接收窗口*/</span><br>  <span class="hljs-type">uint64_t</span> receiver_window_&#123;<span class="hljs-number">1</span>&#125;;<br><br>  <span class="hljs-comment">/** 发送了或是等待发送，还未被接收的segments*/</span><br>  std::queue&lt;TCPSenderMessage&gt; outstanding_msgs_;<br><br>  <span class="hljs-comment">/** 等待发送的segments*/</span><br>  std::deque&lt;TCPSenderMessage&gt; messages_to_send_;<br><br>  <span class="hljs-comment">/** timer*/</span><br>  Timer timer;<br><br>  <span class="hljs-comment">/** 发送是否结束*/</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sending_finished</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> fin_sent_; &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/* Construct TCP sender with given default Retransmission Timeout and possible ISN */</span><br>  <span class="hljs-built_in">TCPSender</span>( <span class="hljs-type">uint64_t</span> initial_RTO_ms, std::optional&lt;Wrap32&gt; fixed_isn );<br><br>  <span class="hljs-comment">/* 尽可能地将outbound_stream的数据以segment的形式包装起来，等待发送。 */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">( Reader&amp; outbound_stream )</span></span>;<br><br>  <span class="hljs-comment">/* 真正发送TCP segments的时候（消耗messages_to_send_），Send a TCPSenderMessage if needed (or empty optional otherwise) */</span><br>  <span class="hljs-function">std::optional&lt;TCPSenderMessage&gt; <span class="hljs-title">maybe_send</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">/* 生成空的TCP segment。Generate an empty TCPSenderMessage */</span><br>  <span class="hljs-function">TCPSenderMessage <span class="hljs-title">send_empty_message</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">/* 接收来自TCP receiver的消息（消耗outstanding_msgs_）。Receive an act on a TCPReceiverMessage from the peer&#x27;s receiver */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receive</span><span class="hljs-params">( <span class="hljs-type">const</span> TCPReceiverMessage&amp; msg )</span></span>;<br><br>  <span class="hljs-comment">/* 通过调用tick来累计时间，超时需要重新将outstanding的消息发送。Time has passed by the given # of milliseconds since the last time the tick() method was called. */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tick</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> ms_since_last_tick )</span></span>;<br><br>  <span class="hljs-comment">/* Accessors for use in testing */</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">sequence_numbers_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// How many sequence numbers are outstanding?</span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// How many consecutive *re*transmissions have happened?</span><br>&#125;;<br><br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_sender.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;buffer.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;byte_stream.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_config.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tcp_sender_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrapping_integers.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/* TCPSender constructor (uses a random ISN if none given) */</span><br>TCPSender::<span class="hljs-built_in">TCPSender</span>( <span class="hljs-type">uint64_t</span> initial_RTO_ms, optional&lt;Wrap32&gt; fixed_isn )<br>  : <span class="hljs-built_in">isn_</span>( fixed_isn.<span class="hljs-built_in">value_or</span>( Wrap32 &#123; <span class="hljs-built_in">random_device</span>()() &#125; ) ), <span class="hljs-built_in">initial_RTO_ms_</span>( initial_RTO_ms )<br>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::sequence_numbers_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> outstanding_window_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> consecutive_retransmission_;<br>&#125;<br><br><span class="hljs-function">optional&lt;TCPSenderMessage&gt; <span class="hljs-title">TCPSender::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 没有打包好的message不需要发送</span><br>  <span class="hljs-keyword">if</span> (messages_to_send_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>  <span class="hljs-comment">// 正在进行超时重传的时候不能发送新的message</span><br>  <span class="hljs-keyword">if</span> (consecutive_retransmission_ &amp;&amp; timer.<span class="hljs-built_in">is_running</span>() &amp;&amp; timer.<span class="hljs-built_in">now</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>  <span class="hljs-comment">// 正常发送数据包</span><br>  TCPSenderMessage msg = messages_to_send_.<span class="hljs-built_in">front</span>();<br>  messages_to_send_.<span class="hljs-built_in">pop_front</span>();<br>  <span class="hljs-comment">// 启动时钟</span><br>  <span class="hljs-keyword">if</span> (!timer.<span class="hljs-built_in">is_running</span>()) &#123;<br>    timer.<span class="hljs-built_in">start</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> msg;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::push</span><span class="hljs-params">( Reader&amp; outbound_stream )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 当且仅当发送还没有结束（FIN是否发送）的时候，才会生成message，等待发送</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sending_finished</span>()) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 正常发送</span><br>  <span class="hljs-comment">// 首先获取当前可以发送的字节数。注意SYN和FIN也会分别占据一个字节号</span><br>  <span class="hljs-type">uint64_t</span> sending_window = ackno_ + (receiver_window_ ? receiver_window_ : <span class="hljs-number">1</span>) - next_seqno_;<br>  <span class="hljs-keyword">while</span> (sending_window &gt; <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-built_in">sending_finished</span>()) &#123;<br>    <span class="hljs-comment">// 生成message</span><br>    TCPSenderMessage msg;<br>    <span class="hljs-keyword">if</span> (next_seqno_ == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 首个msg需要发送SYN，并且SYN会占据一个字节</span><br>      msg.SYN = <span class="hljs-literal">true</span>;<br>      syn_sent_ = <span class="hljs-literal">true</span>;<br>      --sending_window; <span class="hljs-comment">// SYN占据一个字节</span><br>    &#125;<br>    <span class="hljs-comment">// 设置序列号，转化成Wrap32</span><br>    msg.seqno = Wrap32::<span class="hljs-built_in">wrap</span>(next_seqno_, isn_);<br>    <span class="hljs-comment">// 从outbound_stream中读取数据，添加payload到msg中。利用ByteStream中提供的helper函数实现</span><br>    Buffer &amp;buffer = msg.payload;<br>    <span class="hljs-built_in">read</span>(outbound_stream, <span class="hljs-built_in">min</span>(sending_window, TCPConfig::MAX_PAYLOAD_SIZE), buffer);<br>    <span class="hljs-comment">// 更新窗口，并且检查是否发送完成（是否需要添加FIN到msg）</span><br>    sending_window -= msg.<span class="hljs-built_in">sequence_length</span>();<br>    <span class="hljs-keyword">if</span> (sending_window &gt; <span class="hljs-number">0</span> &amp;&amp; outbound_stream.<span class="hljs-built_in">is_finished</span>()) &#123;<br>      <span class="hljs-comment">// 添加FIN</span><br>      msg.FIN = <span class="hljs-literal">true</span>;<br>      fin_sent_ = <span class="hljs-literal">true</span>;<br>      --sending_window; <span class="hljs-comment">// FIN占据一个字节</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg.<span class="hljs-built_in">sequence_length</span>() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 出现空的msg结束</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 添加msg到待发送队列</span><br>    messages_to_send_.<span class="hljs-built_in">emplace_back</span>(msg);<br>    <span class="hljs-comment">// 添加到outstanding_msgs队列，以确保正确接收</span><br>    outstanding_msgs_.<span class="hljs-built_in">emplace</span>(msg);<br>    <span class="hljs-comment">// 更新next_seqno_以及已经加入发送队列的字节数</span><br>    next_seqno_ += msg.<span class="hljs-built_in">sequence_length</span>();<br>    outstanding_window_ += msg.<span class="hljs-built_in">sequence_length</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function">TCPSenderMessage <span class="hljs-title">TCPSender::send_empty_message</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  TCPSenderMessage msg&#123;<br>    .seqno = Wrap32::<span class="hljs-built_in">wrap</span>(next_seqno_, isn_)<br>  &#125;;<br>  <span class="hljs-keyword">return</span> msg;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::receive</span><span class="hljs-params">( <span class="hljs-type">const</span> TCPReceiverMessage&amp; msg )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 假定新的ackno都是大于当前之前的ackno</span><br>  <span class="hljs-keyword">if</span> (msg.ackno.<span class="hljs-built_in">has_value</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> new_ackno = msg.ackno-&gt;<span class="hljs-built_in">unwrap</span>(isn_, next_seqno_);<br>    ackno_ = <span class="hljs-built_in">max</span>(ackno_, new_ackno);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (ackno_ &gt; next_seqno_) &#123; <span class="hljs-comment">// &quot;Impossible ackno (beyond next seqno) is ignored&quot;</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  receiver_window_ = msg.window_size;<br>  <span class="hljs-type">bool</span> new_check = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (!outstanding_msgs_.<span class="hljs-built_in">empty</span>()) &#123;<br>    TCPSenderMessage out_msg = outstanding_msgs_.<span class="hljs-built_in">front</span>();<br>    <span class="hljs-keyword">auto</span> out_msg_seqno = out_msg.seqno.<span class="hljs-built_in">unwrap</span>(isn_, next_seqno_); <span class="hljs-comment">// ?</span><br>    <span class="hljs-keyword">auto</span> out_msg_len = out_msg.<span class="hljs-built_in">sequence_length</span>();<br>    <span class="hljs-keyword">if</span> (out_msg_seqno + out_msg_len &gt; ackno_) &#123;<br>      <span class="hljs-comment">// 到第一个还未确定的msg终止</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// msg已经被确认了，需要及时从outstanding_msgs_中删除</span><br>    outstanding_msgs_.<span class="hljs-built_in">pop</span>();<br>    outstanding_window_ -= out_msg_len;<br>    new_check = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 是否收到了新的确认，需要重置计时器，以及超时重传时间和连续重传的次数</span><br>  <span class="hljs-keyword">if</span> (new_check) &#123;<br>    retransmission_timeout = initial_RTO_ms_;<br>    consecutive_retransmission_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (outstanding_msgs_.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-comment">// 没有outstanding message的时候，停止计时器 </span><br>      timer.<span class="hljs-built_in">stop</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 重新开始计时</span><br>      timer.<span class="hljs-built_in">start</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 只有超时，并且outstanding不为空的时候，需要重传outstanding中最早被发送的消息</span><br>  <span class="hljs-keyword">if</span> (timer.<span class="hljs-built_in">is_expired</span>(ms_since_last_tick, retransmission_timeout) &amp;&amp; !outstanding_msgs_.<span class="hljs-built_in">empty</span>()) &#123;<br>    messages_to_send_.<span class="hljs-built_in">emplace_front</span>(outstanding_msgs_.<span class="hljs-built_in">front</span>());<br>    <span class="hljs-keyword">if</span> (receiver_window_) &#123;<br>      retransmission_timeout &lt;&lt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 超时重传时间间隔翻倍</span><br>    &#125;<br>    ++consecutive_retransmission_; <span class="hljs-comment">// 连续重传计数</span><br>    <span class="hljs-built_in">maybe_send</span>(); <span class="hljs-comment">// 尝试发送消息；调用的时候timer.ticks = 0，表示再进行超时重传，因此会将窗口内的消息重传</span><br>    timer.<span class="hljs-built_in">start</span>(); <span class="hljs-comment">// 再次开始计时</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<h2 id="Lab-4-Network-Interface"><a href="#Lab-4-Network-Interface" class="headerlink" title="Lab 4 Network Interface"></a>Lab 4 Network Interface</h2><p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2021/11/cs144-lab5/">CS144计算机网络 Lab5 | Kiprey’s Blog</a></p>
<p>本周的实现需要实现network interface:</p>
<ul>
<li>The bridge between Internet datagrams that travel the world, and link-layer Ethernet frames that travel one hop.</li>
<li><img src="image-20230526105913205.png" srcset="/img/loading.gif" lazyload alt="image-20230526105913205"></li>
</ul>
<p><em><strong>network interface</strong></em>:</p>
<ul>
<li>A component that translates outbound IP datagrams into link-layer (e.g., Ethernet) frames and vice versa.</li>
</ul>
<p>Most of the work will be in <strong>looking up</strong> (and <strong>caching</strong>) the <em><strong>Ethernet address</strong></em> for each next-hop <em><strong>IP address</strong></em>.</p>
<ul>
<li>The protocal for this is called the <strong>Address Resolution Protocol</strong> (<strong>ARP</strong>).</li>
</ul>
<h3 id="Checkpoint-4：-The-Address-Resolution-Protocol"><a href="#Checkpoint-4：-The-Address-Resolution-Protocol" class="headerlink" title="Checkpoint 4： The Address Resolution Protocol"></a>Checkpoint 4： The Address Resolution Protocol</h3><p>主要的任务就是实现<code>NetworkInteface</code> (<code>network_interface.cc</code>)的三个主要的methods，同时维护从IP address到 Ethernet address的mapping。</p>
<ul>
<li>mapping就是一个cache，主要的目的是效率。</li>
</ul>
<p>需要实现的函数：</p>
<ol>
<li><code>void NetworkInterface::send datagram(const InternetDatagram &amp;dgram, const Address &amp;next hop);</code><ul>
<li>该方法在调用者（如<code>TCPConnection</code>或是router）想要发送一个outbound Internet (IP) datagram到the next hop的时候调用。</li>
<li>需要完成的任务就是将datagram转化成Ethernet frame，然后发送出去。<ul>
<li>如果the next hop的目标Ethernet address是已知的，立即发送。<ul>
<li>创建一个Ethernet frame （with type = <code>EthernetHeader::TYPE_IPv4</code>）；</li>
<li>将payload设置为the serialized datagram；</li>
<li>Set the source and destination adddress.</li>
</ul>
</li>
<li>如果the next hop的目标Ethernet address是未知的，广播ARP request帧来询问下一跳的Ethernet address；将IP datagram加入queue，ARP reply收到之后可以被发送。<ul>
<li>ARP广播：目标MAC地址为全0；目标IP地址是就是等待发送datagram的主机IP地址。</li>
</ul>
</li>
</ul>
</li>
<li>Except：我们并不希望整个网络中都是ARP request，因此对于the same IP address已经在过去的5秒内发送过了ARP request，则不要再次发送ARP request了，等待第一次发送ARP request的回复。</li>
<li>将目标Ethernet address目前还未知的datagram加入queue。</li>
</ul>
</li>
<li><code>optional&lt;InternetDatagram&gt; NetworkInterface::recv_frame(const EthernetFrame &amp;frame);</code><ul>
<li>该方法在收到来自网络的Ethernet frame被调用。</li>
<li>忽略所有目标地址不是自己的Ethernet frames。<ul>
<li>Ethernet destination要么是broadcast address，要么是interface’s own Ethernet address （保存在<code>_ethernet_address</code>成员变量）。</li>
</ul>
</li>
<li>收到的frame包括两种：<ul>
<li>inbound frame是<em><strong>IPv4</strong></em>：<ul>
<li>parse the payload as an <code>InternetDatagram</code>，</li>
<li>如果parse成功，则返回结果<code>InternetDatagram</code>给调用者。</li>
</ul>
</li>
<li>inbound frame是<em><strong>ARP</strong></em>：<ul>
<li>parse the pay load as an <code>ARPMessage</code>，</li>
<li>如果parse成功，记住从sender’s IP address 到 Ethernet address的mapping （只记住30s）。</li>
<li>Learning mappings from both requests and replies.</li>
<li>如果ARP request的是寻求的IP address的地址是自己，则回复ARP reply。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>std::optional&lt;EthernetFrame&gt; maybe_send();</code><ul>
<li>This is the <code>NetworkInterface</code>‘s opportunity to actually send a <code>EthernetFrame</code>（如果想要发送的话）。</li>
</ul>
</li>
<li><code>void NetworkInterface::tick(const size t ms since last tick);</code><ul>
<li>随着事件的流逝调用该函数。</li>
<li>将所有的过期的IP-to-Ethernet mapping 删除。</li>
</ul>
</li>
</ol>
<p>其他问题：</p>
<ul>
<li>100-150行code</li>
<li>通过在<code>maybe_send()</code>函数中返回帧来发送。</li>
<li>记录IP address到Ethernet address的mapping数据结构自己决定</li>
<li>IP address是一个<code>Address</code> object，调用<code>Address:ipv4_numeric()</code>方法转化为32-bit integer</li>
<li>关于ARP request发送了没有收到回复，在本实验中不用担心/现实中会返回ICMP “host unreachable”。<ul>
<li>关于等待Ethernet address，在queue中的InternetDatagram也是一样的，本实验中不用考虑。</li>
</ul>
</li>
<li>关于<code>parse()</code>和<code>serialize()</code>:<ul>
<li><code>parse()</code> takes a <code>T&amp; obj </code>and <code>vector&lt;Buffer&gt;&amp; buffers</code>. <ul>
<li>On success, it fills obj withthe result and returns true. Otherwise, it returns false.</li>
</ul>
</li>
<li><code>serialize()</code> takes a <code>T&amp; obj</code> and returns the result as a <code>vector&lt;Buffer&gt;</code>.</li>
</ul>
</li>
</ul>
<h3 id="Program-Structure-and-Design-of-the-NetworkInterface"><a href="#Program-Structure-and-Design-of-the-NetworkInterface" class="headerlink" title="Program Structure and Design of the NetworkInterface:"></a>Program Structure and Design of the NetworkInterface:</h3><p>根据实验指导书知道，我们需要一个<code>mapping_</code>表来存储已有的地址映射，但是这些映射表项有TTL (30s)，因此表项中也需要记录TTL。对于没有地址映射的IP地址，需要将想要发送的IP数据报加入对应的队列中，等待收到ARP回复或是ARP请求得到该地址映射。对于ARP请求也有一个等待的TTL：5s之内不能再次发送相同的IP地址的ARP请求，超时需要再次发送。</p>
<p>综上所述，本实验中所需要的数据结构总结如下：</p>
<ol>
<li>需要一个<code>std::map</code>存储地址映射，而地址映射包括了{IP地址，ETH地址，TTL}，因此使用一个结构体将{ETH地址，TTL}包装在一起，对于TTL到期的地址映射表项需要及时删除。<ul>
<li>使用一个<code>struct CacheEntry&#123;eth_addr, ttl&#125;</code>存地址映射的表项；</li>
<li>使用一个<code>std::map&lt;uint32_t, CacheEntry&gt;</code>存储实际的地址映射。</li>
</ul>
</li>
<li>需要一个<code>std::map</code>存储等待IP地址的IP数据报，由于每个IP地址可能有多个IP数据报等待发送，因此给每个等待的IP地址都使用一个队列将待发送的数据报存储起来。<ul>
<li>使用一个<code>std::map&lt;uint32_t, std::queue&lt;InternetDatagram&gt;&gt;</code>存储等待发送的IP数据报；</li>
<li>等待的IP数据报等待ARP回复或是广播学习到对应的IP地址之后，再次尝试发送。</li>
</ul>
</li>
<li>相同IP地址的ARP请求的在5s之内不能重传，因此我们需要维护ARP请求的生命期：对于超时的ARP请求需要再次发送；对于未到时的ARP请求需要及时更新对应的TTL。<ul>
<li>使用一个<code>std::map&lt;uint32_t, size_t&gt;</code>每个ARP请求的TTL。</li>
</ul>
</li>
<li>需要使用一个队列将等待发送的帧存储起来等待发送。<ul>
<li>使用一个<code>std::queue&lt;EthernetFrame&gt;</code>存储等待发送的帧。</li>
</ul>
</li>
<li>其余的属性：<ul>
<li><code>ip_address_</code>：自己的IP地址；</li>
<li><code>ethernet_address_</code>：自己的以太网地址；</li>
<li><code>cache_entry_ttl</code>：地址映射的默认最大生命期；</li>
<li><code>arp_ttl</code>：ARP请求的生命期。</li>
</ul>
</li>
</ol>
<h3 id="Implementation-Challenges-1"><a href="#Implementation-Challenges-1" class="headerlink" title="Implementation Challenges:"></a>Implementation Challenges:</h3><p>基本上按照实验说明即可。<br>几个需要注意的地方：</p>
<ul>
<li>对于发送帧，需要将其加入队列等待发送，在<code>maybe_send()</code>函数中，如果不为空，返回帧，否则返回<code>nullopt</code>。</li>
<li>更新或是删除的<code>std::map</code>的时候，需要注意迭代器失效的问题，可以使用一个向量存储过期的IP地址，然后统一删除所有的过期地址。</li>
<li>超时的ARP请求需要重发。</li>
<li>ARP请求的学习是两方法学习：<ul>
<li>收到ARP request，可以学习；</li>
<li>收到ARP reply，可以学习；</li>
<li>学习到新的IP地址到ETH地址的映射之后，需要及时将等待中的IP数据包重新发送。</li>
</ul>
</li>
<li><code>std::map</code>的安全删除，先遍历，记录下需要删除的键，再统一删除。<ul>
<li>往上推荐的做法是map.erase(iter++)，效果类似。</li>
</ul>
</li>
</ul>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ethernet_frame.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ethernet_header.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ipv4_datagram.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-comment">// A &quot;network interface&quot; that connects IP (the internet layer, or network layer)</span><br><span class="hljs-comment">// with Ethernet (the network access layer, or link layer).</span><br><br><span class="hljs-comment">// This module is the lowest layer of a TCP/IP stack</span><br><span class="hljs-comment">// (connecting IP with the lower-layer network protocol,</span><br><span class="hljs-comment">// e.g. Ethernet). But the same module is also used repeatedly</span><br><span class="hljs-comment">// as part of a router: a router generally has many network</span><br><span class="hljs-comment">// interfaces, and the router&#x27;s job is to route Internet datagrams</span><br><span class="hljs-comment">// between the different interfaces.</span><br><br><span class="hljs-comment">// The network interface translates datagrams (coming from the</span><br><span class="hljs-comment">// &quot;customer,&quot; e.g. a TCP/IP stack or router) into Ethernet</span><br><span class="hljs-comment">// frames. To fill in the Ethernet destination address, it looks up</span><br><span class="hljs-comment">// the Ethernet address of the next IP hop of each datagram, making</span><br><span class="hljs-comment">// requests with the [Address Resolution Protocol](\ref rfc::rfc826).</span><br><span class="hljs-comment">// In the opposite direction, the network interface accepts Ethernet</span><br><span class="hljs-comment">// frames, checks if they are intended for it, and if so, processes</span><br><span class="hljs-comment">// the the payload depending on its type. If it&#x27;s an IPv4 datagram,</span><br><span class="hljs-comment">// the network interface passes it up the stack. If it&#x27;s an ARP</span><br><span class="hljs-comment">// request or reply, the network interface processes the frame</span><br><span class="hljs-comment">// and learns or replies as necessary.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkInterface</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CacheEntry</span> &#123;<br>    EthernetAddress eth_addr;<br>    <span class="hljs-type">size_t</span> ttl;<br>  &#125;;<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> cache_entry_ttl = <span class="hljs-number">30000</span>;<br><br>  <span class="hljs-comment">// Ethernet (known as hardware, network-access, or link-layer) address of the interface</span><br>  EthernetAddress ethernet_address_;<br><br>  <span class="hljs-comment">// IP (known as Internet-layer or network-layer) address of the interface</span><br>  Address ip_address_;<br><br>  <span class="hljs-comment">/** 内部的转发表Cache*/</span><br>  std::map&lt;<span class="hljs-type">uint32_t</span>, CacheEntry&gt; mapping_;<br><br>  <span class="hljs-comment">/** 等待发送的EthernetFrame队列*/</span><br>  std::queue&lt;EthernetFrame&gt; frames_to_send_;<br><br>  <span class="hljs-comment">/** 等待Ethernet address的InternetDatagram*/</span><br>  std::map&lt;<span class="hljs-type">uint32_t</span>, std::queue&lt;InternetDatagram&gt;&gt; datagram_waiting_;<br><br>  <span class="hljs-comment">/** 记录正在等待的ARP reply的IP address， 5s更新*/</span><br>  std::map&lt;<span class="hljs-type">uint32_t</span>, <span class="hljs-type">size_t</span>&gt; arp_waiting_time_;<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> arp_ttl_ = <span class="hljs-number">5000</span>;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Construct a network interface with given Ethernet (network-access-layer) and IP (internet-layer)</span><br>  <span class="hljs-comment">// addresses</span><br>  <span class="hljs-built_in">NetworkInterface</span>( <span class="hljs-type">const</span> EthernetAddress&amp; ethernet_address, <span class="hljs-type">const</span> Address&amp; ip_address );<br><br>  <span class="hljs-comment">// Access queue of Ethernet frames awaiting transmission</span><br>  <span class="hljs-function">std::optional&lt;EthernetFrame&gt; <span class="hljs-title">maybe_send</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">// Sends an IPv4 datagram, encapsulated in an Ethernet frame (if it knows the Ethernet destination</span><br>  <span class="hljs-comment">// address). Will need to use [ARP](\ref rfc::rfc826) to look up the Ethernet destination address</span><br>  <span class="hljs-comment">// for the next hop.</span><br>  <span class="hljs-comment">// (&quot;Sending&quot; is accomplished by making sure maybe_send() will release the frame when next called,</span><br>  <span class="hljs-comment">// but please consider the frame sent as soon as it is generated.)</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send_datagram</span><span class="hljs-params">( <span class="hljs-type">const</span> InternetDatagram&amp; dgram, <span class="hljs-type">const</span> Address&amp; next_hop )</span></span>;<br><br>  <span class="hljs-comment">// Receives an Ethernet frame and responds appropriately.</span><br>  <span class="hljs-comment">// If type is IPv4, returns the datagram.</span><br>  <span class="hljs-comment">// If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span><br>  <span class="hljs-comment">// If type is ARP reply, learn a mapping from the &quot;sender&quot; fields.</span><br>  <span class="hljs-function">std::optional&lt;InternetDatagram&gt; <span class="hljs-title">recv_frame</span><span class="hljs-params">( <span class="hljs-type">const</span> EthernetFrame&amp; frame )</span></span>;<br><br>  <span class="hljs-comment">// Called periodically when time elapses</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tick</span><span class="hljs-params">( <span class="hljs-type">size_t</span> ms_since_last_tick )</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;network_interface.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;arp_message.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;buffer.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ethernet_frame.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ethernet_header.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ipv4_datagram.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;parser.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// ethernet_address: Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span><br><span class="hljs-comment">// ip_address: IP (what ARP calls &quot;protocol&quot;) address of the interface</span><br>NetworkInterface::<span class="hljs-built_in">NetworkInterface</span>( <span class="hljs-type">const</span> EthernetAddress&amp; ethernet_address, <span class="hljs-type">const</span> Address&amp; ip_address )<br>  : <span class="hljs-built_in">ethernet_address_</span>( ethernet_address ), <span class="hljs-built_in">ip_address_</span>( ip_address )<br>&#123;<br>  cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="hljs-built_in">to_string</span>( ethernet_address_ ) &lt;&lt; <span class="hljs-string">&quot; and IP address &quot;</span><br>       &lt;&lt; ip_address.<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// dgram: the IPv4 datagram to be sent</span><br><span class="hljs-comment">// next_hop: the IP address of the interface to send it to (typically a router or default gateway, but</span><br><span class="hljs-comment">// may also be another host if directly connected to the same network as the destination)</span><br><br><span class="hljs-comment">// Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) by using the</span><br><span class="hljs-comment">// Address::ipv4_numeric() method.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::send_datagram</span><span class="hljs-params">( <span class="hljs-type">const</span> InternetDatagram&amp; dgram, <span class="hljs-type">const</span> Address&amp; next_hop )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> next_hop_ip = next_hop.<span class="hljs-built_in">ipv4_numeric</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> next_hop_iter = mapping_.<span class="hljs-built_in">find</span>(next_hop_ip);<br>  <span class="hljs-keyword">if</span> (next_hop_iter != mapping_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// next hop 的Ethernet address已知，在cache中。</span><br>    <span class="hljs-comment">// 直接构造EthernetFrame，加入发送队列，由maybe_send()函数发送。</span><br>    EthernetFrame frame;<br>    frame.header = &#123;<br>      .dst = next_hop_iter-&gt;second.eth_addr,<br>      .src = ethernet_address_,<br>      .type = EthernetHeader::TYPE_IPv4,<br>    &#125;;<br>    frame.payload = <span class="hljs-built_in">serialize</span>(dgram);<br>    <span class="hljs-comment">// frame封装完毕，加入待发送队列</span><br>    frames_to_send_.<span class="hljs-built_in">push</span>(frame);<br>    <span class="hljs-comment">// frame_to_send_ = frame;</span><br>    <span class="hljs-comment">// maybe_send();</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 将IP数据包加入等待队列</span><br>  datagram_waiting_[next_hop_ip].<span class="hljs-built_in">push</span>(dgram);<br>  <span class="hljs-comment">// 是否需要发送ARP request还是等待</span><br>  <span class="hljs-keyword">if</span> (arp_waiting_time_.<span class="hljs-built_in">find</span>(next_hop_ip) == arp_waiting_time_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 需要发送ARP request</span><br>    <span class="hljs-comment">// next hop的Ethernet address还是未知的，需要发送ARP request</span><br>    EthernetFrame arp_frame;<br>    arp_frame.header = &#123;<br>      .dst = ETHERNET_BROADCAST,<br>      .src = ethernet_address_,<br>      .type = EthernetHeader::TYPE_ARP<br>    &#125;;<br><br>    <span class="hljs-comment">// 设置ARP request信息</span><br>    ARPMessage arp_msg;<br>    arp_msg = &#123;<br>      .opcode = ARPMessage::OPCODE_REQUEST,<br>      .sender_ethernet_address = ethernet_address_,<br>      .sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>(),<br>      .target_ethernet_address = &#123;&#125;,<br>      .target_ip_address = next_hop_ip<br>    &#125;;<br>    arp_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>    <span class="hljs-comment">// 加入待发送帧，发送ARP request</span><br>    frames_to_send_.<span class="hljs-built_in">push</span>(arp_frame);<br>    <span class="hljs-comment">// frame_to_send_ = arp_frame;</span><br>    <span class="hljs-comment">// maybe_send();</span><br>    arp_waiting_time_[next_hop.<span class="hljs-built_in">ipv4_numeric</span>()] = arp_ttl_; <span class="hljs-comment">// 记录ARP 等待ttl</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// frame: the incoming Ethernet frame</span><br><span class="hljs-function">optional&lt;InternetDatagram&gt; <span class="hljs-title">NetworkInterface::recv_frame</span><span class="hljs-params">( <span class="hljs-type">const</span> EthernetFrame&amp; frame )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 只接收广播或是发给自己的frame</span><br>  <span class="hljs-keyword">if</span> (frame.header.dst != ETHERNET_BROADCAST &amp;&amp; frame.header.dst != ethernet_address_) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>  &#125;<br>  InternetDatagram dgram;<br>  <span class="hljs-comment">// 根据frame的类型进行操作</span><br>  <span class="hljs-comment">// IPv4</span><br>  <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_IPv4) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parse</span>(dgram, frame.payload)) &#123;<br>      <span class="hljs-keyword">return</span> dgram;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>  &#125;<br>  <span class="hljs-comment">// ARP </span><br>  <span class="hljs-keyword">if</span> (frame.header.type == EthernetHeader::TYPE_ARP) &#123;<br>    ARPMessage arp_msg;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parse</span>(arp_msg, frame.payload)) &#123;<br>      <span class="hljs-comment">// 收到ARP request或者ARP reply都记录下mapping 30s</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> &amp;src_ip_addr = arp_msg.sender_ip_address;<br>      <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> &amp;dst_ip_addr = arp_msg.target_ip_address;<br>      <span class="hljs-type">const</span> EthernetAddress &amp;src_eth_addr = arp_msg.sender_ethernet_address;<br>      <span class="hljs-type">const</span> EthernetAddress &amp;dst_eth_addr = arp_msg.target_ethernet_address;<br>      <span class="hljs-type">bool</span> is_valid_arp_request = arp_msg.opcode == ARPMessage::OPCODE_REQUEST &amp;&amp; dst_ip_addr == ip_address_.<span class="hljs-built_in">ipv4_numeric</span>();<br>      <span class="hljs-type">bool</span> is_valid_arp_response = arp_msg.opcode == ARPMessage::OPCODE_REPLY &amp;&amp; dst_eth_addr == ethernet_address_;<br><br>      <span class="hljs-comment">// 收到的是ARP request</span><br>      <span class="hljs-keyword">if</span> (is_valid_arp_request) &#123;<br>        <span class="hljs-comment">// 收到的是ARP request并且恰好就是发送给自己的，则需要回复</span><br>        <span class="hljs-comment">// 设置以太网帧</span><br>        EthernetFrame arp_frame;<br>        arp_frame.header = &#123;<br>          .dst = src_eth_addr,<br>          .src = ethernet_address_,<br>          .type = EthernetHeader::TYPE_ARP<br>        &#125;;<br>        <span class="hljs-comment">// 设置ARP回复消息</span><br>        ARPMessage arp_rpl;<br>        arp_rpl = &#123;<br>          .opcode = ARPMessage::OPCODE_REPLY,<br>          .sender_ethernet_address = ethernet_address_,<br>          .sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>(),<br>          .target_ethernet_address = src_eth_addr,<br>          .target_ip_address = src_ip_addr<br>        &#125;;<br>        <span class="hljs-comment">// 将ARP报文包装到以太网帧中</span><br>        arp_frame.payload = <span class="hljs-built_in">serialize</span>(arp_rpl);<br>        <span class="hljs-comment">// 加入发送队列</span><br>        frames_to_send_.<span class="hljs-built_in">push</span>(arp_frame);<br>        <span class="hljs-comment">// frame_to_send_ = arp_frame;</span><br>        <span class="hljs-comment">// maybe_send();</span><br>      &#125;<br><br>      <span class="hljs-comment">// 从ARP request和ARPreply中学习mapping_</span><br>      <span class="hljs-keyword">if</span> (is_valid_arp_request || is_valid_arp_response) &#123;<br>        <span class="hljs-comment">// 设置学习到的mapping_</span><br>        mapping_[src_ip_addr] = &#123;src_eth_addr, cache_entry_ttl&#125;;<br>        <span class="hljs-comment">// 设置了mapping，需要取出正在等待该next_hop_ip的datagram再次发送</span><br>        <span class="hljs-keyword">auto</span> &amp;dg_que = datagram_waiting_[src_ip_addr];<br>        <span class="hljs-keyword">while</span> (!dg_que.<span class="hljs-built_in">empty</span>()) &#123;<br>          <span class="hljs-comment">// 将队列中的datagram重新发送</span><br>          <span class="hljs-built_in">send_datagram</span>(dg_que.<span class="hljs-built_in">front</span>(), Address::<span class="hljs-built_in">from_ipv4_numeric</span>(src_ip_addr));<br>          dg_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-comment">// 从ARP等待中删除</span><br>        arp_waiting_time_.<span class="hljs-built_in">erase</span>(src_ip_addr);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-comment">// ms_since_last_tick: the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::tick</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 更新IP address mapping的每一项存在时间</span><br><span class="hljs-comment">   * 正在发送的ARP时间</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// 删除存在超时的cache项</span><br>  <span class="hljs-comment">// 方法1： map.erase(iter++)做法</span><br>  <span class="hljs-comment">// for (auto iter = mapping_.begin(); iter != mapping_.end(); ) &#123;</span><br>  <span class="hljs-comment">//   if (iter-&gt;second.ttl &lt;= ms_since_last_tick) &#123;</span><br>  <span class="hljs-comment">//     mapping_.erase(iter++);</span><br>  <span class="hljs-comment">//   &#125; else &#123;</span><br>  <span class="hljs-comment">//     iter-&gt;second.ttl -= ms_since_last_tick;</span><br>  <span class="hljs-comment">//     ++iter;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// 方法2： 记录待删除的键</span><br>  vector&lt;<span class="hljs-type">uint32_t</span>&gt; outdated;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[ip_addr, cache_entry] : mapping_) &#123;<br>    <span class="hljs-keyword">if</span> (cache_entry.ttl &lt;= ms_since_last_tick) &#123;<br>      outdated.<span class="hljs-built_in">emplace_back</span>(ip_addr);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cache_entry.ttl -= ms_since_last_tick;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ip_addr : outdated) &#123;<br>    mapping_.<span class="hljs-built_in">erase</span>(ip_addr);<br>  &#125;<br><br>  <span class="hljs-comment">// 重新发送超时的ARP request</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[ip_addr, ttl] : arp_waiting_time_) &#123;<br>    <span class="hljs-keyword">if</span> (ttl &lt;= ms_since_last_tick) &#123;<br>      <span class="hljs-comment">// 超时（超过5s）需要发送ARP request</span><br>      <span class="hljs-comment">// next hop的Ethernet address还是未知的，需要发送ARP request</span><br>      EthernetFrame arp_frame;<br>      arp_frame.header = &#123;<br>        .dst = ETHERNET_BROADCAST,<br>        .src = ethernet_address_,<br>        .type = EthernetHeader::TYPE_ARP<br>      &#125;;<br><br>      <span class="hljs-comment">// 设置ARP request信息</span><br>      ARPMessage arp_msg;<br>      arp_msg = &#123;<br>        .opcode = ARPMessage::OPCODE_REQUEST,<br>        .sender_ethernet_address = ethernet_address_,<br>        .sender_ip_address = ip_address_.<span class="hljs-built_in">ipv4_numeric</span>(),<br>        .target_ethernet_address = &#123;&#125;,<br>        .target_ip_address = ip_addr<br>      &#125;;<br>      arp_frame.payload = <span class="hljs-built_in">serialize</span>(arp_msg);<br>      <span class="hljs-comment">// 重置ARP等待时间</span><br>      ttl = arp_ttl_;<br>      frames_to_send_.<span class="hljs-built_in">push</span>(arp_frame);<br>      <span class="hljs-comment">// frame_to_send_ = arp_frame;</span><br>      <span class="hljs-comment">// maybe_send(); </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// ARP request还未到期，更新ttl</span><br>      ttl -= ms_since_last_tick;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function">optional&lt;EthernetFrame&gt; <span class="hljs-title">NetworkInterface::maybe_send</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 从frames_to_send_中取出frame发送</span><br>  <span class="hljs-keyword">if</span> (frames_to_send_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullopt</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> frame = frames_to_send_.<span class="hljs-built_in">front</span>();<br>  frames_to_send_.<span class="hljs-built_in">pop</span>();<br>  <span class="hljs-keyword">return</span> frame;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h2 id="Lab-5-Building-an-IP-router"><a href="#Lab-5-Building-an-IP-router" class="headerlink" title="Lab 5 Building an IP router"></a>Lab 5 Building an IP router</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34893654/article/details/130140422">路由表的实现方式_qq_34893654的博客-CSDN博客</a></p>
<p>在<code>NetworkInterface</code>之上实现IP router。</p>
<ul>
<li>A <strong>router</strong> has <em><strong>several</strong></em> network interfaces, and can receive Internet datagrams on any of them.</li>
<li>The router’s job is to forward the datagrams it gets according to the <strong>routing table</strong>: a list of rules that tells the router, for any given datagram,<ul>
<li>What interface to send it out;</li>
<li>The IP address of the next hop.</li>
</ul>
</li>
</ul>
<p>我们的任务就是实现一个可以找出上述两个要求的router，并不需要实现生成routing table的算法。</p>
<ul>
<li>仅仅是实现查找routing table的算法。</li>
</ul>
<p>带实现的是一个新的类<code>Router</code>。</p>
<ul>
<li>基于lab4 实现的 <code>NetworkInterface</code>。</li>
<li>IP router只知道IP，并不知道TCP，ARP以及Ethernet的信息。</li>
</ul>
<p>30-60行代码</p>
<h3 id="实现Router"><a href="#实现Router" class="headerlink" title="实现Router"></a>实现<code>Router</code></h3><p><code>Router</code>类需要完成的任务：</p>
<ul>
<li>keep track of a routing table (the list of forwarding rules, or routes), and</li>
<li>forward each datagram it receives:<ul>
<li>to the correct next hop</li>
<li>on the correct outgoing NetworkInterface.</li>
</ul>
</li>
</ul>
<p>需要实现两个methods:</p>
<ol>
<li><code>void add_route(uint32_t route_prefix, uint8_t prefix_length, optional&lt;Address&gt; next_hop, size_t interface_num);</code><ul>
<li>该方法添加一个route到routing table；</li>
<li>需要添加一个私有的data structure成员存储该信息；</li>
<li>该函数主要做的就是保存route等待后来使用。</li>
</ul>
</li>
<li><code>void route()</code><ul>
<li>该方法需要就将每个到来的datagram路由到next hop的对应network interface.</li>
<li>需要实现 <em><strong>longest-prefix match</strong></em>来找到最佳匹配route。<ul>
<li>寻找目标IP地址与routing table中匹配的；</li>
<li>在所有的匹配中选择 the longest-prefix-match route.</li>
<li>如果没有匹配的，则router丢弃该datagram。</li>
<li>router需要减少datagram的TTL，如果TTL已经是0或是减一之后为0，则需要丢弃该datagram。</li>
<li>正常情况下，router需要将修改过TTL的datagram发送到对应的interface（调用<code>interface(interface_num).send_datagram()</code>）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Program-Structure-and-Design-of-the-Router"><a href="#Program-Structure-and-Design-of-the-Router" class="headerlink" title="Program Structure and Design of the Router:"></a>Program Structure and Design of the Router:</h3><p>本次实验使用到的数据结构比较简单，可以利用向量就可以，这里使用了map，因为在匹配的时候只需要用到<code>route_prefix</code>和<code>prefix_length</code>。</p>
<h3 id="Implementation-Challenges-2"><a href="#Implementation-Challenges-2" class="headerlink" title="Implementation Challenges:"></a>Implementation Challenges:</h3><ol>
<li><code>add_route()</code>中直接记录下对应的route</li>
<li>在<code>route()</code>中对于当前router的所有端口（<code>NetworkInterface</code>）进行遍历，<ul>
<li>对于每个端口发来的IP数据报，查找routing table，然后进行转发</li>
<li>首先需要判断TTL，如果TTL为0或是1都没有用，直接丢弃</li>
<li>对于TTL合法的IP数据报，查找已有的routing table表项，寻找最长的匹配：<ul>
<li>不能直接进行移位判断，因为C++对一个32位整数的32位移位是不允许的；</li>
<li>分成三种情况：<br>  (1) $prefiex length == 0$：只有没有成功匹配的时候有用，有过匹配都可以忽略，因为不可能比0更短的匹配了；<br>  (2) $prefiex length == 32$：直接比较就可以，如果比较成功也结束了，因为不会还有更长的匹配了，32就是最长的；<br>  (3) $1 \le prefiex length \le 31$：与掩码<code>mask = 0xFFFFFFFF &lt;&lt; (32 - prefix_length)</code>做按位与<code>mask &amp; dst_ip_addr == route_prefix</code>。</li>
<li>比较的过程中需要注意<code>optional&lt;Address&gt;</code>中是否有值。</li>
</ul>
</li>
</ul>
</li>
<li>在数据报转发之前，由于TTL已经发生了变化，需要重新计算校验和，可以检查<code>IPv4Header</code>类定义发现，提供了计算校验和的函数<code>compute_checksum()</code>。</li>
</ol>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;network_interface.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-comment">// A wrapper for NetworkInterface that makes the host-side</span><br><span class="hljs-comment">// interface asynchronous: instead of returning received datagrams</span><br><span class="hljs-comment">// immediately (from the `recv_frame` method), it stores them for</span><br><span class="hljs-comment">// later retrieval. Otherwise, behaves identically to the underlying</span><br><span class="hljs-comment">// implementation of NetworkInterface.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncNetworkInterface</span> : <span class="hljs-keyword">public</span> NetworkInterface<br>&#123;<br>  std::queue&lt;InternetDatagram&gt; datagrams_in_ &#123;&#125;;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> NetworkInterface::NetworkInterface;<br><br>  <span class="hljs-comment">// Construct from a NetworkInterface</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AsyncNetworkInterface</span><span class="hljs-params">( NetworkInterface&amp;&amp; interface )</span> : NetworkInterface( interface ) &#123;</span>&#125;<br><br>  <span class="hljs-comment">// \brief Receives and Ethernet frame and responds appropriately.</span><br><br>  <span class="hljs-comment">// - If type is IPv4, pushes to the `datagrams_out` queue for later retrieval by the owner.</span><br>  <span class="hljs-comment">// - If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span><br>  <span class="hljs-comment">// - If type is ARP reply, learn a mapping from the &quot;target&quot; fields.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// \param[in] frame the incoming Ethernet frame</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recv_frame</span><span class="hljs-params">( <span class="hljs-type">const</span> EthernetFrame&amp; frame )</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">auto</span> optional_dgram = NetworkInterface::<span class="hljs-built_in">recv_frame</span>( frame );<br>    <span class="hljs-keyword">if</span> ( optional_dgram.<span class="hljs-built_in">has_value</span>() ) &#123;<br>      datagrams_in_.<span class="hljs-built_in">push</span>( std::<span class="hljs-built_in">move</span>( optional_dgram.<span class="hljs-built_in">value</span>() ) );<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// Access queue of Internet datagrams that have been received</span><br>  <span class="hljs-function">std::optional&lt;InternetDatagram&gt; <span class="hljs-title">maybe_receive</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> ( datagrams_in_.<span class="hljs-built_in">empty</span>() ) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    InternetDatagram datagram = std::<span class="hljs-built_in">move</span>( datagrams_in_.<span class="hljs-built_in">front</span>() );<br>    datagrams_in_.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> datagram;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// A router that has multiple network interfaces and</span><br><span class="hljs-comment">// performs longest-prefix-match routing between them.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span><br>&#123;<br>  <span class="hljs-comment">// The router&#x27;s collection of network interfaces</span><br>  std::vector&lt;AsyncNetworkInterface&gt; interfaces_ &#123;&#125;;<br><br>  <span class="hljs-comment">/** 使用一个map存routing table*/</span><br>  std::map&lt;std::pair&lt;<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint8_t</span>&gt;, std::pair&lt;std::optional&lt;Address&gt;, <span class="hljs-type">size_t</span>&gt;&gt; routing_table_;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Add an interface to the router</span><br>  <span class="hljs-comment">// interface: an already-constructed network interface</span><br>  <span class="hljs-comment">// returns the index of the interface after it has been added to the router</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">add_interface</span><span class="hljs-params">( AsyncNetworkInterface&amp;&amp; interface )</span></span><br><span class="hljs-function">  </span>&#123;<br>    interfaces_.<span class="hljs-built_in">push_back</span>( std::<span class="hljs-built_in">move</span>( interface ) );<br>    <span class="hljs-keyword">return</span> interfaces_.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Access an interface by index</span><br>  <span class="hljs-function">AsyncNetworkInterface&amp; <span class="hljs-title">interface</span><span class="hljs-params">( <span class="hljs-type">size_t</span> N )</span> </span>&#123; <span class="hljs-keyword">return</span> interfaces_.<span class="hljs-built_in">at</span>( N ); &#125;<br><br>  <span class="hljs-comment">// Add a route (a forwarding rule)</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_route</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> route_prefix,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">uint8_t</span> prefix_length,</span></span><br><span class="hljs-params"><span class="hljs-function">                  std::optional&lt;Address&gt; next_hop,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">size_t</span> interface_num )</span></span>;<br><br>  <span class="hljs-comment">// Route packets between the interfaces. For each interface, use the</span><br>  <span class="hljs-comment">// maybe_receive() method to consume every incoming datagram and</span><br>  <span class="hljs-comment">// send it on one of interfaces to the correct next hop. The router</span><br>  <span class="hljs-comment">// chooses the outbound interface and next-hop as specified by the</span><br>  <span class="hljs-comment">// route with the longest prefix_length that matches the datagram&#x27;s</span><br>  <span class="hljs-comment">// destination address.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">route</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;router.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ipv4_datagram.hh&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// route_prefix: The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span><br><span class="hljs-comment">// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of</span><br><span class="hljs-comment">//    the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span><br><span class="hljs-comment">// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in</span><br><span class="hljs-comment">//    which case, the next hop address should be the datagram&#x27;s final destination).</span><br><span class="hljs-comment">// interface_num: The index of the interface to send the datagram out on.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Router::add_route</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> route_prefix,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> prefix_length,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> optional&lt;Address&gt; next_hop,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> interface_num )</span></span><br><span class="hljs-function"></span>&#123;<br>  cerr &lt;&lt; <span class="hljs-string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="hljs-built_in">from_ipv4_numeric</span>( route_prefix ).<span class="hljs-built_in">ip</span>() &lt;&lt; <span class="hljs-string">&quot;/&quot;</span><br>       &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;( prefix_length ) &lt;&lt; <span class="hljs-string">&quot; =&gt; &quot;</span> &lt;&lt; ( next_hop.<span class="hljs-built_in">has_value</span>() ? next_hop-&gt;<span class="hljs-built_in">ip</span>() : <span class="hljs-string">&quot;(direct)&quot;</span> )<br>       &lt;&lt; <span class="hljs-string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>  routing_table_[&#123;route_prefix, prefix_length&#125;] = &#123;next_hop, interface_num&#125;;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Router::route</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历所有的interface，处理每个interface到达的InternetDatagram，做转发</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;interface : interfaces_) &#123;<br>    <span class="hljs-keyword">for</span> (optional&lt;InternetDatagram&gt; datagram = interface.<span class="hljs-built_in">maybe_receive</span>(); datagram.<span class="hljs-built_in">has_value</span>(); datagram = interface.<span class="hljs-built_in">maybe_receive</span>()) &#123;<br>      <span class="hljs-comment">// 首先检查TTL</span><br>      <span class="hljs-keyword">auto</span> &amp;ttl = datagram-&gt;header.ttl;<br>      <span class="hljs-keyword">if</span> (ttl == <span class="hljs-number">0</span> || ttl == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 丢弃当前的datagram，什么都不做</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-comment">// 将当前datagram的ttl减一</span><br>      -- ttl;<br>      std::optional&lt;std::pair&lt;<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint8_t</span>&gt;&gt; longest_prefix_match;<br>      <span class="hljs-type">uint32_t</span> &amp;dst = datagram-&gt;header.dst;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[route, next_hop_info] : routing_table_) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[route_prefix, prefix_length] =  route;<br>        <span class="hljs-comment">// 根据prefix_length分成三种情况处理</span><br>        <span class="hljs-comment">// 三步：1.检查匹配；2检查当前是否有结果，有的话选长的</span><br>        <span class="hljs-comment">// 另外的实现方式：(route_prefix ^ dgram.header.dst) &gt;&gt; (32 - it-&gt;prefix_length) == 0</span><br>        <span class="hljs-keyword">if</span> (prefix_length == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// prefix_length == 0不可能比其他的匹配更长，只在没有其他任何匹配的时候初始匹配</span><br>          <span class="hljs-comment">// 并且prefix_length == 0的路由表项与任何IP都是匹配的</span><br>          <span class="hljs-keyword">if</span> (!longest_prefix_match.<span class="hljs-built_in">has_value</span>()) &#123; <br>            longest_prefix_match = &#123;route_prefix, prefix_length&#125;;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prefix_length == <span class="hljs-number">32</span>) &#123;<br>          <span class="hljs-comment">// prefix_length == 32的匹配需要完全匹配</span><br>          <span class="hljs-keyword">if</span> (route_prefix == dst) &#123;<br>            <span class="hljs-comment">// prefix_length == 32 就是可能存在的最长匹配，不可能还有更长的了</span><br>            longest_prefix_match = &#123;route_prefix, prefix_length&#125;;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 1 &lt;= prefix_lenght &lt;= 31，可以使用移位操作了</span><br>          <span class="hljs-type">uint32_t</span> mask = <span class="hljs-number">0xFFFFFFFF</span>;<br>          mask &lt;&lt;= <span class="hljs-number">32</span> - prefix_length;<br>          <span class="hljs-keyword">if</span> ((dst &amp; mask) == route_prefix) &#123;<br>            <span class="hljs-comment">// 匹配</span><br>            <span class="hljs-keyword">if</span> (longest_prefix_match.<span class="hljs-built_in">has_value</span>()) &#123;<br>              <span class="hljs-comment">// 当前有值</span><br>              <span class="hljs-keyword">if</span> (prefix_length &gt; longest_prefix_match-&gt;second) &#123;<br>                <span class="hljs-comment">// 当前的匹配更长，替换为当前结果，否则什么都不做</span><br>                longest_prefix_match = &#123;route_prefix, prefix_length&#125;;<br>              &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 当前没有值的情况</span><br>              longest_prefix_match = &#123;route_prefix, prefix_length&#125;;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 完成路由表的匹配之后，根据结果进行打包（IP地址修改）转发</span><br>      <span class="hljs-keyword">if</span> (longest_prefix_match.<span class="hljs-built_in">has_value</span>()) &#123;<br>        <span class="hljs-comment">// 只需要处理有匹配结果的；没有匹配的不用处理，丢弃</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[next_hop, interface_num] = routing_table_[longest_prefix_match.<span class="hljs-built_in">value</span>()];<br>        <span class="hljs-comment">// 将IP数据包转发到对应的端口号</span><br>        AsyncNetworkInterface&amp; transmit_interface =  <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">interface</span>(interface_num);<br>        <span class="hljs-comment">// 发送之前记录重新校验和</span><br>        datagram.<span class="hljs-built_in">value</span>().header.<span class="hljs-built_in">compute_checksum</span>();<br>        transmit_interface.<span class="hljs-built_in">send_datagram</span>(datagram.<span class="hljs-built_in">value</span>(), next_hop.<span class="hljs-built_in">value_or</span>(Address::<span class="hljs-built_in">from_ipv4_numeric</span>(dst)));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<h2 id="Lab-6-Putting-it-all-together"><a href="#Lab-6-Putting-it-all-together" class="headerlink" title="Lab 6 Putting it all together"></a>Lab 6 Putting it all together</h2><p>不需要coding，使用之前的labs来create a real network that includes your networkstatck (host and router) talking to the network stack implemented by another student in the class。</p>
<p><img src="image-20230601113538216.png" srcset="/img/loading.gif" lazyload alt="image-20230601113538216"></p>
<p>通过一个relay server <code>cs144.keithw.org</code>建立网络连接</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>本次实验主要是利用之前实验搭建的模块，构成一套端到端的app，可以通信，之前的实验正常通过应该没有问题，有几个需要注意的地方：</p>
<ul>
<li><p>启动的时候需要注意<code>server</code>端口是even number才行，<code>client</code>端口是对应的<code>server</code>端口号加一。</p>
</li>
<li><p>其他基本按照实验手册不会有什么问题。</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Stanford CS144: Computer Network Notes</div>
      <div>http://example.com/2023/06/02/Stanford-CS144-Computer-Network-Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>V. Louis</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 2, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/09/UCB-CS-61B-Notes/" title="UCB CS 61B Notes">
                        <span class="hidden-mobile">UCB CS 61B Notes</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
