

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="The C++ Programming Language  Part Ⅰ: Introductory MaterialChapter 2. A Tour of C++: The Basics Introduction The Basics Hello, World! Types, Variables, and Arithmetic Constants Tests and Loops Pointer">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Programming Language Notes">
<meta property="og:url" content="http://example.com/2023/01/13/C-Programming-Language-Notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="The C++ Programming Language  Part Ⅰ: Introductory MaterialChapter 2. A Tour of C++: The Basics Introduction The Basics Hello, World! Types, Variables, and Arithmetic Constants Tests and Loops Pointer">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/obsidian/Louis/计算机专业知识/C++.assets/image-20230129151158655-1674976322141-1.png">
<meta property="og:image" content="d:/obsidian/Louis/计算机专业知识/C++.assets/image-20230129151354561.png">
<meta property="og:image" content="d:/obsidian/Louis/计算机专业知识/C++.assets/image-20230117171611635.png">
<meta property="og:image" content="d:/obsidian/Louis/计算机专业知识/C++.assets/image-20230117175706348.png">
<meta property="og:image" content="d:/obsidian/Louis/计算机专业知识/C++.assets/image-20230117195603731.png">
<meta property="og:image" content="d:/obsidian/Louis/计算机专业知识/C++.assets/image-20230129145841357.png">
<meta property="article:published_time" content="2023-01-13T13:27:05.000Z">
<meta property="article:modified_time" content="2023-01-29T07:21:03.548Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="d:/obsidian/Louis/计算机专业知识/C++.assets/image-20230129151158655-1674976322141-1.png">
  
  
  
  <title>C++ Programming Language Notes - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Villian Louis&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ Programming Language Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-13 21:27" pubdate>
          January 13, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          119k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          991 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++ Programming Language Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="The-C-Programming-Language-Part-Ⅰ-Introductory-Material"><a href="#The-C-Programming-Language-Part-Ⅰ-Introductory-Material" class="headerlink" title="The C++ Programming Language  Part Ⅰ: Introductory Material"></a><em>The C++ Programming Language</em>  Part Ⅰ: Introductory Material</h1><h2 id="Chapter-2-A-Tour-of-C-The-Basics"><a href="#Chapter-2-A-Tour-of-C-The-Basics" class="headerlink" title="Chapter 2. A Tour of C++: The Basics"></a>Chapter 2. A Tour of C++: The Basics</h2><ul>
<li>Introduction</li>
<li>The Basics<ul>
<li>Hello, World!</li>
<li>Types, Variables, and Arithmetic</li>
<li>Constants</li>
<li>Tests and Loops</li>
<li>Pointers, Arrays, and Loops</li>
</ul>
</li>
<li>User-Defined Types<ul>
<li>Structures</li>
<li>Classes</li>
<li>Enumerations</li>
</ul>
</li>
<li>Modularity<ul>
<li>Separate Compilation</li>
<li>Namespaces</li>
<li>Error Handling</li>
</ul>
</li>
<li>Postcript</li>
<li>Advice</li>
</ul>
<h3 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h3><ul>
<li><p>2，3，4，5章主要是”give you an idea of what C++ is”</p>
<ul>
<li>Chapter 2给出<ul>
<li>notion of C++</li>
<li>C++‘s model of memory</li>
<li>computation</li>
<li>the basic mechanism for organizing code into program</li>
</ul>
</li>
<li>Chapter 3介绍C++’s Abstraction mechanism</li>
<li>Chapter 4 和 Chapter 5 给出一些Standard-library facilities的例子</li>
</ul>
</li>
<li><p>严格的自底向上的方式介绍C++</p>
</li>
<li><p>This tour present C++ as an integrated whole.</p>
</li>
</ul>
<h3 id="2-2-The-Basics"><a href="#2-2-The-Basics" class="headerlink" title="2.2 The Basics"></a>2.2 The Basics</h3><ol>
<li><p>C++ is a compiled language.</p>
<ul>
<li>Source text必须由 compiler处理，产生object files。然后object files 被linker combined，产生executable program</li>
<li><img src="D:\obsidian\Louis\计算机专业知识\C++.assets\image-20230129151158655-1674976322141-1.png" srcset="/img/loading.gif" lazyload alt="image-20230129151158655"></li>
</ul>
</li>
<li><p>An executable program is created for a specific hardware/system combination; it is not portable.</p>
<ul>
<li>When talk about portability of C++ programs, we usually mean portability of source code; that is the source code can be successfully compiled and run on a varity of systems.</li>
</ul>
</li>
<li><p>ISO C++ Standard defines two kinds of entities:</p>
<ul>
<li>Core language features.<ul>
<li>Such as built-in types (e.g. char and int) and loops (e.g. for-statements and while-statements)</li>
</ul>
</li>
<li>Standard-library components.<ul>
<li>Such as containers (e.g. vector and map) and I/O operations (e.g. &lt;&lt; and getline())</li>
<li>The standard-library components are perfectly ordinary C++ code provided by every C++ implementation. This implies that C++ is sufficiently expressive and efficient for the most demanding systems programming tasks.</li>
</ul>
</li>
</ul>
</li>
<li><p>C++ is a statically typed language.</p>
<ul>
<li>That is, the type of every entity (e.g., object, value, name, and expression) must be known to the compiler at its point of use.</li>
<li>The type of an object determines the set of operations applicable to it.</li>
</ul>
</li>
</ol>
<h4 id="2-2-1-Hello-World"><a href="#2-2-1-Hello-World" class="headerlink" title="2.2.1 Hello, World!"></a>2.2.1 Hello, World!</h4><ol start="5">
<li>The minimal C++ program is<ul>
<li>定义main函数</li>
<li>没有任何参数</li>
<li>什么都不做</li>
<li>Curly braces, {}, expressing grouping in C++.</li>
<li>// 单行注释</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// the minimal C++ program</span><br></code></pre></td></tr></table></figure>

<ol start="6">
<li><p>Every C++ program must have exactly one global function named main().</p>
<ul>
<li>The program starts by executing that function.</li>
<li>The int value returned by main(), if any, is the program’s return value to “the system.”<ul>
<li>If no value is return, the system will receive a value indicating successful compilation.</li>
<li>A nonzero value from main() indicates failure.</li>
<li>Not every operating system and execution envirnment make use of that return value:<ul>
<li>Linux/Unix-based environments often do</li>
<li>But Windows-based environments rarely do.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Typically, a program produces some output.</p>
<ul>
<li>The line <code>#include &lt;iostream&gt;</code>  instructs the compiler to include the declarations of standard stream I/O facilities as found in iostream.</li>
<li>The operaor <code>&lt;&lt;</code> (“put to”) writes its second argument on its first.<ul>
<li>The string literal “Hello, World!\n” is written onto the standard output stream <code>std::cout</code>.</li>
<li>A string literal is a sequence of characters surrounded by double quotes.<ul>
<li>In a string literal, the backslash character <code>\</code> followed by another character denotes a single ‘‘special character.’’</li>
<li>In this case, <code>\n</code> is the newline character, so that the characters written are Hello, World! followed by a newline.</li>
</ul>
</li>
</ul>
</li>
<li>The <code>std::</code> specifies that the name <code>cout</code> is to be found in the standard-library namespace.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="8">
<li>Essentially all executable code is placed in functions and called directly or indirectly from <code>main()</code>.<ul>
<li>A “return type” <code>void</code> indicates that a function does not return a value.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">// make names from std visible without std::</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> x*x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;The square of &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">square</span>(x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">print_square</span>(<span class="hljs-number">1.234</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-2-Types-Variables-and-Arithmetic"><a href="#2-2-2-Types-Variables-and-Arithmetic" class="headerlink" title="2.2.2 Types, Variables, and Arithmetic"></a>2.2.2 Types, Variables, and Arithmetic</h4><ol start="9">
<li>Every name and every expression has a type that determines the operations that may be performed on it.<ul>
<li>A declaration is a statement that introduces a name into the program. It specifies a type for the named entity.<ul>
<li>A <em>type</em> defines a set of possible values and set of operations (for an object).</li>
<li>An <em>object</em> is some memory that holds a value of some type.</li>
<li>A <em>value</em> is a set of bits interpreted according to a type.</li>
<li>A <em>variable</em> is a named object.</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> inch <span class="hljs-comment">// the declaration specifies that inch is of the type int</span><br></code></pre></td></tr></table></figure>

<ol start="10">
<li><p>C++ offers a variety of fundamental types.</p>
<ul>
<li><code>bool</code>: true or false</li>
<li><code>char</code>: character</li>
<li><code>int</code>: integer</li>
<li><code>double</code>: double-precision floating-point number</li>
</ul>
</li>
<li><p>Each fundamental type corresponds directly to hardware facilities and has a fixed size that determines the range of values that can be stored in it.</p>
<ul>
<li><img src="D:\obsidian\Louis\计算机专业知识\C++.assets\image-20230129151354561.png" srcset="/img/loading.gif" lazyload alt="image-20230129151354561"></li>
<li>A <code>char</code> variable is of the natural size to hold a character on a given machine (typically an 8-bit byte).</li>
<li>The sizes of other types are quoted in multiples of the size of a char.</li>
<li>The size of a type is implementation-defined and can be obtained by the <code>sizeof</code> operator.</li>
</ul>
</li>
<li><p>The arithmetic operator can be used for appropriate combination of these types.</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">x+y <span class="hljs-comment">// plus</span><br>+x <span class="hljs-comment">// unary plus</span><br>x-y <span class="hljs-comment">//minus</span><br>-x <span class="hljs-comment">//unary minus</span><br>x*y <span class="hljs-comment">//multiply</span><br>x/y <span class="hljs-comment">//divide</span><br>x%y <span class="hljs-comment">// remainder (modulus) for integers</span><br></code></pre></td></tr></table></figure>

<p>So can the comparision operators.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">x==y <span class="hljs-comment">// equal</span><br>x!=y <span class="hljs-comment">// not equal</span><br>x&lt;y <span class="hljs-comment">// less than</span><br>x&gt;y <span class="hljs-comment">// greater than</span><br>x&lt;=y <span class="hljs-comment">// less than or equal</span><br>x&gt;=y <span class="hljs-comment">// greater than or equal</span><br></code></pre></td></tr></table></figure>

<ol start="13">
<li>In assignments and in arithmetic operations, C++ performs all meaningful conversions between the basic types so that they can be mixed freely.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">()</span> <span class="hljs-comment">// function that does not return a value</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">double</span> d = <span class="hljs-number">2.2</span>; <span class="hljs-comment">// initializa floating-point number</span><br>	<span class="hljs-type">int</span> i = <span class="hljs-number">7</span>; <span class="hljs-comment">// initialize integer</span><br>	d = d+i; <span class="hljs-comment">// assign sum of d+i to d</span><br>	i = d*i; <span class="hljs-comment">// assing product to i (truncating the double d*i to an int)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Note that <code>=</code> is the assignment operator and <code>==</code> test equality.</p>
<ol start="14">
<li>C++ offers a variety of notations for expressing initialization.<ul>
<li>the <code>=</code> used above</li>
<li>a universal form based on <code>curly-brace-delimited initializer lists</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">double</span> d1 = <span class="hljs-number">2.3</span>;<br><span class="hljs-type">double</span> d2&#123;<span class="hljs-number">2.3</span>&#125;;<br><br>complex&lt;<span class="hljs-type">double</span>&gt; z = <span class="hljs-number">1</span>; <span class="hljs-comment">// a complex number with double-precision floating-point scalars</span><br>complex&lt;<span class="hljs-type">double</span>&gt; z2&#123;d1,d2&#125;<br>complex&lt;<span class="hljs-type">double</span>&gt; z3 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// the = is optional with &#123;...&#125;</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// a vector of ints</span><br></code></pre></td></tr></table></figure>

<p>The <code>=</code> form is traditional and dates back to C, but if in doubt, use the general {}-list form. If nothing else, it saves you from conversions that lose information (narrowing conversion).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i1 = <span class="hljs-number">7.2</span>; <span class="hljs-comment">// i1 becomes 7</span><br><span class="hljs-type">int</span> i2&#123;<span class="hljs-number">7.2</span>&#125;; <span class="hljs-comment">// error: floating-point to integer conversion (narrowing conversion)</span><br><span class="hljs-type">int</span> i3 = &#123;<span class="hljs-number">7.2</span>&#125;; <span class="hljs-comment">// error: floating-point to integer conversion (the = is redundant)</span><br></code></pre></td></tr></table></figure>

<ol start="15">
<li>A constant cannot be left uninitialized and a variable should only be left uninitialized in extremely rare circumstances.<ul>
<li>Don’t introduce a name untial you have a suitable value for it.</li>
<li>User-defined types (such as string, vector, Matrix, Motor_controller, and Orc_warrior) can be definec to be implicitly initialized.</li>
</ul>
</li>
<li>When defining a variable, you don;t actually need to state its type explicitly when it can be deduced from the initializer.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> b = <span class="hljs-literal">true</span>; <span class="hljs-comment">// a bool</span><br><span class="hljs-keyword">auto</span> ch = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">// a char</span><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">123</span>; <span class="hljs-comment">// an int</span><br><span class="hljs-keyword">auto</span> d = <span class="hljs-number">1.2</span>; <span class="hljs-comment">// a double</span><br><span class="hljs-keyword">auto</span> z = <span class="hljs-built_in">sqrt</span>(y); <span class="hljs-comment">// z has the type of whatever sqrt(y) returns</span><br></code></pre></td></tr></table></figure>

<p>With <code>auto</code>, we use the <code>=</code> syntax because there is no type conversion involved that might cause problems.</p>
<ol start="17">
<li>We use <code>auto</code> where we don’t have a specific reason to mention the type explicitly. “Specific reasons” include:<ul>
<li>The definition is in a large scope where we want to make the type clearly visible to readers of our code.</li>
<li>We want to be explicit about a variable’s range or precision (e.g., double rather than float).</li>
</ul>
</li>
</ol>
<p>Using auto, we avoid redundancy and writing long type names.</p>
<ol start="18">
<li>In addition to the conventional arithmetic and logical operators, C++ offers more specific operations for modifying a variable.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">x+=y; <span class="hljs-comment">// x = x+y</span><br>++x; <span class="hljs-comment">// increment: x = x+1</span><br>x-=y; <span class="hljs-comment">// x = x-y</span><br>--x; <span class="hljs-comment">// decrement: x = x-1</span><br>x*=y; <span class="hljs-comment">// scaling: x = x*y</span><br>x/=y; <span class="hljs-comment">// scaling: x = x/y</span><br>x%=y; <span class="hljs-comment">// x = x%y</span><br></code></pre></td></tr></table></figure>

<p>Thes operators are concise, convenient, and very frequently used.</p>
<h4 id="2-2-3-Constants"><a href="#2-2-3-Constants" class="headerlink" title="2.2.3 Constants"></a>2.2.3 Constants</h4><ol start="19">
<li>C++ supports two notions of immutability.<ul>
<li><code>const</code>: meaning roughly “I promise not to change this value”.<ul>
<li>This is used primarily to specify interfaces, so that data can be passed to functions without fear of it being modified.</li>
<li>The compiler enforces the promise made by <code>const</code>.</li>
</ul>
</li>
<li><code>constexpr</code>: meaning roughly “to be evaluated at compile time”.<ul>
<li>This is used primarily to specify constants, to allow placement of data in memory where it is unlikely to be corrupted, and for performance.</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> dmv = <span class="hljs-number">17</span>; <span class="hljs-comment">// dmv is named constant</span><br><span class="hljs-type">int</span> var = <span class="hljs-number">17</span>; <span class="hljs-comment">// var is a variable, not a constant</span><br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> max1 = <span class="hljs-number">1.4</span>*<span class="hljs-built_in">square</span>(dmv); <span class="hljs-comment">// OK if square(17) is a constant expression</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> max2 = <span class="hljs-number">1.4</span>*<span class="hljs-built_in">square</span>(var); <span class="hljs-comment">// Error: var is not a constant expression(Cannot be know when compiling.)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> max3 = <span class="hljs-number">1.4</span>*<span class="hljs-built_in">square</span>(var); <span class="hljs-comment">// Ok: may be evaluated at run time</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">double</span>&gt;&amp;)</span></span>; <span class="hljs-comment">// Function sum() will bot modify its argument</span><br><br>vector&lt;<span class="hljs-type">double</span>&gt; v&#123;<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">4.5</span>&#125;; <span class="hljs-comment">// v is not a constant</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> s1 = <span class="hljs-built_in">sum</span>(v); <span class="hljs-comment">// Ok: evaluted at run time</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> s2 = <span class="hljs-built_in">sum</span>(v); <span class="hljs-comment">// Error: sum(v) not constant expression</span><br></code></pre></td></tr></table></figure>

<ul>
<li><img src="D:\obsidian\Louis\计算机专业知识\C++.assets\image-20230117171611635.png" srcset="/img/loading.gif" lazyload alt="image-20230117171611635"></li>
</ul>
<ol start="20">
<li>For a function to be usable in a <code>constant expression</code>, that is, in an expression that will be evaluated by the compiler, it must be defined <code>constexpr</code>.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x*x;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>To be <code>constexpr</code>, a function must be rather simple: just a return-statement computing a value.</li>
<li>A <code>constexpr</code> function can be used for non-constant arguments, but when that is done the result is not a constant expression.<ul>
<li>We allow a <code>constexpr</code> function to be called with non-constant-expression arguments in the contexts that do not require constant expression, so that we don’t have to define essentially the same function twice: once for constant expression and once for variables.</li>
</ul>
</li>
</ul>
<ol start="21">
<li>In a few places, constant expressions are required by language rules(e.g., array bounds, case labels, some template arguments, and constants declared using <code>constexpr</code>). In other cases, compile-time evaluation is important for performance.</li>
</ol>
<ul>
<li>Independently of performance issues, the notion of immutability (of an object with an unchangable state) is an important design concern.</li>
</ul>
<h4 id="2-2-4-Tests-and-Loops"><a href="#2-2-4-Tests-and-Loops" class="headerlink" title="2.2.4 Tests and Loops"></a>2.2.4 Tests and Loops</h4><ol start="22">
<li>C++ provides a conventional set of statements for expressing selection and looping.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept</span><span class="hljs-params">()</span> <span class="hljs-comment">// a simple function that prompts the user and returns a Boolean indicating the response</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Do you want to proceed (y or n)?\n&quot;</span>;<br>  <br>    <span class="hljs-type">char</span> answer = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; answer;<br>  <br>    <span class="hljs-keyword">if</span>(answer==<span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>&gt;&gt;</code> operator (“get from”) is used for input; <code>cin</code> is the standard input stream.<ul>
<li>The type of the right-hand operand of <code>&gt;&gt;</code> determines what input is accepted, and its right-hand operand is the target of the input operation.</li>
</ul>
</li>
</ul>
<ol start="23">
<li>A <code>switch</code>-statement tests a value against a set of constants.<ul>
<li>The case constants must be distinct.</li>
<li>If the value tested does not match any of them, the <code>default</code> is chosen. If no <code>default</code> is provided, no action is taken if the value doesn’t match any case constant.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept2</span><span class="hljs-params">()</span> <span class="hljs-comment">// a simple function that prompts the user and returns a Boolean indicating the response</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Do you want to proceed (y or n)?\n&quot;</span>;<br>  <br>    <span class="hljs-type">char</span> answer = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; answer;<br>  <br>    <span class="hljs-keyword">switch</span>(answer)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;y&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      	<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>n<span class="hljs-number">&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;ll take that for a no.\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="24">
<li>Few programs are written without loops.<ul>
<li>The <code>while</code>-statement executes until its condition becomes <code>false</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept3</span><span class="hljs-params">()</span> <span class="hljs-comment">// a simple function that prompts the user and returns a Boolean indicating the response</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tries = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(tries&lt;<span class="hljs-number">4</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Do you want to proceed (y or n)?\n&quot;</span>;<br><br>        <span class="hljs-type">char</span> answer = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; answer;<br><br>        <span class="hljs-keyword">switch</span>(answer)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;y&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>n<span class="hljs-number">&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">default</span>:<br>                cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;ll take that for a no.\n&quot;</span>;<br>                ++tries;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;ll take that for a no.\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-5-Pointers-Arrays-and-Loops"><a href="#2-2-5-Pointers-Arrays-and-Loops" class="headerlink" title="2.2.5 Pointers, Arrays, and Loops"></a>2.2.5 Pointers, Arrays, and Loops</h4><ol start="25">
<li>An array of elements of type <code>char</code> can be declared like this:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> v[<span class="hljs-number">6</span>]; <span class="hljs-comment">// array of 6 characters</span><br></code></pre></td></tr></table></figure>

<p>Sillarly, a pointer can be declared like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> *p; <span class="hljs-comment">// pointer to character</span><br></code></pre></td></tr></table></figure>

<ul>
<li>In declarations, <code>[]</code> means “array of” and <code>*</code> means “pointer to.”</li>
<li>All arrays have <code>0</code> as their lower bound. The size of an array must be a constant expression.</li>
<li>A pointer variable can hold the address of an object of the appropriate type:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> *p = &amp;v[<span class="hljs-number">3</span>]; <span class="hljs-comment">// p points to v&#x27;s fourth element</span><br><span class="hljs-type">char</span> x = *p; <span class="hljs-comment">// *p is the object that p points to</span><br></code></pre></td></tr></table></figure>

<ul>
<li>In an expression, prefix unary <code>*</code> means “contents of “ and prefix unary <code>&amp;</code> means “address of.”<ul>
<li>We can represent the result of that initialized definition graphically.</li>
<li><img src="D:\obsidian\Louis\计算机专业知识\C++.assets\image-20230117175706348.png" srcset="/img/loading.gif" lazyload alt="image-20230117175706348"></li>
</ul>
</li>
</ul>
<ol start="26">
<li>The <code>for</code>-statement can be read as “set <code>i</code> to zero; while <code>i</code> is not <code>10</code>, copy the <code>i</code>th element and increment <code>i</code>.”</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_fct</span><span class="hljs-params">()</span> <span class="hljs-comment">// copying ten elements from one array to another</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> v1[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> v2[<span class="hljs-number">10</span>]; <span class="hljs-comment">// to become a copy of v1</span><br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i=<span class="hljs-number">0</span>; i!=<span class="hljs-number">10</span>; ++i) <span class="hljs-comment">// copy elemets</span><br>        v2[i]=v1[i];<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>++</code> operator simply adds <code>1</code>.</li>
</ul>
<ol start="27">
<li>C++ also offers a simplier <code>for</code>-statement, called a range-<code>for</code>-statement, for loops that traverse a sequence in the simplest way.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : v) <span class="hljs-comment">// for each x in v</span><br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : &#123;<span class="hljs-number">10</span>,<span class="hljs-number">21</span>,<span class="hljs-number">32</span>,<span class="hljs-number">43</span>,<span class="hljs-number">54</span>,<span class="hljs-number">65</span>&#125;)<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The first range-<code>for</code>-statement can be read as “for every element of v, from the first to the last, place a copy in <code>x</code> and print it.”</li>
<li>Note that we don’t have to specify an array bound when we initialize it with a list.</li>
<li>The range-<code>for</code>-statement can be used for any sequence of elements.</li>
</ul>
<p>If we didn’t want to copy the values from <code>v</code> into the variable <code>x</code>, but rather just have <code>x</code> refer to an element, we could write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> v[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x : v)<br>        ++x;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>In a declaration, the unary suffix <code>&amp;</code> means “reference to.”<ul>
<li>A reference is similar to a pointer, execpt that you don’t need to use a prefix <code>*</code> to access the value referred to by the reference.</li>
<li>A referenc cannot be made to refer to a different object after its initialization.</li>
</ul>
</li>
</ul>
<h2 id="Chapter-3-A-Tour-of-C-Abstraction-mechanisms"><a href="#Chapter-3-A-Tour-of-C-Abstraction-mechanisms" class="headerlink" title="Chapter 3. A Tour of C++: Abstraction mechanisms"></a>Chapter 3. A Tour of C++: Abstraction mechanisms</h2><h3 id="3-2-Classes"><a href="#3-2-Classes" class="headerlink" title="3.2 Classes"></a>3.2 Classes</h3><h4 id="3-2-3-Virtual-Functions"><a href="#3-2-3-Virtual-Functions" class="headerlink" title="3.2.3 Virtual Functions"></a>3.2.3 Virtual Functions</h4><ol>
<li><p>A <code>Container</code> object must contain information to allow it select the right function to call at run time.</p>
<p>The usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions.</p>
<ul>
<li>That table is usually called the <em><strong>virtual function table</strong></em> or simply the <code>vtbl</code>.</li>
<li>Each class with virtual functions has its own <code>vtble</code> identifying its virtual functions.</li>
</ul>
</li>
</ol>
<ol start="2">
<li>The space overhead is one pointer in each object of a class with virtual functions plus one <code>vtbl</code> for each such class.</li>
</ol>
<h3 id="3-4-Templates"><a href="#3-4-Templates" class="headerlink" title="3.4 Templates"></a>3.4 Templates</h3><h4 id="3-4-4-Variadic-Templates"><a href="#3-4-4-Variadic-Templates" class="headerlink" title="3.4.4 Variadic Templates"></a>3.4.4 Variadic Templates</h4><ol>
<li><p>A template can be defined to accept an arbitrary number of arguments of arbitrary types.</p>
<p>Such a template is called a <em><strong>variadic template</strong></em>. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Tail&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T head, Tail... tail)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">g</span>(head); <span class="hljs-comment">// do something to head</span><br>    <span class="hljs-built_in">f</span>(tail...); <span class="hljs-comment">// try again with tail</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">// do nothing</span><br></code></pre></td></tr></table></figure>

<p>The key to implementing a variadic template is to note that when you pass a list of arguments to it, you can separate the first argument from the rest.</p>
<ul>
<li>Here, we do something to the first argument (the <code>head</code>) and then recursively call <code>f()</code> with the rest of the arguments (the <code>tail</code>).</li>
<li>The <strong>elipsis</strong>, <code>...</code>, is used to indicate “the rest” of a list.</li>
<li>Eventually, of course, <code>tail</code> will become empty and we need a separate function to deal with that.</li>
</ul>
</li>
<li><p>We can call this <code>f()</code> like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;first:&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\nsecond:&quot;</span>;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">0.2</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&quot;yuck!&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="Chapter-4-A-Tour-of-C-Containers-and-Algorithms"><a href="#Chapter-4-A-Tour-of-C-Containers-and-Algorithms" class="headerlink" title="Chapter 4. A Tour of C++: Containers and Algorithms"></a>Chapter 4. A Tour of C++: Containers and Algorithms</h2><h2 id="Chapter-5-A-Tour-of-C-Concurrency-and-Utilities"><a href="#Chapter-5-A-Tour-of-C-Concurrency-and-Utilities" class="headerlink" title="Chapter 5. A Tour of C++: Concurrency and Utilities"></a>Chapter 5. A Tour of C++: Concurrency and Utilities</h2><h3 id="5-3-Concurrency"><a href="#5-3-Concurrency" class="headerlink" title="5.3 Concurrency"></a>5.3 Concurrency</h3><h4 id="5-3-1-Tasks-and-threads"><a href="#5-3-1-Tasks-and-threads" class="headerlink" title="5.3.1 Tasks and threads"></a>5.3.1 Tasks and <code>thread</code>s</h4><h1 id="The-C-Programming-Language-Part-Ⅱ-Basic-Facilities"><a href="#The-C-Programming-Language-Part-Ⅱ-Basic-Facilities" class="headerlink" title="The C++ Programming Language  Part Ⅱ : Basic Facilities"></a>The C++ Programming Language  Part Ⅱ : Basic Facilities</h1><h2 id="Chapter-6-Types-and-Declarations"><a href="#Chapter-6-Types-and-Declarations" class="headerlink" title="Chapter 6. Types and Declarations"></a>Chapter 6. Types and Declarations</h2><ol>
<li><p>The standard header <code>&lt;cstddef&gt;</code> defines an alias that is very widely used in both standard-library declarations and user code:</p>
<ul>
<li><code>size_t</code> is an implementation-defined unsigned integer type that can hold the size in bytes of every object.</li>
</ul>
<p>Consequetly, it is used where we need to hold an object size. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, n)</span></span>; <span class="hljs-comment">// get n bytes</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-4-Objects-and-Values"><a href="#6-4-Objects-and-Values" class="headerlink" title="6.4 Objects and Values"></a>6.4 Objects and Values</h3><h4 id="6-4-2-Lifetimes-of-Objects"><a href="#6-4-2-Lifetimes-of-Objects" class="headerlink" title="6.4.2 Lifetimes of Objects"></a>6.4.2 Lifetimes of Objects</h4><ol>
<li><p>The <em><strong>lifetime</strong></em> of an object starts when its constructor completes and ends when its destructor starts executing.</p>
<ul>
<li>Objects of type without a declared constructor, such as an <code>int</code>, can be considered to have default constructors and destructors that do nothing.</li>
</ul>
</li>
<li><p>We can classify objects based on their lifetimes:</p>
<ul>
<li><em><strong>Automatic</strong></em><ul>
<li>Unless the programmer specifies otherwise (section 12.1.8, section 16.2.12), an object declared in a function is created when its definition is encountered and destroyed when its name goes out of scope.</li>
<li>Such objects are sometimes called <em><strong>automatic</strong></em> objects.</li>
<li>In typical implementation, automatic objects are allocated on the stack; each call of the function gets its own <em><strong>stack frame</strong></em> to hold its automatic objects.</li>
</ul>
</li>
<li><em><strong>Static</strong></em>:<ul>
<li>Objects declared in global or namespace scope (section 6.3.4) and <code>static</code>s declared in functions (section 12.1.8) or classes(section 16.2.12) are created and initialized once (only) and “live” until the program terminates (section 15.4.3).</li>
<li>Such objects are called <em><strong>static</strong></em> objects.</li>
<li>A static object has the same address throughout the life of a program execution.</li>
<li>Static objects can cause serious problems in a multi-threaded program because they are shared among all threads and typically require locking to avoid data races (section 5.3.1, section 42.3).</li>
</ul>
</li>
<li><em><strong>Free store</strong></em>:<ul>
<li>Using the <code>new</code> and <code>delete</code> operators, we can create objects whose lifetimes are controlled directly (section 11.2).</li>
</ul>
</li>
<li><em><strong>Temporary objects</strong></em>:<ul>
<li>E.g., intermediate results in a computation or an object used to hold a value for a reference to <code>const</code> argument.</li>
<li>Their lifetime is determined by their use.</li>
<li>If they are bound to a reference, their lifetime is that of the reference; otherwise, they “live” until the end of the full expression of which they are part.<ul>
<li>A <em><strong>full expression</strong></em> is an expression that is not part of another expression.</li>
<li>Typically, temporary objects are automatic.</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>Thread-local objects</strong></em>:<ul>
<li>that is, objects declared <code>thread_local</code> (section 42.2.8)</li>
<li>Such objects are created when their thread is and destroy when their thread is.</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>Static</strong></em> and <em><strong>automatic</strong></em> are traditionally referred to as <em><strong>storage classes</strong></em>.</p>
</li>
<li><p>Array elements and nonstatic class members have their lifetimes determined by the object of which they are part.</p>
</li>
</ol>
<h2 id="Chapter-7-Pointers-Arrays-and-References"><a href="#Chapter-7-Pointers-Arrays-and-References" class="headerlink" title="Chapter 7. Pointers, Arrays, and References"></a>Chapter 7. Pointers, Arrays, and References</h2><h3 id="7-3-Arrays"><a href="#7-3-Arrays" class="headerlink" title="7.3 Arrays"></a>7.3 Arrays</h3><h4 id="7-3-2-String-Literals"><a href="#7-3-2-String-Literals" class="headerlink" title="7.3.2 String Literals"></a>7.3.2 String Literals</h4><ol>
<li><p>A <em><strong>string literal</strong></em> is a character sequence enclosed within double quotes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;this is a string&quot;</span><br></code></pre></td></tr></table></figure>

<p>A string literal contains one more character than it appears to have; it is terminated by the <strong>null character</strong>, <code>&#39;\0&#39;</code>, with the value <code>0</code>. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sizeof</span>(<span class="hljs-string">&quot;Bohr&quot;</span>)==<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>The type of a string literal is “array of the appropriate number of <code>const</code> characters,” so <code>&quot;Bohr&quot;</code> is of type <code>const char[5]</code>.</p>
</li>
</ol>
<h3 id="7-7-References"><a href="#7-7-References" class="headerlink" title="7.7 References"></a>7.7 References</h3><ol>
<li><p>To reflect the lvalue/rvalue and <code>const</code>/non-<code>const</code> distinctions, there are three kinds of references:</p>
<ul>
<li><em><strong>lvalue references</strong></em>: <ul>
<li>to refer to objects whose value we want to change</li>
</ul>
</li>
<li><code>const</code> <em><strong>references</strong></em>:<ul>
<li>to refer to objects whose value we do not want to change (e.g., a constant)</li>
</ul>
</li>
<li><em><strong>rvalue references</strong></em>: <ul>
<li>to refer to objects whose value we do not need to preserve after we have used it (e.g., a temporary)</li>
</ul>
</li>
</ul>
<p>Collectively, they are called <em><strong>references</strong></em>. The first two are both called <em><strong>lvalue references</strong></em>.</p>
</li>
</ol>
<h4 id="7-7-1-Lvalue-References"><a href="#7-7-1-Lvalue-References" class="headerlink" title="7.7.1 Lvalue References"></a>7.7.1 Lvalue References</h4><ol>
<li><p>Initialization of a reference is trivial when the initializer is an lvalue (an object whose address you can take; section 6.4).</p>
<ul>
<li>The initializer for “plain” <code>T&amp;</code> must be a lvalue of type <code>T</code>.</li>
</ul>
<p>The initializer for a <code>const T&amp;</code> need not be an lvalue or evenof type <code>T</code>. In such cases:</p>
<ul>
<li>First, implicit type conversion to <code>T</code> is applied if necessary (section 10.5).</li>
<li>Then, the resulting value is placed in a temporary variable of type <code>T</code>.</li>
<li>Finally, this temporary variable is used as the value of the initializer.</li>
</ul>
</li>
</ol>
<h4 id="7-7-2-Rvalue-References"><a href="#7-7-2-Rvalue-References" class="headerlink" title="7.7.2 Rvalue References"></a>7.7.2 Rvalue References</h4><h4 id="7-7-3-References-to-References"><a href="#7-7-3-References-to-References" class="headerlink" title="7.7.3 References to References"></a>7.7.3 References to References</h4><h4 id="7-7-4-Pointers-and-References"><a href="#7-7-4-Pointers-and-References" class="headerlink" title="7.7.4 Pointers and References"></a>7.7.4 Pointers and References</h4><h2 id="Chapter-8-Structures-Unions-and-Enumerations"><a href="#Chapter-8-Structures-Unions-and-Enumerations" class="headerlink" title="Chapter 8. Structures, Unions, and Enumerations"></a>Chapter 8. Structures, Unions, and Enumerations</h2><h3 id="8-3-Unions"><a href="#8-3-Unions" class="headerlink" title="8.3 Unions"></a>8.3 Unions</h3><ol>
<li>A <code>union</code> is a <code>struct</code> in which all members are allocated at the same address so that <code>union</code> occupies only as much space as its largest member.<ul>
<li>Naturally, a <code>union</code> can hold a value for only one member at a time.</li>
</ul>
</li>
</ol>
<h4 id="8-3-2-Anonymous-unions"><a href="#8-3-2-Anonymous-unions" class="headerlink" title="8.3.2 Anonymous unions"></a>8.3.2 Anonymous <code>union</code>s</h4><ol>
<li>A anonymous <code>union</code> is an object, not a type, and its members can be accessed without mentioning an object name.<ul>
<li>That means that we can use members of an anonymous <code>union</code> exactly as we use other member of a class – as long as we remember that <code>union</code> members really can be used only one at a time.</li>
</ul>
</li>
</ol>
<h3 id="8-4-Enumerations"><a href="#8-4-Enumerations" class="headerlink" title="8.4 Enumerations"></a>8.4 Enumerations</h3><ol>
<li><p>An <em>enumeration</em> is a type that can hold a set of integer values specified by the user. Some of an enumeration’s possible values are named and called enumerators.</p>
<ul>
<li><p>For example</p>
<ul>
<li><p>```C++<br>enum class Color{red, green, blue};</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp">     - This defines an enumberation called `Color` <span class="hljs-keyword">with</span> enumerators `red`, `green`, <span class="hljs-keyword">and</span> `blue`.<br>   - <span class="hljs-string">&quot;An enumeration&quot;</span> <span class="hljs-keyword">is</span> colloquially shortented <span class="hljs-string">&quot;an `enum`.&quot;</span><br><span class="hljs-number">2.</span> There are two kinds of enumerations:<br><br>   - <span class="hljs-built_in">enum</span> classes, <span class="hljs-keyword">for</span> which the enumerator<br><br><span class="hljs-meta">## Chapter 9. Statements</span><br><br><span class="hljs-meta">### 9.5 Iteration Statements</span><br><br><span class="hljs-meta">#### 9.5.1 Range-`for` Statements</span><br><br><span class="hljs-number">1.</span> The simplest loop <span class="hljs-keyword">is</span> a range-`<span class="hljs-keyword">for</span>`-statement; it simply gives the programmer access to each element of a range.<br><br><span class="hljs-meta">## Chapter 10. Expressions</span><br><br><span class="hljs-meta">### 10.3 Operator Summary</span><br><br><span class="hljs-meta">#### 10.3.4 Temporary Objects</span><br><br><span class="hljs-number">1.</span> Often, the compiler must introduce an <span class="hljs-built_in">object</span> to hold an intermediate result of an expression.<br><br>- For example, <span class="hljs-keyword">for</span> `v=x+y∗z` the result of `y∗z` has to be put somewhere before it <span class="hljs-keyword">is</span> added to `x`.<br><br>   For built-<span class="hljs-keyword">in</span> types, <span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> all handled so that a ***temporary <span class="hljs-built_in">object</span>*** (often referred to <span class="hljs-keyword">as</span> just a ***temporary***) <span class="hljs-keyword">is</span> invisible to the user.<br><br>   For a user-defined type that holds a resource knowing the lifetime of a temporary can be important.<br><br><span class="hljs-number">2.</span> <span class="hljs-function">Unless bound to a reference <span class="hljs-keyword">or</span> used to initialize a named <span class="hljs-title">object</span> (<span class="hljs-params">variable</span>), a temporary <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> destroyed at the end od the full expression <span class="hljs-keyword">in</span> which it was created.</span><br><span class="hljs-function"></span><br><span class="hljs-function">   - A ***full expression*** <span class="hljs-keyword">is</span> an expression that <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a subexpression of some other expression.</span><br><span class="hljs-function">3. The standard-library `<span class="hljs-built_in">string</span>` has a member `<span class="hljs-title">c_str</span>()` that returns a C-style pointer to a zero-terminated array of charactors.</span><br><span class="hljs-function"></span><br><span class="hljs-function">   Also, the <span class="hljs-keyword">operator</span> `+` <span class="hljs-keyword">is</span> defined to mean <span class="hljs-built_in">string</span> concatenation. These are useful facilities <span class="hljs-keyword">for</span> `<span class="hljs-built_in">string</span>`s.</span><br><span class="hljs-function"></span><br><span class="hljs-function">   However, <span class="hljs-keyword">in</span> combination they can cause obscure problems.</span><br><span class="hljs-function"></span><br><span class="hljs-function">   - For example:</span><br><span class="hljs-function">   - ```C++</span><br><span class="hljs-function">     <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">string</span>&amp; s2, <span class="hljs-built_in">string</span>&amp; s3</span>)</span><br>     &#123;<br>         <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* cs = (s1+s2).c_str(); <span class="hljs-comment">// temporary is created and be destroyed. (full expression)</span><br>         cout &lt;&lt; cs; <span class="hljs-comment">// Error: cs points to deallocated storage. (might work)</span><br>         <span class="hljs-keyword">if</span>(strlen(cs=(s2+s3).c_str())&lt;<span class="hljs-number">8</span> &amp;&amp; cs[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;a&#x27;</span>)&#123;<br>             <span class="hljs-comment">// cs used here: not guaranteed to work</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>“Don’t do that!”</p>
</li>
<li><p>Such code does get written, so it is worth knowning how it is interpreted.</p>
<ul>
<li>A temporary string object is created to hold <code>s1+s2</code>. Next, A pointer to a C-style string is extraced from that object. Then – at the end of the expression – the temporary object is deleted.</li>
<li>The C-style string returned by <code>c_str()</code> was allocated as part of the temporary object holding <code>s1+s2</code>, and that storage is not guaranteed to exist after that temporary is destroyed.</li>
<li>Consequently, <code>cs</code> points to deallocated storage. The output operation <code>cout&lt;&lt;cs</code> might work as expected, but that would be sheer luck.</li>
<li>A compiler can detect and warn against many variants of this problem.</li>
</ul>
</li>
<li><p>The problem with the <code>if</code>-statement is a bit more subtle.</p>
<ul>
<li>The condition will work as expected because the full expression in which the temporary holding <code>s2+s3</code> is created is the condition itself.</li>
<li>However, that temporary is destroyed before the controlled statement is entered, so any use of <code>cs</code> there is not guaranteed to work.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Please note that in this case, as in many others, the problems with temporaries arose from using a high-level data type in a low-level way.</p>
<ul>
<li><p>A cleaner programming style yields a more understandable program fragment and avoids the problems with temporaries completely.</p>
</li>
<li><p>For example:</p>
<ul>
<li><p>```C++<br>void f(string&amp; s1, string&amp; s2, string&amp; s3)<br>{</p>
<pre><code class="hljs">cout &lt;&lt; s1+s2;
string s = s2+s3;
if(s.length()&lt;8 &amp;&amp; s[0]==&#39;a&#39;)&#123;
    // use s here
&#125;
</code></pre>
<p>}</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- A temporary can be used <span class="hljs-keyword">as</span> an initializer <span class="hljs-keyword">for</span> a `<span class="hljs-keyword">const</span>` reference <span class="hljs-keyword">or</span> a named <span class="hljs-built_in">object</span>.<br>- For example:<br><br>  - ```C++<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;</span>)</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>&amp;s1, <span class="hljs-built_in">string</span>&amp; s2</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s = s1+s2;<br>        <span class="hljs-built_in">string</span> ss = s1+s2;<br>    <br>        g(s,ss); <span class="hljs-comment">// we can use s and ss here</span><br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>This is fine. The temporary is destroyed when “its” reference or named object goes out of scope.</p>
<p>Remember that returning a reference to a local variable is an error and that a temporary object cannot be bound to a non-<code>const</code> lvaue reference.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>A temporary object can also be created explicitly in an expression by invoking a constructor.</p>
<p>For example:</p>
<ul>
<li>```C++<br>void f(Shape&amp; s, int n, char ch)<br>{<pre><code class="hljs">s.move(string&#123;n,ch&#125;); // construct a string with n copies of ch to pass to Shape::move()
// ...
</code></pre>
}<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">   - Such temporaries are destroyed <span class="hljs-keyword">in</span> exactly the same way <span class="hljs-keyword">as</span> the implicitly generated temporaries.<br><br><span class="hljs-comment">### 10.4 Constant Expressions</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1. C++ offers two related meaning of &quot;constant&quot;:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   - `constexpr`: Evaluate at compile time.</span><br><span class="hljs-comment">   - `const`: Do not modify in this scope.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Basically, `constexpr`&#x27;s role is to enable and ensure compile-time evaluation, whereas `const`&#x27;s primary role is to sepcify immutability in interface.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2. A ***constant expression*** is an expression that a compiler can evaluate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   - It cannot use values that are not known at compile time and it cannot have side effects.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Ultimately, a constant expression must start out with an integral value, a floating-point value, or an enumerator, and we can combine those using operator and `constexpr` functions that in turn produce values.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   In addition, some addresses can be used in some forms of constant expressions.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3. There are a variety of reasons why someone might want a named constant rather than a literal or a value stored in a variable:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   - Named constants make the code easier to understand and maintain.</span><br><span class="hljs-comment">   - A variable might be changed.</span><br><span class="hljs-comment">     - So we have to be more careful in our reasoning than for a constant.</span><br><span class="hljs-comment">   - The language requires constant expressions for array sizes, `case` labels, and `template` value arguments.</span><br><span class="hljs-comment">   - Embedded systems programmers like to put immutable data into read-only memory because read-only memory is cheaper than dynamic memory (in terms of cost and energy consumption), and often more plentiful. Also, data in read-only memory is immune to most system crashes.</span><br><span class="hljs-comment">   - If initialization is done at compile time, there can be no data races on that object in a multi-threaded system.</span><br><span class="hljs-comment">   - Sometimes, evaluating something once (at compile time) gives significantly better performance than doing so a million times at run time.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   We don&#x27;t just use constant expressions because of an obsession with performance. Often, the reason is that a constant expression is more direct representation of our system requirements.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span> <span class="hljs-number">10.5</span> Implicit Type Conversion<br><br><br><br><span class="hljs-comment">#### 10.5.1 Promotions</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span><span class="hljs-comment"># 10.5.2 Conversions</span><br><br><br><br><span class="hljs-comment">##### 10.5.2.1 Integral Conversions</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span><span class="hljs-comment">## 10.5.2.2 Floating-Point Conversions</span><br><br><br><br><span class="hljs-comment">##### 10.5.2.3 Pointer and Reference Conversions</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span><span class="hljs-comment">## 10.5.2.4 Pointer-to-Member Conversions</span><br><br><br><br><span class="hljs-comment">##### 10.5.2.5 Boolean Conversions</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span><span class="hljs-comment">## 10.5.2.6 Floating-Integral Conversions</span><br><br><br><br><br><br><span class="hljs-comment">## Chapter 11. Select Operations</span><br><br><span class="hljs-comment">### 11.2 Free Store</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span> <span class="hljs-number">11.4</span> Lambda Expressions<br><br><span class="hljs-comment">## Chapter 12. Functions</span><br><br><span class="hljs-comment">## Chapter 13. Exception Handling</span><br><br><span class="hljs-comment">### 13.6 A `vector` implementation</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">###</span><span class="hljs-comment"># 13.6.1 A Simple `vector`</span><br><br><span class="hljs-number">1.</span> A typical implementation <span class="hljs-keyword">of</span> `<span class="language-javascript">vector</span>` (section <span class="hljs-number">4.4</span><span class="hljs-number">.1</span>, section <span class="hljs-number">31.4</span>) will consist <span class="hljs-keyword">of</span> a **handle** holding pointers to the first element, one-past-the-last element, <span class="hljs-keyword">and</span> one-past-the-last allocated space (section <span class="hljs-number">31.2</span><span class="hljs-number">.1</span>) (<span class="hljs-keyword">or</span> the equivalent information represented <span class="hljs-keyword">as</span> a pointer plus offsets):<br><br>   - ![image<span class="hljs-number">-20230124202038535</span>](D:\obsidian\Louis\计算机专业知识\C++.assets\image<span class="hljs-number">-20230124202038535.</span>png)<br><br>   In addition, it holds an allocator (here, `<span class="language-javascript">alloc</span>`), <span class="hljs-keyword">from</span> which the `<span class="language-javascript">vector</span>` can acquire memory <span class="hljs-keyword">for</span> its elements.<br><br>   - The <span class="hljs-keyword">default</span> allocator (section <span class="hljs-number">34.4</span><span class="hljs-number">.1</span>) uses `<span class="language-javascript"><span class="hljs-keyword">new</span></span>` <span class="hljs-keyword">and</span> `<span class="language-javascript"><span class="hljs-keyword">delete</span></span>` to acquire <span class="hljs-keyword">and</span> release memory.<br><span class="hljs-number">2.</span> Here <span class="hljs-keyword">is</span> a declaration <span class="hljs-keyword">of</span> `<span class="language-javascript">vector</span>` simplified to present only what <span class="hljs-keyword">is</span> needed to discuss exception safety <span class="hljs-keyword">and</span> avoidance <span class="hljs-keyword">of</span> resource leaks:<br><br>   ```<span class="language-javascript">C++</span><br><span class="language-javascript">   template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> = allocator&lt;T&gt;&gt;</span><br><span class="language-javascript">   <span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span>&#123;</span><br><span class="language-javascript">   <span class="hljs-attr">private</span>:</span><br><span class="language-javascript">       T* elem; <span class="hljs-comment">// start of allocation</span></span><br><span class="language-javascript">       T* space; <span class="hljs-comment">// end of element sequence, start of space allocated for possible expression</span></span><br><span class="language-javascript">       T* last; <span class="hljs-comment">// end of allocated space</span></span><br><span class="language-javascript">       A alloc; <span class="hljs-comment">// allocator</span></span><br><span class="language-javascript">   </span><br><span class="language-javascript">   <span class="hljs-attr">public</span>:</span><br><span class="language-javascript">       using size_type = unsigned int; <span class="hljs-comment">// type used for vector sizes</span></span><br><span class="language-javascript">   </span><br><span class="language-javascript">       explicit <span class="hljs-title function_">vector</span>(size_type n, <span class="hljs-keyword">const</span> T&amp; val = <span class="hljs-title function_">T</span>(), <span class="hljs-keyword">const</span> A&amp; = <span class="hljs-title function_">A</span>());</span><br><span class="language-javascript">   </span><br><span class="language-javascript">       <span class="hljs-title function_">vector</span>(<span class="hljs-keyword">const</span> vector&amp; a); <span class="hljs-comment">// copy constructor</span></span><br><span class="language-javascript">       vector&amp; operator=(<span class="hljs-keyword">const</span> vector&amp; a); <span class="hljs-comment">// copy assignment</span></span><br><span class="language-javascript">   </span><br><span class="language-javascript">       <span class="hljs-title function_">vector</span>(vector&amp;&amp; a); <span class="hljs-comment">// move constructor</span></span><br><span class="language-javascript">       vector&amp; operator=(vector&amp;&amp; a); <span class="hljs-comment">// move assignment</span></span><br><span class="language-javascript">   </span><br><span class="language-javascript">       ~<span class="hljs-title function_">vector</span>();</span><br><span class="language-javascript">   </span><br><span class="language-javascript">       size_type <span class="hljs-title function_">size</span>() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> space-elem;&#125;</span><br><span class="language-javascript">       size_type <span class="hljs-title function_">capacity</span>() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> last-elem;&#125;</span><br><span class="language-javascript">       <span class="hljs-keyword">void</span> <span class="hljs-title function_">reserve</span>(size_type n); <span class="hljs-comment">// increase capacity to n</span></span><br><span class="language-javascript">   </span><br><span class="language-javascript">       <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span>(size_type n, <span class="hljs-keyword">const</span> T&amp; = &#123;&#125;); <span class="hljs-comment">// increase size to n</span></span><br><span class="language-javascript">       <span class="hljs-keyword">void</span> <span class="hljs-title function_">push_back</span>(<span class="hljs-keyword">const</span> T&amp;); <span class="hljs-comment">// add an element at the end</span></span><br><span class="language-javascript">   </span><br><span class="language-javascript">       <span class="hljs-comment">// ...</span></span><br><span class="language-javascript">   &#125;;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Chapter-14-Namespaces"><a href="#Chapter-14-Namespaces" class="headerlink" title="Chapter 14. Namespaces"></a>Chapter 14. Namespaces</h2><h4 id="14-2-4-Argument-Dependent-Lookup"><a href="#14-2-4-Argument-Dependent-Lookup" class="headerlink" title="14.2.4 Argument-Dependent Lookup"></a>14.2.4 Argument-Dependent Lookup</h4><ol>
<li>When a class member invokes a named function, other members of the same class and its base classes are preferred over functions potentially found based on argument types (operators follow a different rule; Section 18.5)</li>
</ol>
<h2 id="Chapter-15-Source-Files-and-Programs"><a href="#Chapter-15-Source-Files-and-Programs" class="headerlink" title="Chapter 15. Source Files and Programs"></a>Chapter 15. Source Files and Programs</h2><h3 id="15-4-Programs"><a href="#15-4-Programs" class="headerlink" title="15.4 Programs"></a>15.4 Programs</h3><h4 id="15-4-3-Program-Termination"><a href="#15-4-3-Program-Termination" class="headerlink" title="15.4.3 Program Termination"></a>15.4.3 Program Termination</h4><h1 id="The-C-Programming-Language-Part-Ⅲ-Abstraction-Mechanisms"><a href="#The-C-Programming-Language-Part-Ⅲ-Abstraction-Mechanisms" class="headerlink" title="The C++ Programming Language  Part Ⅲ : Abstraction Mechanisms"></a>The C++ Programming Language  Part Ⅲ : Abstraction Mechanisms</h1><h2 id="Chapter-16-Classes"><a href="#Chapter-16-Classes" class="headerlink" title="Chapter 16. Classes"></a>Chapter 16. Classes</h2><h3 id="16-2-Class-Basics"><a href="#16-2-Class-Basics" class="headerlink" title="16.2 Class Basics"></a>16.2 Class Basics</h3><h4 id="16-2-12-static-members"><a href="#16-2-12-static-members" class="headerlink" title="16.2.12 static members"></a>16.2.12 <code>static</code> members</h4><ol>
<li><p>A variable that is part of a class, yet is not part of an object of that class, is called a <code>static</code> member.</p>
<ul>
<li>This is exactly one copy of a <code>static</code> member instead of  one copy per object, as for ordinary non-<code>static</code> members (section 6.4.2).</li>
</ul>
<p>Similarly, a function that needs access to members of a class, yet doesn’t need to be invoked for a particular object, is called a <code>static</code> member function.</p>
</li>
<li><p>If used, a <code>static</code> member – a function or data member – must be defined somewhere.</p>
<p>The keyword <code>static</code> is not repeated in the definition of a <code>static</code> member.</p>
</li>
<li><p>In multi-threaded code, <code>static</code> data members require some kind of locking or access discipline to avoid race conditions (section 5.3.4; section 41.2.4).</p>
</li>
</ol>
<h3 id="16-3-Concrete-Classes"><a href="#16-3-Concrete-Classes" class="headerlink" title="16.3 Concrete Classes"></a>16.3 Concrete Classes</h3><ol>
<li>A class is called <em>concrete</em> (or <em>a concrete class</em>) if its representation is part of its definition.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> Chrono&#123;<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Month</span> &#123;jan=<span class="hljs-number">1</span>,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec&#125;;<br>  <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br>    <span class="hljs-keyword">public</span>: <span class="hljs-comment">// public interface</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bad_date</span>&#123;&#125;; <span class="hljs-comment">// exception class</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-type">int</span> dd=&#123;&#125;, Month mm=&#123;&#125;, <span class="hljs-type">int</span> yy=&#123;&#125;)</span></span>; <span class="hljs-comment">// &#123;&#125; means &quot;pick a default&quot;</span><br>      <br>        <span class="hljs-comment">// nonmodifying functions for examining the Date:</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function">Month <span class="hljs-title">month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>      <br>        <span class="hljs-function">string <span class="hljs-title">string_rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// string representation</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">char_rep</span><span class="hljs-params">(<span class="hljs-type">char</span> s[], <span class="hljs-type">int</span> max)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// C-style string representation</span><br>      <br>        <span class="hljs-comment">// (modifying) functions for changing the Date:</span><br>        <span class="hljs-function">Date&amp; <span class="hljs-title">add_year</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n years</span><br>        <span class="hljs-function">Date&amp; <span class="hljs-title">add_month</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n months</span><br>        <span class="hljs-function">Date&amp; <span class="hljs-title">add_day</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// add n days</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_valid</span><span class="hljs-params">()</span>: // check if this Date representation is a date</span><br><span class="hljs-function">        int d, m, y;</span> <span class="hljs-comment">// representation</span><br>    &#125;;<br>  <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_date</span><span class="hljs-params">(<span class="hljs-type">int</span> d, Month m, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// true for a valid date</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_leapyear</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// true if y is a leap year</span><br>  <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Date&amp; a, <span class="hljs-type">const</span> Date&amp; b);<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Date&amp;a, <span class="hljs-type">const</span> Date&amp; b);<br>  <br>    <span class="hljs-function"><span class="hljs-type">const</span> Date&amp; <span class="hljs-title">default_date</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// the default date</span><br>  <br>    ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Date&amp; d); <span class="hljs-comment">// print d to os</span><br>    istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Date&amp; d); <span class="hljs-comment">// read Date from is into d</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Chapter-17-Construction-Cleanup-Copy-and-Move"><a href="#Chapter-17-Construction-Cleanup-Copy-and-Move" class="headerlink" title="Chapter 17. Construction, Cleanup, Copy, and Move"></a>Chapter 17. Construction, Cleanup, Copy, and Move</h2><h3 id="17-2-Constructors-and-Destructors"><a href="#17-2-Constructors-and-Destructors" class="headerlink" title="17.2 Constructors and Destructors"></a>17.2 Constructors and Destructors</h3><h4 id="17-2-5-virtual-Destructors"><a href="#17-2-5-virtual-Destructors" class="headerlink" title="17.2.5 virtual Destructors"></a>17.2.5 <code>virtual</code> Destructors</h4><ol>
<li><p>A destructors can be declared to be <code>virtual</code>, and usually should be for a class with a virtual function.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">Circle</span>(); <span class="hljs-comment">// overrides ~Shape()</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>The reason we need a <code>virtual</code> destructor is that an object usually manipulated through the interface provided by a base class is often also <code>delete</code>d through that interface:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">user</span><span class="hljs-params">(Shape* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    p-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// invoke the appropriate draw()</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// invoke the appropriate destructor</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Had <code>Shape</code>‘s destructor not beed <code>virtual</code> that <code>delete</code> would have failed to invoke the appropriate derived class destructor (e.g., ~Circle()).</p>
<p>That failure would cause the resources owned by the deleted object (if any) to be leaked.</p>
</li>
</ul>
</li>
</ol>
<h3 id="17-5-Copy-and-Move"><a href="#17-5-Copy-and-Move" class="headerlink" title="17.5 Copy and Move"></a>17.5 Copy and Move</h3><h4 id="17-5-1-Copy"><a href="#17-5-1-Copy" class="headerlink" title="17.5.1 Copy"></a>17.5.1 Copy</h4><p>Consider a simple two-dimensional <code>Matrix</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>&#123;<br>    array&lt;<span class="hljs-type">int</span>,2&gt; dim; <span class="hljs-comment">// two dimensions</span><br>    T* elem; <span class="hljs-comment">// pointer to dim[0]*dim[1] elements of type T</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> d1, <span class="hljs-type">int</span> d2) :dim&#123;d1,d2&#125;, elem&#123;<span class="hljs-keyword">new</span> T[d1*d2]&#125;&#123;&#125; <span class="hljs-comment">// simplified (no error handling)\</span><br><span class="hljs-comment">    int size() const &#123;return dim[0]*dim[1];&#125;</span><br>  <br>    <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp;); <span class="hljs-comment">//copy constructor</span><br>    Matrix&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Matrix&amp;); <span class="hljs-comment">// copy assignment</span><br>  <br>    <span class="hljs-built_in">Matrix</span>(Matrix&amp;&amp;); <span class="hljs-comment">// move constructor</span><br>    Matrix&amp; <span class="hljs-keyword">operator</span>=(Matrix&amp;&amp;); <span class="hljs-comment">// move assignment</span><br>  <br>    ~<span class="hljs-built_in">Matrix</span>()&#123; <span class="hljs-keyword">delete</span>[] elem;&#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Chapter-18-Operator-Overloading"><a href="#Chapter-18-Operator-Overloading" class="headerlink" title="Chapter 18 Operator Overloading"></a>Chapter 18 Operator Overloading</h2><ul>
<li>Introduction</li>
<li>Operator Functions<ul>
<li>Binary and Unary Operators</li>
<li>Predefined Meanings for Operators</li>
<li>Operators and User defined Types</li>
<li>Passing Objects</li>
<li>Operators in Namespaces</li>
</ul>
</li>
<li>A Complex Number Type<ul>
<li>Member and Nonmember Operators</li>
<li>Mixed-Mode Arithmetic</li>
<li>Conversions</li>
<li>Literals</li>
<li>Accessor Functions</li>
<li>Helper Functions</li>
</ul>
</li>
<li>Type Conversion<ul>
<li>Conversion Operators</li>
<li><code>explicit</code> Conversion Operators</li>
<li>Ambiguities</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="18-1-Introduction"><a href="#18-1-Introduction" class="headerlink" title="18.1 Introduction"></a>18.1 Introduction</h3><ol>
<li><p>Every technical field – and most nontechnical fields – has developed conventional shorthand notation to make convenient the presentation and discussion involving frequently used concepts.</p>
<ul>
<li><code>x+y*z</code> is clearer to us than <code>mutiply y by z and add the result to x</code>.</li>
</ul>
</li>
<li><p>Like most languages, C++ supports a set of operators for its built-in types. However, most concepts for which operators are conventionally used are not built-in types in C++, so they must be represented as user-defined types.</p>
<ul>
<li>For example, if you need complex arithmetic, matrix algebra, logic signals, or character strings in C++, you use classes to represent these notions.</li>
</ul>
<p>Defining operators for such classes sometimes allows a programmer to provide a more conventional and convenient notation for manipulating objects than that could be achieved using only the basic functional notation.</p>
</li>
<li><p>Consider:</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123; <span class="hljs-comment">// a very simplified complex</span><br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) :re&#123;r&#125;,im&#123;i&#125;&#123;&#125;<br>    complex <span class="hljs-keyword">operator</span>+(complex);<br>    complex <span class="hljs-keyword">operator</span>*(complex);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>This defines a simple implementation of the concept of complex numbers.</p>
<ul>
<li>A <code>complex</code> is represented by a pair of double-precision floating-point numbers manipulated by the operator <code>+</code> and <code>*</code>.</li>
<li>The programmber defines <code>complex::operator+()</code> and <code>complex::operator*()</code> to provide meanings for <code>+</code> and <code>*</code>.<ul>
<li>For example, if <code>b</code> and <code>c</code> are of type <code>complex</code>, <code>b+c</code> means <code>b.operator+(c)</code></li>
</ul>
</li>
</ul>
<p>We can now approximate the conventional interpretation of <code>complex</code> expressions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    complex a = complex&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3.1</span>&#125;;<br>    complex b&#123;<span class="hljs-number">1.2</span>,<span class="hljs-number">2</span>&#125;;<br>    complex c&#123;b&#125;;<br>  <br>    a = b+c;<br>    b = b+c*a;<br>    c = a*b+<span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The usual precedence rules hold.<ul>
<li>So the second statement means <code>b=b+(c*a)</code>, not <code>b=(b+c)*a</code>.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>C++ grammar is written so that the <code>&#123;&#125;</code> notation can only be used for initializers and on the right-hand side of an assignment:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(complex a, complex b)</span></span><br><span class="hljs-function"></span>&#123;<br>    a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Ok: right hand side of assignment</span><br>    a += &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Ok: right hand side of assignment</span><br>    b = a+&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Sytax error</span><br>    b = a+complex&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// Ok</span><br>    <span class="hljs-built_in">g</span>(a,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;); <span class="hljs-comment">// Ok: a function argument is considered an initializer</span><br>    &#123;a,b&#125; = &#123;b,a&#125;; <span class="hljs-comment">// Sytax error</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>There seems to be no fundamental reason not to use <code>&#123;&#125;</code> in more places, but the technical problems of writing a grammar allowing <code>&#123;&#125;</code> everywhere in an expression (e.g., how would you know if a <code>&#123;</code> after a semicolon was the start of an expression or a block?) and also giving good error messages led to a more limited use of <code>&#123;&#125;</code> in expressions.</p>
<ol start="5">
<li>Many of the most obvious uses of operator overloading are for numberic types. However, the usefulness of user-defined operators is not restricted to numberic types.<ul>
<li>For example, the design of general and abstract interfaces often leads to the use of operators such as <code>-&gt;</code>, <code>[]</code>, and <code>()</code>.</li>
</ul>
</li>
</ol>
<h3 id="18-2-Operator-Functions"><a href="#18-2-Operator-Functions" class="headerlink" title="18.2 Operator Functions"></a>18.2 Operator Functions</h3><ol start="6">
<li>Functions defining meanings for the following operators can be declared:</li>
</ol>
<ul>
<li><img src="D:\obsidian\Louis\计算机专业知识\C++.assets\image-20230117195603731.png" srcset="/img/loading.gif" lazyload alt="image-20230117195603731"></li>
</ul>
<ol start="7">
<li><p>The following operators cannot be defined by a user:</p>
<ul>
<li><code>::</code>    scope resolution</li>
<li><code>.</code>     member selection</li>
<li><code>.*</code>    member selection through pointer to member</li>
</ul>
<p>They take a name, rather than a value, as their second operand and provide the primary means of referring to members. Allowing them to  be overloaded would lead to subtleties.</p>
</li>
<li><p>The named “operator” cannot be overloaded because they report fundamental facts about their operands:</p>
<ul>
<li><code>sizeof</code>    size of object</li>
<li><code>alignof</code>    alignment of object</li>
<li><code>typeid</code>    <code>type_info</code> of an object</li>
</ul>
</li>
<li><p>The ternary conditional expression operator cannot be overloaded (for no particularly fundamental reason):</p>
<ul>
<li><code>?:</code>    conditional evaluation</li>
</ul>
</li>
<li><p>User-defined literals are defined by using the <code>operator&quot;&quot;</code> notation.</p>
<ul>
<li>This is a syntactic subterfuge because there is no operator called <code>&quot;&quot;</code>.</li>
</ul>
<p>Similarly, <code>operaor T()</code> defines a conversion to a type <code>T</code>.</p>
</li>
<li><p>It is not possible to define new operator tokens, but you can use the function call notation when this set of operators is not adequate.</p>
<ul>
<li>For example, use <code>pow()</code>, not <code>**</code>.</li>
<li>These restrictions may seem Draconian, but more flexible rules can easily lead to ambiguities.<ul>
<li>For example, defining an operator <code>∗∗</code> to mean exponentiation may seem an obvious and easy task, but think again. Should <code>∗∗</code> bind to the left (as in Fortran) or to the right (as in Algol)? Should the expression <code>a∗∗p</code> be interpreted as <code>a∗(∗p)</code> or as <code>(a)∗∗(p)</code>?</li>
<li>There are solutions to all such technical questions.</li>
<li>However, it is most uncertain if applying subtle technical rules will lead to more readable and maintainable code. If doubt, use a named function.</li>
</ul>
</li>
</ul>
</li>
<li><p>The name of an operator function is the keyword <code>operator</code> followed by the operator itself.</p>
<ul>
<li>For example, <code>operator&lt;&lt;</code>.</li>
</ul>
<p>An operator function is declared and can be used like any other function.</p>
<ul>
<li>A use of the operator is only a shorthand for explicit call of the operator function.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(complex a, complex b)</span></span><br><span class="hljs-function"></span>&#123;<br>    complex c = a + b; <span class="hljs-comment">// shorthand</span><br>    complex d = a.<span class="hljs-keyword">operator</span>+(b); <span class="hljs-comment">// explicit call</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Given the previous definition of <code>complex</code>, the two initializers are synonymous.</p>
<h4 id="18-2-1-Binary-and-Unary-Operators"><a href="#18-2-1-Binary-and-Unary-Operators" class="headerlink" title="18.2.1 Binary and Unary Operators"></a>18.2.1 Binary and Unary Operators</h4><ol start="13">
<li>A binary operator can be defined by either a <a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickyk/p/4238380.html">non-<code>static</code> member function</a> taking one argument or a <a target="_blank" rel="noopener" href="https://www.cnblogs.com/muchen/p/6353793.html">nonmember function</a> taking two arguments.<ul>
<li>For any bianry operator <code>@</code>, <code>aa@bb</code> can be interpreted as either <code>aa.operator@bb</code> or <code>operator@(aa,bb)</code>. If both are defined, overload resolution determines which, if any, interpretation is used.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span>);<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+(X,X); <span class="hljs-comment">// non-static member function</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+(X,<span class="hljs-type">double</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(X a)</span></span><br><span class="hljs-function"></span>&#123;<br>    a+<span class="hljs-number">1</span>; <span class="hljs-comment">// a.operator+(1)</span><br>    <span class="hljs-number">1</span>+a; <span class="hljs-comment">// ::operator+(X(1),a) nonmember function</span><br>    a+<span class="hljs-number">1.0</span>; <span class="hljs-comment">// ：：operator+(a,1.0)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1022477">静态成员函数和非静态成员函数的区别？ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<ol start="14">
<li><p>A unary operator, whether prefix or postfix, can be defined by either a non-<code>static</code> member function taking no arguments or a nonmember function taking one argument.</p>
<ul>
<li>For any prefix unary operator <code>@</code>, <code>@aa</code> can be interpreted as either <code>aa.operator@()</code> or <code>operator@(aa)</code>. If both are defined, overload resolution determines which, if any, interpretation is used.</li>
<li>For any postfix unary operator <code>@</code>, <code>aa@</code> can be interpreted as either <code>aa.operator@()</code> or <code>operator@(aa,int)</code>. If both are defined, overload resolution determines which, if any, interpretation is used.</li>
<li>参考section 19.2.4节，介绍关于argument <code>int</code>作为一个dummy，只是用于区分prefix和postfix.<ul>
<li>The <code>int</code> argument is used to indicate that the function is to be invoked for postfix application of <code>++</code>.<ul>
<li>This <code>int</code> is never used; the argument is simply a dummy used to distinguish between prefix and postfix application.</li>
<li>The way to remember which version of an <code>operator++</code> is prefix is to note that the version without the dummy argument is prefix, exactly like all the other unary arithmetic and logical operators.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>An operator can be declared only for the syntax defined for it in the grammar.</p>
<ul>
<li>For example, a user cannot define a unary <code>%</code> or a ternary <code>+</code>.</li>
</ul>
<p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// members (with implicit this pointer):</span><br>    X* <span class="hljs-keyword">operator</span>&amp;(); <span class="hljs-comment">// prefix unary &amp; (address of)</span><br>    X <span class="hljs-keyword">operator</span>&amp;(X); <span class="hljs-comment">// binary &amp; (and)</span><br>    X <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix increment</span><br>    X <span class="hljs-keyword">operator</span>&amp;(X,X); <span class="hljs-comment">// Error: ternary</span><br>    X <span class="hljs-keyword">operator</span>/(); <span class="hljs-comment">//Erro: Unary /</span><br>&#125;;<br><br><span class="hljs-comment">// nonmember functions:</span><br>X <span class="hljs-keyword">operator</span>-(X); <span class="hljs-comment">// prefix unary minus</span><br>X <span class="hljs-keyword">operator</span>-(X,X); <span class="hljs-comment">// binary minus</span><br>X <span class="hljs-keyword">operator</span>--(X&amp;,<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix decrement</span><br>X <span class="hljs-keyword">operator</span>-(); <span class="hljs-comment">// Error: no operand</span><br>X <span class="hljs-keyword">operator</span>-(X,X,X); <span class="hljs-comment">// Error: ternary</span><br>X <span class="hljs-keyword">operator</span>%(X); <span class="hljs-comment">// Error: unary %</span><br></code></pre></td></tr></table></figure></li>
<li><p>The operators <code>operator=</code>, <code>operator[]</code>, <code>operator()</code>, and <code>operator-&gt;</code> must be non-<code>static</code> member functions.</p>
</li>
<li><p>The default meaning of <code>&amp;&amp;</code>, <code>||</code> and <code>,</code> involves sequencing: the first operand is evaluated before the second (and for <code>&amp;&amp;</code> and <code>||</code> the second operand is not always evaluated).</p>
<ul>
<li>This special rule does not hold for user-defined versions of <code>&amp;&amp;</code> , <code>||</code>, and <code>,</code>; instead these operators are treated exactly like other binary operators.</li>
</ul>
</li>
</ol>
<h4 id="18-2-2-Predefined-Meanings-for-Operators"><a href="#18-2-2-Predefined-Meanings-for-Operators" class="headerlink" title="18.2.2 Predefined Meanings for Operators"></a>18.2.2 Predefined Meanings for Operators</h4><ol start="18">
<li><p>The meaning of some built-in operators are defined to be equivalent to some combination of other operators on the same arguments.</p>
<ul>
<li>For example, if <code>a</code> is an int,  <code>++a</code> means <code>a+=1</code>, which in turn means <code>a=a+1</code>.</li>
</ul>
<p>Such relations do not hold for user-defined operators unless the user defines them to.</p>
<ul>
<li>For example, a compiler will not generate a definition of <code>Z::operator+=()</code> from the definitions of <code>Z::operator+()</code> and <code>Z::operator=()</code>.</li>
</ul>
</li>
<li><p>The operator <code>=</code>(assignment), <code>&amp;</code>(address of), and <code>,</code>(sequencing) have predefined meanings when applied to class objects.</p>
<ul>
<li>These predefined meanings can be eliminated(“deleted”)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> X&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&amp;() = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>,(<span class="hljs-type">const</span> X&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(X a, X b)</span></span><br><span class="hljs-function"></span>&#123;<br>    a = b; <span class="hljs-comment">// Error: no operator=()</span><br>    &amp;a; <span class="hljs-comment">// Error: no operator&amp;()</span><br>    a,b; <span class="hljs-comment">// Error: no operator,()</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Alternatively, they can be given new meanings by suitable definitions.</p>
</li>
</ol>
<h4 id="18-2-3-Operators-and-User-Defined-Types"><a href="#18-2-3-Operators-and-User-Defined-Types" class="headerlink" title="18.2.3 Operators and User-Defined Types"></a>18.2.3 Operators and User-Defined Types</h4><ol start="20">
<li><p>An operator function must either be a member or take at least one argument of a user-defined type (functions redefining the <code>new</code> and <code>delete</code> operators need not).</p>
<ul>
<li>This rule ensures that a user cannot change the meaning of an expression unless the expression contains an object of a user-defined type.</li>
</ul>
<p>In particular, it is not possible to define an operator function that operates exclusively on pointers.</p>
<ul>
<li>This ensures that C++ is extensible but not mutable (with the exception of operators <code>=</code>, <code>&amp;</code>, and <code>,</code> for class objects).</li>
</ul>
</li>
<li><p>An operator function intended to accept a built-in type as its first operand cannot be a member function.</p>
<ul>
<li>For example, consider adding a complex variable <code>aa</code> to the integer <code>2</code>: <code>aa+2</code> can, with suitably declared member function , be interpreted as <code>aa.operator+(2)</code>, but <code>2+aa</code> cannot because there is no class <code>int</code> for which to define <code>+</code> to mean <code>2+operator+(aa)</code>.<ul>
<li>Even if there were, two different member functions would be needed to cope with <code>2+aa</code> and <code>aa+2</code>. Because the compiler does not know the meaning of a user-defined +, it cannot assume that the operator is commutative and so interpret <code>2+aa</code> as <code>aa+2</code>.</li>
<li>This example is trivially handled using one or more nonmember functions.</li>
</ul>
</li>
</ul>
</li>
<li><p>Enumberations are user-defined types so that we can define operators for them.</p>
<ul>
<li><p>For example</p>
<ul>
<li>```C++<br>enum Day{sun,mon,tue,wed,thu,fri,sat};Day&amp; operator++(Day&amp; d)<br>{<pre><code class="hljs">return d = (sat == d) ? sun : static_cast&lt;Day&gt;(d+1);
</code></pre>
}<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><br>Every expression <span class="hljs-keyword">is</span> checked <span class="hljs-keyword">for</span> ambiguities. <span class="hljs-keyword">Where</span> a user-defined <span class="hljs-keyword">operator</span> provide a possible interpretation, the expression <span class="hljs-keyword">is</span> checked according <span class="hljs-keyword">to</span> the <span class="hljs-keyword">overload</span> resolution rules <span class="hljs-keyword">in</span> Section <span class="hljs-number">12.3</span>.<br><br>#### <span class="hljs-number">18.2</span>.<span class="hljs-number">4</span> Passing objects<br><br><span class="hljs-number">23</span>. When we define an <span class="hljs-keyword">operator</span>, we typically want <span class="hljs-keyword">to</span> provide a conventional notation.<br><br>    - <span class="hljs-keyword">For</span> example, `a=b+c`.<br><br>    Consequently, we have limited choices <span class="hljs-keyword">of</span> how <span class="hljs-keyword">to</span> pass arguments <span class="hljs-keyword">to</span> the <span class="hljs-keyword">operator</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">how</span> <span class="hljs-title function_">it</span> <span class="hljs-title function_">returns</span> <span class="hljs-title function_">its</span> <span class="hljs-title function_">value</span>.<br><br>    - <span class="hljs-title function_">For</span> <span class="hljs-title function_">example</span>, <span class="hljs-title function_">we</span> <span class="hljs-title function_">cannot</span> <span class="hljs-title function_">require</span> <span class="hljs-title function_">pointer</span> <span class="hljs-title function_">arguments</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">expect</span> <span class="hljs-title function_">programmers</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">use</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">address</span>-<span class="hljs-title function_">of</span> <span class="hljs-title function_">operator</span> <span class="hljs-title function_">or</span> <span class="hljs-title function_">return</span> <span class="hljs-title function_">a</span> <span class="hljs-title function_">pointer</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">expect</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">user</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">dereference</span> <span class="hljs-title function_">it</span>: `*a=&amp;b+&amp;c` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> acceptable.<br><span class="hljs-number">24</span>. <span class="hljs-keyword">For</span> arguments, we have two main choices:<br><br>    - Pass-<span class="hljs-keyword">by</span>-value<br>    - Pass-<span class="hljs-keyword">by</span>-<span class="hljs-keyword">reference</span><br><br>    <span class="hljs-keyword">For</span> small objects, say, one <span class="hljs-keyword">to</span> four words, call-<span class="hljs-keyword">by</span>-value <span class="hljs-keyword">is</span> typically a viable alternative <span class="hljs-keyword">and</span> often the one that gives the best performance.<br><br>    However, performance <span class="hljs-keyword">of</span> argument passing <span class="hljs-keyword">and</span> use depends <span class="hljs-keyword">on</span> machine architecture, compiler <span class="hljs-keyword">interface</span> conventions (Application Binary Interfaces<span class="hljs-punctuation">;</span> ABIs), <span class="hljs-keyword">and</span> the number <span class="hljs-keyword">of</span> times an argument <span class="hljs-keyword">is</span> accessed (it almost always <span class="hljs-keyword">is</span> faster <span class="hljs-keyword">to</span> access an argument passed <span class="hljs-keyword">by</span> value than one passed <span class="hljs-keyword">by</span> <span class="hljs-keyword">reference</span>).<br><br>    - <span class="hljs-keyword">For</span> example, assument taht a `Point` <span class="hljs-keyword">is</span> represented <span class="hljs-keyword">as</span> a pair <span class="hljs-keyword">of</span> `int`s:<br><br>      - ```C++<br>        void Point::<span class="hljs-keyword">operator</span>+=(Point delta)<span class="hljs-punctuation">;</span> <span class="hljs-comment">// pass-by-value (small object)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>For larger objects, we pass by reference.</p>
<ul>
<li><p>For example.</p>
<ul>
<li>```C++<br>template<class T><br>class Matrix{<pre><code class="hljs">array&lt;int,2&gt; dim; // two dimensions
T* elem; // pointer to dim[0]*dim[1] elements of type T
</code></pre>
public:<pre><code class="hljs">Matrix(int d1, int d2) :dim&#123;d1,d2&#125;, elem&#123;new T[d1*d2]&#125;&#123;&#125; // simplified (no error handling)\
int size() const &#123;return dim[0]*dim[1];&#125;

Matrix(const Matrix&amp;); //copy constructor
Matrix&amp; operator=(const Matrix&amp;); // copy assignment

Matrix(Matrix&amp;&amp;); // move constructor
Matrix&amp; operator=(Matrix&amp;&amp;); // move assignment

~Matrix()&#123; delete[] elem;&#125;
//...
</code></pre>
}<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">- Because a `<span class="hljs-keyword">Matrix</span>` (a simple <span class="hljs-keyword">matrix</span> of `double`s) is most likely larger than a few words, we <span class="hljs-keyword">use</span> pass-<span class="hljs-keyword">by</span>-reference:<br>- ```C++<br>  <span class="hljs-keyword">Matrix</span> operator+(<span class="hljs-keyword">const</span> <span class="hljs-keyword">Matrix</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">Matrix</span>&amp;); <span class="hljs-comment">// pass-by-const-reference</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>In particular, we use <code>const</code> references to pass large objects that are not meant to be modified by the called function.</p>
</li>
</ul>
</li>
<li><p>Typically, an operator returns a result.</p>
<p>Returning a pointer or reference to a newly created object is usually a very bad idea:</p>
<ul>
<li>Using a pointer gives notational problems</li>
<li>Referring to an object on the free store (whether by a pointer or by a reference) results in memory management problems.</li>
</ul>
<p>Instead, return objects by value. For large objects, such as a <code>Matrix</code>, define move operations to make such transfers of values efficient.</p>
<ul>
<li><p>For example:</p>
<ul>
<li>```C++<br>Matrix operator+(const Matrix&amp; a, const Matrix&amp; b) // return-by-value<br>{<pre><code class="hljs">Matrix res&#123;a&#125;;
return res+=b;
</code></pre>
}<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs maxima">- Note that operators that <span class="hljs-built_in">return</span> one of their argument objects can -- <span class="hljs-keyword">and</span> usually <span class="hljs-keyword">do</span> -- <span class="hljs-built_in">return</span> a reference.<br><br>  - For <span class="hljs-built_in">example</span>, we could <span class="hljs-built_in">define</span> `Matrix`&#x27;s operator `+=` like this:<br>  - ```C++<br>    Matrix&amp; Matrix::operator+=(const Matrix&amp; a) // <span class="hljs-built_in">return</span>-by-reference<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dim</span>[<span class="hljs-number">0</span>]!=a.<span class="hljs-built_in">dim</span>[<span class="hljs-number">0</span>] || <span class="hljs-built_in">dim</span>[<span class="hljs-number">1</span>]!=a.<span class="hljs-built_in">dim</span>[<span class="hljs-number">1</span>])<br>            <span class="hljs-built_in">throw</span> <span class="hljs-built_in">std</span>::exception(<span class="hljs-string">&quot;bad Matrix += argument&quot;</span>);<br>        double* p = <span class="hljs-built_in">elem</span>;<br>        double* q = a.<span class="hljs-built_in">elem</span>;<br>        double* end = p+<span class="hljs-built_in">dim</span>[<span class="hljs-number">0</span>]*<span class="hljs-built_in">dim</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(p!=end)<br>            *p++=*q++;<br>    <br>        <span class="hljs-built_in">return</span> *this;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>This is particularly common for operator functions that are implemented as members.</li>
</ul>
</li>
</ul>
</li>
<li><p>If a function is simply passes an object to another function, an rvalue reference argument should be used.</p>
</li>
</ol>
<h4 id="18-2-5-Operators-in-Namespaces"><a href="#18-2-5-Operators-in-Namespaces" class="headerlink" title="18.2.5 Operators in Namespaces"></a>18.2.5 Operators in Namespaces</h4><ol start="27">
<li><p>An operator is either a member of a class or defined in some namespace (possibly the global namespace).</p>
<p>Consider this simplified version of string I/O from the standard library.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std&#123; <span class="hljs-comment">// simplified std</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ostream</span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*); <span class="hljs-comment">// ouput C-style string</span><br>    &#125;;<br><br>    <span class="hljs-keyword">extern</span> ostream cout;<br><br>    ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="hljs-type">const</span> string&amp;); <span class="hljs-comment">// output std::string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*p = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::string s = <span class="hljs-string">&quot;world&quot;</span>;<br>    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;!\n&quot;</span>; <span class="hljs-comment">// write out: Hello, world!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Using <code>std::</code> prefix for <code>string</code> and <code>cout</code>, instead of <code>using namepsace std</code>, I was on my best behavior and didn’t pollute the global namespace or in other ways introduce unnecessary dependencies.</p>
</li>
<li><p>The  output operator for C-style strings is a member of <code>std::ostream</code>, so by definition</p>
<ul>
<li><code>std::cout &lt;&lt; p</code> means <code>std::cout.operator&lt;&lt;(p)</code></li>
</ul>
</li>
<li><p><code>std::ostream</code> doesn’t have a member function to output a <code>std::string</code>, so</p>
<ul>
<li><code>std::cout&lt;&lt;s</code> means <code>operator&lt;&lt;(std::cout,s)</code></li>
</ul>
</li>
<li><p>Operators defined in namespaces can be found based on their operand types just as functions can be found based on their argument types.</p>
<ul>
<li><p>In particular, <code>cout</code> is in namespace <code>std</code>, so <code>std</code> is considered when looking for suitable definition of <code>&lt;&lt;</code>.</p>
</li>
<li><p>In that way, for <code>std::cout&lt;&lt;s</code>, the compiler finds and uses:</p>
<ul>
<li>```C++<br>std::operator&lt;&lt;(std::ostream, const std::string&amp;)<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">28</span>. Consider a bianry operator `@`, if `x` is of type `X` <span class="hljs-literal">and</span> `y` is of type `Y`, `x@y` is resolved like this:<br><br>    - If `X` is a class, look for `operator@` as a member of `X` <span class="hljs-literal">or</span> as a member of a base of `X`; <span class="hljs-literal">and</span><br>    - look for declarations of `operator@` in the context surrounding `x@y`; <span class="hljs-literal">and</span><br>    - if `X` is defined in namespace `N`, look for declarations of `operator@` in `N`; <span class="hljs-literal">and</span><br>    - if `Y` is defined in naspace `M`, look for declarations of `operator@` in `M`.<br><br>    Declarations for several `operator@`s may be found an overload resolution rules are used to find the best match, if any.<br><br>    This lookup mechanism is applied only if the operator has at least one operand of a user-defined type.<br><br>    - Therefore, user-defined conversions will be considered.<br>    - Note that a type alias is just a synonym <span class="hljs-literal">and</span> <span class="hljs-literal">not</span> a separate user-defined type.<br><br>    Unary operators are resolved analogously.<br><br>    Note that in operator lookup no preference is given to members over nonmembers.<br><br>    - This different from lookup of named functions.<br><br>      - When a class member invokes a named function, other members of the same class <span class="hljs-literal">and</span> its base classes are preferred over functions potentially found based on argument types.<br>    - The lack of hiding operators ensures that built-in operator are never inaccessible <span class="hljs-literal">and</span> that users can supply <span class="hljs-keyword">new</span> meanings for an operator without modifying existing class declarations.<br><br>      - For example.<br>      - ```C++<br>        X operator!(X)<span class="hljs-comment">;</span><br>        <br>        struct Z&#123;<br>            Z operator!()<span class="hljs-comment">; // does not hide ::operator!()</span><br>            X f(X x) &#123; <span class="hljs-comment">/*...*/</span> <span class="hljs-keyword">return</span> !x<span class="hljs-comment">;&#125; // invoke ::operator!(X)</span><br>            int f(int x) &#123; <span class="hljs-comment">/*...*/</span> <span class="hljs-keyword">return</span> !x<span class="hljs-comment">;&#125; // invokde the built-in ! for ints</span><br>        &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>In particular, the standard <code>iostream</code> library defines <code>&lt;&lt;</code> member functions to output built-in types, and a user can define <code>&lt;&lt;</code> to output user-defined types without modifying class <code>ostream</code>.</p>
</li>
</ul>
</li>
</ol>
<h3 id="18-3-A-Complex-Number-Type"><a href="#18-3-A-Complex-Number-Type" class="headerlink" title="18.3 A Complex Number Type"></a>18.3 A Complex Number Type</h3><ol start="29">
<li><p>The implementation of complex numbers presented in section 18.1 is too restrictive to please anyone.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123; <span class="hljs-comment">// a very simplified complex (from section 18.1)</span><br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) :re&#123;r&#125;,im&#123;i&#125;&#123;&#125;<br>    complex <span class="hljs-keyword">operator</span>+(complex);<br>    complex <span class="hljs-keyword">operator</span>*(complex);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>We would expect this to work:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    complex a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    complex b&#123;<span class="hljs-number">3</span>&#125;;<br>    complex c&#123;a+<span class="hljs-number">2.3</span>&#125;;<br>    complex d&#123;<span class="hljs-number">2</span>+b&#125;;<br>    b = c*<span class="hljs-number">2</span>*c;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>In addtion, we would expect to be provided with a few additional operators.<ul>
<li>Such as <code>==</code> for comparison and <code>&lt;&lt;</code> for output, and a suitable set of mathematical functions, such as <code>sin()</code> and <code>sqrt()</code>.</li>
</ul>
</li>
</ul>
</li>
<li><p>Class <code>complex</code> is a concrete type, so its design follows the guidelines from section 16.3.</p>
<p>In addition, users of complex arithmetic rely so heavily on operators that the definition of <code>complex</code> brings into play most of the basic rules for operator overloading.</p>
</li>
<li><p>The <code>complex</code> type developed in this section uses <code>double</code> for its scalars and is roughly equivalent to the standard-library <code>complex&lt;double&gt;</code>.</p>
</li>
</ol>
<h4 id="18-3-1-Member-and-Nonmember-Operators"><a href="#18-3-1-Member-and-Nonmember-Operators" class="headerlink" title="18.3.1 Member and Nonmember Operators"></a>18.3.1 Member and Nonmember Operators</h4><ol start="32">
<li><p>I prefer to minimize the number of functions that directly manipulate the representation of an object.</p>
<ul>
<li><p>This can be achieved by defining only operators that inherently modify the value of their first argument, such as <code>+=</code>, in the class itself.</p>
</li>
<li><p>Operators that simply produce a new value based on the values of their arguments, such as <code>+</code>, are then defined outside the class and use the essential operators in their implementation:</p>
</li>
<li><p>```C++<br>class complex{</p>
<pre><code class="hljs">double re, im;
</code></pre>
<p>public:</p>
<pre><code class="hljs">complex&amp; operator+=(complex a); // needs access to representation
// ...
</code></pre>
<p>};<br>complex operator+(complex a, complex b)<br>{</p>
<pre><code class="hljs">return a += b; // access representation through +=
</code></pre>
<p>}</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>  - The arguments to <span class="hljs-keyword">this</span> `<span class="hljs-keyword">operator</span>+()` are passed by value, so `a+b` does <span class="hljs-keyword">not</span> modify its operands.<br>- Given these declarations, we can write:<br><br>  ```C++<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(complex x, complex y, complex z)</span></span><br><span class="hljs-function">  </span>&#123;<br>      complex r1&#123;x+y+z&#125;; <span class="hljs-comment">// r1 = operator+(operator+(x,y),z)</span><br>  <br>      complex r2&#123;x&#125;; <span class="hljs-comment">// r2 = x</span><br>      r2 += y; <span class="hljs-comment">// r2.operator+=(y)</span><br>      r2 += z; <span class="hljs-comment">// r2.operator+=(z)</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Except for possible efficiency differentces, the computations of <code>r1</code> and <code>r2</code> are equivalent.</li>
</ul>
</li>
<li><p>Composite assignment operators such as <code>+=</code> and <code>*=</code> tend to be simpler to define than their “simple” counterparts <code>+</code> and <code>*</code>.</p>
<ul>
<li><p>This surprises most people at first, but follows from the fact that three objects are involved in a <code>+</code> operation (the two operands and the result), whereas only two objects are involved in a <code>+=</code> operation.</p>
</li>
<li><p>In the latter case, run-time efficiency is improved by eliminating the need for temporary variables.</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span> complex&amp; complex::<span class="hljs-keyword">operator</span>+=(complex a)<br>&#123;<br>    re += a.re;<br>    im += a.im;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This does not require a temporary variable to hold the result of the addition and is simple for a compiler to inline perfectly.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>A good optimizer will generate close to optimal code for uses fo the plain <code>+</code> operator also.</p>
<p>However, we don’t always have a good optimizer, and not all types are as simple as <code>complex</code>.</p>
<ul>
<li>Section 19.4 discusses ways of defining operators with direct access to the representation of classes.</li>
</ul>
</li>
</ol>
<h4 id="18-3-2-Mixed-Mode-Arithmetic"><a href="#18-3-2-Mixed-Mode-Arithmetic" class="headerlink" title="18.3.2 Mixed-Mode Arithmetic"></a>18.3.2 Mixed-Mode Arithmetic</h4><ol start="34">
<li><p>To cope with <code>2+z</code>, where <code>z</code> is a <code>complex</code>, we need to define operator <code>+</code> to accept operands of different types.</p>
<p>In Fortran terminology, we need <em><strong>mixed-mode arithmetic</strong></em>.</p>
<p>We can achieve that simply by adding appropriate versions of the operators:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    complex&amp; <span class="hljs-keyword">operator</span>+=(complex a)<br>    &#123;<br>        re += a.re;<br>        im += a.im;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    complex&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">double</span> a)<br>    &#123;<br>        re += a;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>The three variants of <code>operator+()</code> can be defined outside <code>complex</code>:</p>
<ul>
<li>```C++<br>complex operator+(complex a, complex b)<br>{<pre><code class="hljs">return a += b; // calls complex::operator+=(complex)
</code></pre>
}complex operator+(complex a, double b)<br>{<pre><code class="hljs">return &#123;a.real()+b, a.imag()&#125;; // real() and imag() are defined in section 18.3.6
</code></pre>
}complex operator+(double a, complex b)<br>{<pre><code class="hljs">return &#123;a+b.real(), b.imag()&#125;;
</code></pre>
}<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>Given these declarations of `+`, we can write:<br><br>```C++<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(complex x, complex y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> r1 = x+y; <span class="hljs-comment">// calls operator+(complex, complex)</span><br>    <span class="hljs-keyword">auto</span> r2 = x+<span class="hljs-number">2</span>; <span class="hljs-comment">// calls operator+(complex, double)</span><br>    <span class="hljs-keyword">auto</span> r3 = <span class="hljs-number">2</span>+x; <span class="hljs-comment">// calls operator+(double, complex)</span><br>    <span class="hljs-keyword">auto</span> r4 = <span class="hljs-number">2</span>+<span class="hljs-number">3</span>; <span class="hljs-comment">// built-in integer addition (for completeness)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="18-3-3-Conversions"><a href="#18-3-3-Conversions" class="headerlink" title="18.3.3 Conversions"></a>18.3.3 Conversions</h4><ol start="35">
<li><p>To cope with assignments and initialization of <code>complex</code> variables with scalars, we need a conversion of a scalar (integer or floating-point number) to a <code>complex</code>.</p>
<ul>
<li>For example:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex b&#123;<span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// should mean b.re=3, b.im=0</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">comp</span><span class="hljs-params">(complex x)</span></span><br><span class="hljs-function"></span>&#123;<br>    x = <span class="hljs-number">4</span>; <span class="hljs-comment">// should mean x.re=4, x.im=0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>We can achieve that by providing a constructor that takes a single number.</p>
<p>A constructor taking a single argument specifies a conversion from its argument type to the constuctors type.</p>
<ul>
<li>For example</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    <span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r) :re&#123;r&#125;, im&#123;<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// build a complex from a double</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The constructor specifies the traditional embedding of the real line in the complex plane.</li>
</ul>
</li>
<li><p>A constructor is a prescription for creating a value of a given type.</p>
<ul>
<li>The constructor is used when a value of a type is expected and when such a value can be created by a constructor for the value supplied as an initializer or assigned value.</li>
<li>Thus, a constructor requiring a single argument need not be called explicitly.</li>
<li>For example:</li>
<li>```C++<br>complex b{3};<br>// means<br>complex b{3,0};<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">37.</span> A user-defined conversion is implicitly applied only <span class="hljs-keyword">if</span> it is unique.<br><br>    - If you don<span class="hljs-number">&#x27;</span>t want a constructor to be used implicitly, declare it `<span class="hljs-keyword">explicit</span>`.<br><span class="hljs-number">38.</span> Naturally, we still need the constructor that takes two `<span class="hljs-type">double</span>`s, <span class="hljs-keyword">and</span> a <span class="hljs-keyword">default</span> constructor initializing a `complex` to `&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;` is also useful:<br><br>    ```C++<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    	<span class="hljs-type">double</span> re, im;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">complex</span>() :re&#123;<span class="hljs-number">0</span>&#125;, im&#123;<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// default constructor</span><br>        <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r) :re&#123;r&#125;, im&#123;<span class="hljs-number">0</span>&#125; &#123;&#125; <span class="hljs-comment">// constructor from scalar to a complex</span><br>        <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125; <span class="hljs-comment">// constructor that takes two doubles</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Using default arguments, we can abbreviate:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>	<span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> i=<span class="hljs-number">0</span>) :re&#123;r&#125;, im&#123;i&#125; &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>By default, copying <code>complex</code> values is defined as copying the real and imaginary parts.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    complex z;<br>    complex x&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    complex y&#123;x&#125;; <span class="hljs-comment">// y also has the value &#123;1,2&#125;</span><br>    z = x; <span class="hljs-comment">// z also has the value &#123;1,2&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="18-3-3-1-Conversions-of-Operands"><a href="#18-3-3-1-Conversions-of-Operands" class="headerlink" title="18.3.3.1 Conversions of Operands"></a>18.3.3.1 Conversions of Operands</h5><ol start="40">
<li><p>We defined three versions of each of the four standard arithmetic operators(<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(complex, complex);<br>complex <span class="hljs-keyword">operator</span>+(complex, <span class="hljs-type">double</span>);<br>complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span>, complex);<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>

<p>This can get tedious, and what is tedious easily becomes error-prone.</p>
<ul>
<li>What if we had three alternatives for the type of each argument for each funtion?<ul>
<li>We would need 3 versions of each single-argument function,  9 version of each two-argument function, 27 versions of each three-argument function, etc.</li>
</ul>
</li>
<li>Often these variants are very similar.<ul>
<li>In fact, almost all variants involve a simple conversion of arguments to a common type followed by a standard algorithm.</li>
</ul>
</li>
</ul>
</li>
<li><p>The alternative to providing different versions of a function for each combination of arguments is rely on conversions.</p>
<ul>
<li><p>For example, our <code>complex</code> class provides a constructor that converts a <code>double</code> to a <code>complex</code>.</p>
</li>
<li><p>Consequently, we could simply declare only one version of the equality operator for <code>complex</code>:</p>
<ul>
<li>```C++<br>bool operator==(complex, complex);void f(complex x, complex y)<br>{<pre><code class="hljs">x==y; // means operator(x,y)
x==3; // means operator(x,complex(3))
3==y; // means operator(complex(3),y)
</code></pre>
}<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-number">42.</span> There can be reasons for preferring to define separate functions.<br><br>    - For example, <span class="hljs-keyword">in</span> some cases the conversion can impose overhead, and <span class="hljs-keyword">in</span> other cases, a simpler algorithm can be used for  specific argument types.<br><br>    <span class="hljs-keyword">Where</span> such issues are not significant, relying on conversions and providing <span class="hljs-keyword">only</span> the most general variant of a <span class="hljs-function"><span class="hljs-keyword">function</span></span> -- plus possibly a few critical variants -- contain the combinatorial explosion of variants that can arise from mixed-mode arithmetic.<br><span class="hljs-number">43.</span> <span class="hljs-keyword">Where</span> several variants of a <span class="hljs-function"><span class="hljs-keyword">function</span></span> or an operator <span class="hljs-keyword">exist</span>, the compiler must pick <span class="hljs-string">&quot;the right&quot;</span> variant based on the argument types and  the available (standard and user-defined) conversions.<br><br>    - Unless a best match exists, an expression is ambiguous and is an error.<br><span class="hljs-number">44.</span> An object constructed by explicit or <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">use</span> of a constructor <span class="hljs-keyword">in</span> an expression (temporary objects; section <span class="hljs-number">10.3</span><span class="hljs-number">.4</span>) is automatic and will be destroyed at the first opportunity.<br><span class="hljs-number">45.</span> No <span class="hljs-keyword">implicit</span> user-defined conversions are applied to the left-hand side of a `.` (or a `-&gt;`). This is the <span class="hljs-keyword">case</span> even when `.` is <span class="hljs-keyword">implicit</span>.<br><br>    For example:<br><br>    - ```C++<br>      void g(<span class="hljs-keyword">complex</span> z)<br>      &#123;<br>          <span class="hljs-number">3</span>+z; // Ok: <span class="hljs-keyword">complex</span>(<span class="hljs-number">3</span>)+z<br>          <span class="hljs-number">3.</span>operator+=(z); // Error: <span class="hljs-number">3</span> is not a <span class="hljs-keyword">class</span> object (no user-defined conversion)<br>          <span class="hljs-number">3</span>+=z; // Error: <span class="hljs-number">3</span> is not a <span class="hljs-keyword">class</span> object (. is <span class="hljs-keyword">implicit</span>)<br>      &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Thus, you can approximate tthe notion that an operator requires an lvaue as its left-hand operand by making that operator a member.</p>
<ul>
<li>However, that is only an approximation because it is possible to access a temporary with a modifying operation, such as <code>operator+=()</code>:</li>
<li>```C++<br>complex x{4,5};<br>complex z{sqrt(x)+={1,2}}; // like tmp=sqrt(x), tmp+={1,2}<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">      - If we don&#x27;t want implicit conversions, we can use `explicit` to suppress them.<br><br>#### <span class="hljs-number">18.3</span>.<span class="hljs-number">4</span> Literals<br><br><span class="hljs-number">46</span>. We have literals of built-in types.<br><br>    - For example, `1,<span class="hljs-number">2</span>` <span class="hljs-literal">and</span> `12e3` are literals of type `double`.<br><br>    For `complex`, we can come pretty close to that by declaring constructors `constexpr`.<br><br><span class="hljs-title">    - For example:</span><br><br>      - ```C++<br>        class complex&#123;<br><span class="hljs-title">        public:</span><br><span class="hljs-title">            constexpr complex(double r=0, double i=0) :</span>re&#123;r&#125;, im&#123;i&#125; &#123;&#125;<br>            // ...<br>        &#125;<br></code></pre></td></tr></table></figure></li>
<li>Given that, a <code>complex</code> can be constructed from its constituent parts at compile time just like a literal from a built-in type. For example:</li>
<li>```C++<br>complex z1{1,2,12e3};<br>constexpr complex z2{1.2,12e3}; // guaranteed compile-time initialization<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">    - When constructors are simple <span class="hljs-keyword">and</span> inline, <span class="hljs-keyword">and</span> especially when they are `constexpr`, it <span class="hljs-keyword">is</span> quite reasonable to think of constructor invocations <span class="hljs-keyword">with</span> literal arguments <span class="hljs-keyword">as</span> literals.<br><span class="hljs-number">47.</span> It <span class="hljs-keyword">is</span> possible to go further <span class="hljs-keyword">and</span> introduce a user-defined literal (section <span class="hljs-number">19.2</span><span class="hljs-number">.6</span>) <span class="hljs-keyword">in</span> support of our `<span class="hljs-built_in">complex</span>` <span class="hljs-built_in">type</span>.<br><br>    In particular, we could define `i` to be a suffix meaning <span class="hljs-string">&quot;imaginary.&quot;</span><br><br>    - For example:<br><br>      - ```c++<br>        constexpr <span class="hljs-built_in">complex</span>&lt;double&gt; operato<span class="hljs-string">r&quot;&quot;</span>i(long double d) // imaginary literal<br>        &#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,d&#125;; // <span class="hljs-built_in">complex</span> <span class="hljs-keyword">is</span> a literal <span class="hljs-built_in">type</span> (user-defined)<br>        &#125;<br></code></pre></td></tr></table></figure></li>
<li>This would allow us to wirte:</li>
<li>```C++<br>complex z1{1.2+12e3i};complex f(double d)<br>{<pre><code class="hljs">auto x&#123;2.3i&#125;;
return x+sqrt(d+12e3i)+12e3i;
</code></pre>
}<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fortran">- The user-defined literal gives us one advantage over what we get from `constexpr` constructors:<br><br>  - We can <span class="hljs-keyword">use</span> user-defined literals <span class="hljs-keyword">in</span> the middle of expressions <span class="hljs-keyword">where</span> `&#123;&#125;` notation can <span class="hljs-keyword">only</span> be used when qualified by a <span class="hljs-keyword">type</span> <span class="hljs-keyword">name</span>.<br>- The example above is roughly equivalent to:<br>- ```C++<br>  <span class="hljs-keyword">complex</span> z1&#123;<span class="hljs-number">1.2</span>,<span class="hljs-number">12e3</span>&#125;;<br>  <br>  <span class="hljs-keyword">complex</span> f(<span class="hljs-keyword">double</span> d)<br>  &#123;<br>      <span class="hljs-keyword">complex</span> x&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2.3</span>&#125;;<br>      <span class="hljs-keyword">return</span> x+<span class="hljs-built_in">sqrt</span>(<span class="hljs-keyword">complex</span>&#123;d,<span class="hljs-number">12e3</span>&#125;)+<span class="hljs-keyword">complex</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">12e3</span>&#125;;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>I suspect that the choice of style of literal depends on your sense of aesthetics and the conventions of your field of work.</p>
<p>The standard-library <code>complex</code> uses <code>constexpr</code> constructors rather that a user-defined literal.</p>
</li>
</ol>
<h4 id="18-3-5-Accessor-Functions"><a href="#18-3-5-Accessor-Functions" class="headerlink" title="18.3.5 Accessor Functions"></a>18.3.5 Accessor Functions</h4><ol start="50">
<li><p>So far, we have provided class <code>complex</code> with constructors and arithmetic operators only.</p>
<p>In particular, we often need to be able to examine and change the value of the real and imaginary parts:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">compelx</span>&#123;<br>	<span class="hljs-type">double</span> re, im;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> re;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> im;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">real</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123;re = r;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">double</span> i)</span> </span>&#123;im = i;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>I don’t consider it a good idea to provide individual access to all members of a class; in general, it is not.</p>
<ul>
<li>For many types, individual access (sometimes referred to as <em>get-and-set functions</em>) is an invitation to disaster.</li>
<li>If we are not careful, individual access could compromise an invariant, and it typically complicates changes to the representation.</li>
<li>For example:<ul>
<li>consider the opportunities for misuse from providing getters and setters for every member of the <code>Date</code> from section 16.3 or (even more so) for the <code>String</code> from section 19.3.</li>
</ul>
</li>
</ul>
</li>
<li><p>However, for <code>complex</code>, <code>real()</code> and <code>imag()</code> are sematically significant:</p>
<ul>
<li><p>Some algorithms are most cleanly written if they can set the real and imaginary parts independently.</p>
</li>
<li><p>For example:</p>
<ul>
<li>Given <code>real()</code> and <code>imag()</code>, we can simplify simple, common, and useful operations, such as <code>==</code>, as nonmember functions (without compromising performance).</li>
<li>```c++<br>inline bool operator==(complex a, complex b)<br>{<pre><code class="hljs">return a.real()==b.real() &amp;&amp; a.imag()==b.imag();
</code></pre>
}<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>#### <span class="hljs-number">18.3</span><span class="hljs-number">.6</span> Helper Functions<br><br><span class="hljs-number">51.</span> If we put all the bits <span class="hljs-keyword">and</span> pieces together, the `complex` <span class="hljs-keyword">class</span> <span class="hljs-title class_">becomes</span>:<br><br>    ```C++<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>    	<span class="hljs-type">double</span> re, im;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">double</span> r=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> i=<span class="hljs-number">0</span>)</span> : re(r), im(i) &#123;</span>&#125;<br>    <br>        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im;&#125;<br>    <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">real</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123; re = r;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">double</span> i)</span> </span>&#123; im = i;&#125;<br>    <br>        complex&amp; <span class="hljs-keyword">operator</span>+=(complex);<br>        complex&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">double</span>);<br>    <br>        <span class="hljs-comment">// -=, *= and /=</span><br>    &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In addition, we must provide a number of helper functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(complex, compelx);<br>complex <span class="hljs-keyword">operator</span>+(complex, <span class="hljs-type">double</span>);<br>complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span>, complex);<br><br><span class="hljs-comment">// binary -,*, and /</span><br><br>complex <span class="hljs-keyword">operator</span>-(complex); <span class="hljs-comment">// unary minus</span><br>complex <span class="hljs-keyword">operator</span>+(complex); <span class="hljs-comment">// unary plus</span><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(compelx, complex);<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(complex, complex);<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; complex&amp;); <span class="hljs-comment">//input</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;, complex); <span class="hljs-comment">// output</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Note that the members <code>real()</code> and <code>imag()</code> are essential for defining the comparisons.</li>
<li>The definitions of most of the following helper functions similarly rely on <code>real()</code> and <code>imag()</code>.</li>
</ul>
</li>
<li><p>We might provide functions to allow users to think in terms of polar coordinates:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">complex <span class="hljs-title">polar</span><span class="hljs-params">(<span class="hljs-type">double</span> rho, <span class="hljs-type">double</span> theta)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">conj</span><span class="hljs-params">(complex)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">abs</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">arg</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">norm</span><span class="hljs-params">(complex)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">(complex)</span></span>; <span class="hljs-comment">// for notational convenience</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(complex)</span></span>; <span class="hljs-comment">// for notational convenience</span><br></code></pre></td></tr></table></figure></li>
<li><p>Finally, we must provide an appropriate set of standard mathematical functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">complex <span class="hljs-title">acos</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">asin</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">atan</span><span class="hljs-params">(complex)</span></span>;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure></li>
<li><p>From a user’s point of view, the <code>complex</code> type presented here is almost identical to the <code>complex&lt;double&gt;</code> found in <code>&lt;complex&gt;</code> in the standard library.</p>
</li>
</ol>
<h3 id="18-4-Type-Conversion"><a href="#18-4-Type-Conversion" class="headerlink" title="18.4 Type Conversion"></a>18.4 Type Conversion</h3><ol start="55">
<li><p>Type conversion can be accomplished by:</p>
<ul>
<li>A constructor taking a single argument</li>
<li>A conversion operator</li>
</ul>
<p>In either case the conversion can be</p>
<ul>
<li><code>explicit</code>;<ul>
<li>that is, the conversion is only performed in a direct initialization, i.e., as an initialier not using a <code>=</code>.</li>
</ul>
</li>
<li>Implicit;<ul>
<li>that is, it will be applied wherever it can be used unambiguously, e.g., as a function argument.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="18-4-1-Conversion-Operators"><a href="#18-4-1-Conversion-Operators" class="headerlink" title="18.4.1 Conversion Operators"></a>18.4.1 Conversion Operators</h4><ol start="56">
<li><p>Using a constructor taking a single argument to specify type conversion is convenient but has implications that can be undesirable.</p>
<p>Also, a constructor cannot specify</p>
<ul>
<li>an implicit conversion from a user-defined type to a built-in type (because the built-in types are not classes), or</li>
<li>a conversion from a new class to a previously defined class (without modifying the declaration for the old class).</li>
</ul>
<p>These problems can be handled by defining a <em><strong>conversion operator</strong></em> for the source type.</p>
<ul>
<li><p>A member function <code>X::operator T()</code>, where <code>T</code> is a type name, defines a conversion from <code>X</code> to <code>T</code>.</p>
<ul>
<li><p>For example, we could define a 6-bit non-negative integer, <code>Tingy</code>, that can mix freely with integers in arithmetic operations. <code>Tiny</code> throws <code>Bad_range</code> if its operations overflow or underflow:</p>
</li>
<li><p>```C++<br>class Tiny{</p>
<pre><code class="hljs">char v;
void assign(int i) &#123; if(i&amp;~077) throw Bad_range(); v=i;&#125;
</code></pre>
<p>public:</p>
<pre><code class="hljs">class Bad_range();

Tiny(int i) &#123; assign(i);&#125;
Tiny&amp; operator=(int i) &#123; assign(i); return *this;&#125;

operator int() const &#123; return v;&#125; // conversion to int function
</code></pre>
<p>};</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><br>  - The <span class="hljs-built_in">range</span> is checked whenever a `<span class="hljs-built_in">Tiny</span>` is initialized by an `<span class="hljs-built_in">int</span>` and whenever an `<span class="hljs-built_in">int</span>` is assigned to one.<br>  - No <span class="hljs-built_in">range</span> check is needed when we copy a `<span class="hljs-built_in">Tiny</span>`, so the <span class="hljs-keyword">default</span> copy constructor and assignment are just right.<br>- To enable the usual <span class="hljs-keyword">integer</span> operations on `<span class="hljs-built_in">Tiny</span>` variables, we define the <span class="hljs-keyword">implicit</span> conversion from `<span class="hljs-built_in">Tiny</span>` to `<span class="hljs-built_in">int</span>`, `<span class="hljs-built_in">Tiny</span>::operator <span class="hljs-built_in">int</span>()`.<br>- Note that the <span class="hljs-keyword">type</span> being converted to is part of the <span class="hljs-keyword">name</span> of the operator and cannot be repeated as the <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> of the conversion <span class="hljs-function"><span class="hljs-keyword">function</span></span>:<br><br>  - ```C++<br>    <span class="hljs-built_in">Tiny</span>::operator <span class="hljs-built_in">int</span>() const &#123; <span class="hljs-keyword">return</span> v;&#125; // right<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">Tiny</span>::operator <span class="hljs-built_in">int</span>() const &#123; <span class="hljs-keyword">return</span> v;&#125; // error<br></code></pre></td></tr></table></figure>
<ul>
<li>In this respect also, a conversion operator resembles a constructor. (constructor also doesn’t have a return type)</li>
</ul>
</li>
<li><p>Whenever a <code>Tiny</code> appears where an <code>int</code> is needed, the appropriate <code>int</code> is used. For example:</p>
<ul>
<li>```C++<br>int main()<br>{<pre><code class="hljs">Tiny c1 = 2;
Tiny c2 = 62;
Tiny c3 = c2 - c1; // c3 = 60
Tiny c4 = c3; // no range check (not necessary)
int i = c1 + c2; // i = 64

c1 = c1+c2; // range error: c1 can&#39;t be 64 (6-bit non-negative integer)
i = c3-64; // i = -4
c2 = c3-64; // range error: c2 can&#39;t be -4
c3 = c4; // no range check (not necessary)
</code></pre>
}<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-number">57</span>. Conversion functions appear <span class="hljs-keyword">to</span> be particularly useful <span class="hljs-keyword">for</span> handling data structures <span class="hljs-keyword">when</span> reading (implemented <span class="hljs-keyword">by</span> a conversion <span class="hljs-keyword">operator</span>) <span class="hljs-built_in">is</span> trivial, <span class="hljs-keyword">while</span> assignment <span class="hljs-built_in">and</span> initialization are distinctly less trivial.<br><span class="hljs-number">58</span>. The `istream` <span class="hljs-built_in">and</span> `ostream` types rely <span class="hljs-keyword">on</span> a conversion <span class="hljs-keyword">function</span> <span class="hljs-keyword">to</span> enable statements such <span class="hljs-keyword">as</span>:<br><br>    ```C++<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;x)<br>        cout&lt;&lt;x;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>The input operation <code>cin&gt;&gt;x</code> returns an <code>istream&amp;</code>. That value is implicitly converted to a value indicating the state of <code>cin</code>. This value can then be tested by the <code>while</code>.</p>
</li>
<li><p>However, it is typically <em><strong>not</strong></em> a good idea to define an implicit conversion from one type to another in such a way that information is lost in the conversion.</p>
</li>
</ul>
</li>
<li><p>In general, it is wise to be sparing in the introduction of conversion operators.</p>
<ul>
<li>When used in excess, they lead to ambiguities. Such ambiguities are caught by the compiler, but they can be a nuisance to resolve.</li>
<li>Probably the best idea is initially to do conversions by named functions, such as <code>X::make_int()</code>.<ul>
<li>If such a function becomes popular enough to make explicit use inelegant, it can be replaced by a conversion operator <code>X::operator int()</code>.</li>
</ul>
</li>
</ul>
</li>
<li><p>If both user-defined conversions and user-defined operators are defined, it is possible to get ambiguities between the user-defined operators and the built-in operators. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(Tiny, Tiny);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Tiny t, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    t+i; <span class="hljs-comment">// Error, ambiguous: &quot;operator+(t,Tiny(i))&quot; or &quot;int(t)+i&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="18-4-2-explicit-Conversion-Operators"><a href="#18-4-2-explicit-Conversion-Operators" class="headerlink" title="18.4.2 explicit Conversion Operators"></a>18.4.2 <code>explicit</code> Conversion Operators</h4><ol start="61">
<li><p>Conversion operators tend to be defined so that they can be used everywhere.</p>
<p>However, it is possible to declare a conversion operator <code>explicit</code> and have it apply only for direct initialization, where an equivalent <code>explicit</code> constructor would have beed used.</p>
<ul>
<li><p>For example, the standard-library <code>unique_ptr</code> has an explicit conversion to <code>bool</code>:</p>
</li>
<li><p>```C++<br>template&lt;typename T, typename D = default_delete<T>&gt;<br>class unique_ptr{<br>public:</p>
<pre><code class="hljs">// ...
explicit operator bool() const noexcept; // dose *this hold a pointer(that is not nullptr)?
</code></pre>
<p>};</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- The reason to declare <span class="hljs-keyword">this</span> conversion <span class="hljs-keyword">operator</span> `<span class="hljs-keyword">explicit</span>` is to avoid its use in surprising contexts. Consider:<br><br>  - ```C++<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">(unique_ptr&lt;Record&gt; p, unique_ptr&lt;<span class="hljs-type">int</span>&gt; q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!p) <span class="hljs-comment">// Ok: We want this use</span><br>            <span class="hljs-keyword">throw</span> Invalid_unique_ptr&#123;&#125;;<br>    <br>        <span class="hljs-type">bool</span> b = p; <span class="hljs-comment">// error; suspicious use</span><br>        <span class="hljs-type">int</span> x = p+q; <span class="hljs-comment">// error; we definitly don&#x27;t want this</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>Had <code>unique_ptr</code>‘s conversion to bool not been <code>explicit</code>, the last two definitions would have compiled.</p>
<ul>
<li>The value of <code>b</code> would have become <code>true</code> and the value of <code>x</code> would have become <code>1</code> or <code>2</code> (depending on whether <code>q</code> was valid or not).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="18-4-3-Ambiguities"><a href="#18-4-3-Ambiguities" class="headerlink" title="18.4.3 Ambiguities"></a>18.4.3 Ambiguities</h4><ol start="62">
<li><p>An assignment of a value of type <code>V</code> to an object of class <code>X</code> is legal if there is an assignment operator <code>X::operator=(Z)</code> so that <code>v</code> is <code>Z</code> or there is a unique conversion of <code>V</code> to <code>Z</code>.</p>
<ul>
<li>Initialization is treated equivalently.</li>
</ul>
</li>
<li><p>In some cases, a value if the desired type can be constructed by repeated use of constructors or conversion operators.</p>
<ul>
<li>This must be handled by explicit conversions; only one level of user-defined implicit conversion is legal.</li>
</ul>
<p>In some cases, a value of the desired type can be constructed in more than one way; such cases are illegal. For example:</p>
<ul>
<li>```C++<br>class X{ /<em>…</em>/ X(int); X(const char*);};<br>class Y{ /<em>…</em>/ Y(int);};<br>class Z{/<em>…</em>/ Z(int);};X f(X);<br>Y f(Y);Z g(Z);void k1()<br>{<pre><code class="hljs">f(1); // Error: ambiguous f(X(1)) or f(Y(1))?
f(X(1)); // OK
f(Y(1)); // OK

g(&quot;Mack&quot;); // Error:two user-defined conversions needed; g(Z&#123;X&#123;&quot;Mack&quot;&#125;&#125;) not tried
g(X&#123;&quot;Doc&quot;&#125;); // OK: g(Z&#123;X&#123;&quot;Doc&quot;&#125;&#125;)
g(Z&#123;&quot;Suzy&quot;&#125;); // OK: g(Z&#123;X&#123;&quot;Suzy&quot;&#125;&#125;)
</code></pre>
}<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">64.</span> User-<span class="hljs-function">defined conversions are considered only <span class="hljs-keyword">if</span> a call cannot be resolved without <span class="hljs-title">them</span> (<span class="hljs-params">i.e., <span class="hljs-keyword">using</span> only built-<span class="hljs-keyword">in</span> conversions</span>). For example:</span><br><span class="hljs-function"></span><br><span class="hljs-function">    - ```C++</span><br><span class="hljs-function">      <span class="hljs-keyword">class</span> XX</span>&#123;<span class="hljs-comment">/*...*/</span> XX(<span class="hljs-built_in">int</span>);&#125;;<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span>(<span class="hljs-params"><span class="hljs-built_in">double</span></span>)</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span>(<span class="hljs-params">XX</span>)</span>;<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">k2</span>()</span><br>      &#123;<br>          h(<span class="hljs-number">1</span>); <span class="hljs-comment">// h(double&#123;1&#125;) or h(XX&#123;1&#125;)? h(double&#123;1&#125;)!</span><br>      &#125;<br></code></pre></td></tr></table></figure></li>
<li>The call <code>h(1)</code> means <code>h(double(1))</code> because that alternative uses only a standard conversion rather than a user-defined conversion.</li>
</ul>
</li>
<li><p>The rules for conversion are neither the simplest to implement, nor the simplest to document, nor the most general that could be devised.</p>
<p>They are, however, considerably safer, and the resulting resolutions are typically less surprising than alternatives.</p>
<p>It is far easier to manually resolve an ambiguity than to find an error caused by an unsuspected conversion.</p>
</li>
<li><p>The insistence on strict bottom-up analysis implies that the return type is not used in overloading function. For example:</p>
<ul>
<li>```C++<br>class Quad{<br>public:<pre><code class="hljs">Quad(double);
// ...
</code></pre>
};Quad operator+(Quad,Quad); // the return type of + is Quadvoid f(double a1, double a2)<br>{<pre><code class="hljs">Quad r1 = a1+a2; // double-precision floating-point add (the return type Quad of + is not used.)
Quad r2 = Quad&#123;a1&#125;+a2; // force quad arithmetic
</code></pre>
}<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- The reason <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> design choice is partly that strict bottom-up analysis is more comprehensible <span class="hljs-keyword">and</span> partly that it is <span class="hljs-keyword">not</span> considered the compiler<span class="hljs-number">&#x27;</span>s job to decide which precision the programmer might want <span class="hljs-keyword">for</span> the addition.<br><br>Once the types of both sides of an initialization <span class="hljs-keyword">or</span> assignment have been determined, both types are used to resolve the initialization <span class="hljs-keyword">and</span> assignment. For example:<br><br>- ```C++<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Real</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span></span>;<br>      <span class="hljs-comment">// ...</span><br>  &#125;;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Real a)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-type">double</span> d = a; <span class="hljs-comment">// d = a.double();</span><br>      <span class="hljs-type">int</span> i = a; <span class="hljs-comment">// i = a.int();</span><br>  <br>      d = a; <span class="hljs-comment">// d = a.double();</span><br>      i = a; <span class="hljs-comment">// i = a.int();</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>In these cases, the type analysis is still bottom-up, with only a single operator and its argument types considered at any one time.</li>
</ul>
</li>
</ol>
<h3 id="18-5-Advice"><a href="#18-5-Advice" class="headerlink" title="18.5 Advice"></a>18.5 Advice</h3><ol>
<li>Define operators primarily to mimic conventional usage.</li>
<li>Redefine or prohibit copying if the default is not appropriate for a type.</li>
<li>For large operands, use <code>const</code> reference argument type.</li>
<li>For large results, use a move constructor.</li>
<li>Prefer member functions over nonmembers for operations that need access to the representation.</li>
<li>Prefer nonmember functions over members for operations that do not need access to the represention.</li>
<li>Use namespaces to associate helper functions with “their” class.</li>
<li>Use nonmember functions for symmetric operators.</li>
<li>Use member functions to express operators that require an lvalue as their left-hand operand.</li>
<li>Use user-defined literals to mimic conventional notation.</li>
<li>Provide “<code>set()</code> and <code>get()</code> functions” for a data member only if the fundamental semantics of a class require them.</li>
<li>Be cautious about introducing implicit conversions.</li>
<li>Avoid value-destroying (“narrowing”) conversions.</li>
<li>Do not define the same conversion as both a constructor and a conversion operator. (60)</li>
</ol>
<h2 id="Chapter-19-Special-Operators"><a href="#Chapter-19-Special-Operators" class="headerlink" title="Chapter 19. Special Operators"></a>Chapter 19. Special Operators</h2><ul>
<li>Introduction</li>
<li>Special Operators<ul>
<li>Subscripting</li>
<li>Function Call</li>
<li>Dereferencing</li>
<li>Increment and Decrement</li>
<li>Allocation and Deallocation</li>
<li>User-Defined Literals</li>
</ul>
</li>
<li>A String Class<ul>
<li>Essential Operations</li>
<li>Access to Charactors</li>
<li>Representation</li>
<li>Member Functions</li>
<li>Helper Functions</li>
<li>Using Our String</li>
</ul>
</li>
<li>Friends<ul>
<li>Finding Friends</li>
<li>Friends and Members</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="19-1-Introduction"><a href="#19-1-Introduction" class="headerlink" title="19.1 Introduction"></a>19.1 Introduction</h3><ol>
<li>Overloading is not just arithmetic and logical operations.<ul>
<li>In fact, operators are crucial in the design of:<ul>
<li>containers (e.g., <code>vector</code> and <code>map</code>)</li>
<li>“smart pointer”(e.g., <code>unique_ptr</code> and <code>shared_ptr</code>)</li>
<li>iterators</li>
<li>other classes concerned with resource management.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="19-2-Special-Operators"><a href="#19-2-Special-Operators" class="headerlink" title="19.2 Special Operators"></a>19.2 Special Operators</h3><ol start="2">
<li>Special operators <code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>++</code>, <code>--</code>, <code>new</code>, <code>delete</code> are special only in that the mapping from their use in the code to a programmer’s definition differs slightly from that used for conventional unary and binary operators, such as <code>+</code>, <code>&lt;</code>, and <code>~</code>.<ul>
<li>The <code>[]</code>(subscript) and <code>()</code>(call) operators are among the most useful user-defined operators.</li>
</ul>
</li>
</ol>
<h4 id="19-2-1-Subscripting"><a href="#19-2-1-Subscripting" class="headerlink" title="19.2.1 Subscripting"></a>19.2.1 Subscripting</h4><ol start="3">
<li><p>An <code>operator[]</code> function can be used to give subscripts a meaning for class objects.</p>
<p>The second argument (the subscript) of an <code>operator[]</code> function may be of any type.</p>
<p>This makes it possible to define <code>vector</code>s, associative arrats, etc.</p>
<ul>
<li><p>As an example, we can define a simple associative array type like this:</p>
</li>
<li><p>```C++<br>struct Assoc{</p>
<pre><code class="hljs">vector&lt;pair&lt;string,int&gt;&gt; vec; // vector of &#123;name,value&#125; pairs

const int&amp; operator[](const string &amp;) const; // return reference to const element
int&amp; operator[](const string&amp;); // return reference to element
</code></pre>
<p>};</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>  - An `Assoc` keeps a vector of `std::pair`s.<br>- The implementation uses the same trivial <span class="hljs-keyword">and</span> inefficient search method.<br>- ```C++<br>  <span class="hljs-type">int</span>&amp; Assoc::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> string&amp; s)<br>      <span class="hljs-comment">// search for s; return a reference to it value if found</span><br>      <span class="hljs-comment">// otherwise, make a new pair &#123;s,0&#125; and return a reference to its value</span><br>  &#123;<br>  	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : vec)<br>          <span class="hljs-keyword">if</span>(s == x.first) <span class="hljs-keyword">return</span> x.second;<br>  <br>      vec.<span class="hljs-built_in">push_back</span>(&#123;s,<span class="hljs-number">0</span>&#125;); <span class="hljs-comment">// initial value:0</span><br>  <br>      <span class="hljs-keyword">return</span> vec.<span class="hljs-built_in">back</span>().second; <span class="hljs-comment">// return last element</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>We can use <code>Assoc</code> like this:</p>
</li>
<li><p>```C++<br>int main() // count the occurrences of each word on input<br>{</p>
<pre><code class="hljs">Assoc values;
string buf;
while(cin&gt;&gt;buf) ++values[buf];
for(auto x : values.vec)
    cout &lt;&lt; &quot;&#123;&quot; &lt;&lt; x.first &lt;&lt; &quot;,&quot; &lt;&lt; x.second &lt;&lt; &quot;&#125;\n&quot;;
</code></pre>
<p>}</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">   - The standard-library `map` <span class="hljs-keyword">and</span> `unordered_map` are further developments of the idea of an associative array <span class="hljs-keyword">with</span> less naive implementations.<br><span class="hljs-number">4.</span> An `<span class="hljs-keyword">operator</span>[]()` must be a non-<span class="hljs-keyword">static</span> member function.<br><br><span class="hljs-meta">#### 19.2.2 Function Call</span><br><br><span class="hljs-number">5.</span> Function call, that <span class="hljs-keyword">is</span> the notation ***expression(expression-list)***, can be interpreted <span class="hljs-keyword">as</span> a binary operation <span class="hljs-keyword">with</span> the ***expression*** <span class="hljs-keyword">as</span> the left-hand operand <span class="hljs-keyword">and</span> the ***expression-list*** <span class="hljs-keyword">as</span> the right-hand operand.<br><span class="hljs-number">6.</span> The call <span class="hljs-keyword">operator</span>, `()`, can be overloaded <span class="hljs-keyword">in</span> the same way <span class="hljs-keyword">as</span> other operators can. For example:<br><br>   ```C++<br>   <span class="hljs-keyword">struct</span> Action&#123;<br>       <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">operator</span>()(<span class="hljs-params"><span class="hljs-built_in">int</span></span>)</span>;<br>       <span class="hljs-function">pair&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">operator</span>()(<span class="hljs-params"><span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span></span>)</span>;<br>       <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">operator</span>()(<span class="hljs-params"><span class="hljs-built_in">double</span></span>)</span>;<br>       <span class="hljs-comment">// ...</span><br>   &#125;;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params">Action act</span>)</span><br>   &#123;<br>       <span class="hljs-built_in">int</span> x = act(<span class="hljs-number">2</span>);<br>       auto y = act(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br>       <span class="hljs-built_in">double</span> z = act(<span class="hljs-number">2.3</span>)<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>An argument list for an <code>operator()()</code> is evaluated and checked according to the usual argument-passing-rules.</p>
</li>
</ul>
<p>Overloading the function call operator seems to be useful primarily for defining types that have only a single operation and for types for which one operation is predominant.</p>
<p>The <em><strong>call operator</strong></em> is also known as the <em><strong>application operator</strong></em>.</p>
</li>
<li><p>The most obvious and also the most important, use of the <code>()</code> operator is to provide the usual function call syntax for objects that in some way behave like functions.</p>
<p>An object that acts like a function is often call a <em><strong>function-liker object</strong></em> or simply a <em><strong>function object</strong></em>.</p>
<ul>
<li><p>Such function objects allow us to write code that takes nontrivial operations as parameters.</p>
</li>
<li><p>In many cases, it is essential that function objects can hold data needed to perform their operation.</p>
</li>
<li><p>For example, we can define a class with an <code>operator()()</code> that adds a stored value to its argument:</p>
<ul>
<li><p>```C++<br>class Add{</p>
<pre><code class="hljs">complex val;
</code></pre>
<p>public:</p>
<pre><code class="hljs">Add(complex c) :val(c) &#123;&#125; // save a value
Add(double r, double i): val&#123;&#123;r,i&#125;&#125; &#123;&#125;

void operator()(complex&amp; c) const &#123;c += val;&#125; // add a value to argument
</code></pre>
<p>};</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- An <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">class</span> `Add` is initialized <span class="hljs-keyword">with</span> a complex number, <span class="hljs-keyword">and</span> <span class="hljs-keyword">when</span> invoked using `<span class="hljs-literal">()</span>`, it  adds that number <span class="hljs-keyword">to</span> its argument. For example:<br>- ```C++<br>  void h(vector&lt;complex&gt;&amp; vec, <span class="hljs-built_in">list</span>&lt;complex&gt;&amp; lst, complex z)<br>  &#123;<br>      <span class="hljs-keyword">for</span><span class="hljs-constructor">_each(<span class="hljs-params">vec</span>.<span class="hljs-params">begin</span>()</span>,vec.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,Add&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br>      <span class="hljs-keyword">for</span><span class="hljs-constructor">_each(<span class="hljs-params">lst</span>.<span class="hljs-params">begin</span>()</span>,lst.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>,Add&#123;z&#125;)<br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>This will add <code>complex&#123;2,3&#125;</code> to every element of the <code>vector</code> and <code>z</code> to every element of the <code>list</code>.</p>
<ul>
<li>Note that Add{z} constructs an object that is used repeatedly by <code>for_each()</code>:  <code>Add&#123;z&#125;</code>‘s <code>operator()()</code> is called for each element of the sequence.</li>
</ul>
</li>
<li><p>This all works because <code>for_each</code> is a template that applies <code>()</code> to its third argument without caring exactly what that third argument really is:</p>
<ul>
<li>```C++<br>template&lt;typename Iter, typename Fct&gt;<br>Fct for_each(Iter b, Iter e, Fct f)<br>{<pre><code class="hljs">while(b != e) f(*b++);
return f;
</code></pre>
}<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">         - At <span class="hljs-built_in">first</span> glance, this technique may look esoteric, but it <span class="hljs-built_in">is</span> simple, efficient, <span class="hljs-keyword">and</span> extremely useful.<br><span class="hljs-number">8</span>. Note that a <span class="hljs-built_in">lambda</span> expression (section <span class="hljs-number">3.4</span><span class="hljs-number">.3</span>, section <span class="hljs-number">11.4</span>) <span class="hljs-built_in">is</span> basically a syntax <span class="hljs-keyword">for</span> defining a function object. For <span class="hljs-built_in">example</span>, we  could have written:<br><br>   ```C++<br>   void h2(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">complex</span>&gt;&amp; vec, list&lt;<span class="hljs-built_in">complex</span>&gt;&amp; lst, <span class="hljs-built_in">complex</span> z)<br>   &#123;<br>       for_each(vec.begin(),vec.end(),[](<span class="hljs-built_in">complex</span>&amp; a)&#123; a+=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;&#125;);<br>       for_each(lst.begin(),lst.end(),[](<span class="hljs-built_in">complex</span>&amp; a)&#123; a+=z;&#125;);<br>   &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>In this case, each of the lambda expressions generates the equivalent of the function object <code>Add</code>.</p>
</li>
</ul>
</li>
<li><p>Other popular uses of <code>operator()()</code> are as a substring operator and as a subscripting operator for multidimensional arrays.</p>
</li>
<li><p>An <code>operator()()</code> must be a non-<code>static</code> member function.</p>
</li>
<li><p>Function call operators are often templates.</p>
</li>
</ol>
<h4 id="19-2-3-Dereferencing"><a href="#19-2-3-Dereferencing" class="headerlink" title="19.2.3 Dereferencing"></a>19.2.3 Dereferencing</h4><ol start="12">
<li><p>The dereferencing operator, <code>-&gt;</code> (also known as the <em><strong>arrow</strong></em> operator), can be defined as a unary postfix operator. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ptr</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    X* <span class="hljs-keyword">operator</span>-&gt;();<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>Objects of class <code>Ptr</code> can be used to access members of class <code>X</code> in a very similar manner to the way pointers are used. For example:</li>
<li>```C++<br>void f(Ptr p)<br>{<pre><code class="hljs">p-&gt;m = 7; // (p.operator-&gt;())-&gt;m = 7
</code></pre>
}<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl"><br>- T<span class="hljs-function"><span class="hljs-title">he</span> transformation of the object `p` into the pointer `p.operator-&gt;</span>()` does <span class="hljs-built_in">not</span> depend on the member `m` pointed to.<br>- T<span class="hljs-function"><span class="hljs-title">hat</span> <span class="hljs-keyword">is</span> the sense <span class="hljs-built_in">in</span> which `operator-&gt;</span>()` <span class="hljs-keyword">is</span> a unary <span class="hljs-keyword">postfix</span> operator.<br>- H<span class="hljs-function"><span class="hljs-title">owever</span>, there <span class="hljs-keyword">is</span> no new syntax introduced, so a member <span class="hljs-keyword">name</span> <span class="hljs-keyword">is</span> still required after the `-&gt;</span>`. For example:<br><br>  - ```C++<br>    void g(Ptr p)<br>    &#123;<br>        X* <span class="hljs-function"><span class="hljs-title">q1</span> = p-&gt;</span>; <span class="hljs-comment">// sytax error</span><br>        X* <span class="hljs-function"><span class="hljs-title">q2</span> = p.operator-&gt;</span>(); <span class="hljs-comment">// OK</span><br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Overloading <code>-&gt;</code> is primarily useful for creating “smart pointers,” that is, objects that act like pointers and in addition perform some action whenever an object is accessed through them.</p>
<ul>
<li>The standard-library “smart pointers” <code>unique_ptr</code> and <code>shared_ptr</code> provide operator <code>-&gt;</code>.</li>
</ul>
</li>
<li><p>As an example, we could define a class <code>Disk_ptr</code> for accessing objects stored on disk.</p>
<ul>
<li><code>Disk_ptr</code>‘s constructor takes a name that can be used to find the object on disk,</li>
<li><code>Disk_ptr::operator-&gt;()</code> brings the object into main memory when accessed through its <code>Disk_ptr</code>,</li>
<li>and <code>Disk_ptr</code>‘s destructor eventually writes the updated object back out to desk.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Disk_ptr</span>&#123;<br>    string identifier;<br>    T* in_core_address;<br>	<span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Disk_ptr</span>(<span class="hljs-type">const</span> string&amp; s) : identifier&#123;s&#125;, in_core_address&#123;<span class="hljs-literal">nullptr</span>&#125; &#123;&#125;<br>    ~<span class="hljs-built_in">Disk_ptr</span>()&#123; <span class="hljs-built_in">write_to_disk</span>(in_core_address,identifier);&#125;<br><br>    T* <span class="hljs-keyword">operator</span>-&gt;()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(in_core_address == <span class="hljs-literal">nullptr</span>)<br>            in_core_address = <span class="hljs-built_in">read_from_disk</span>(identitier);<br>        <span class="hljs-keyword">return</span> in_core_address;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>Disk_ptr</code> might be used like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rec</span>&#123;<br>    string name;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>    Disk_ptr&lt;Rec&gt; p&#123;s&#125;; <span class="hljs-comment">// get Disk_ptr for s</span><br><br>    p-&gt;name = <span class="hljs-string">&quot;Roscoe&quot;</span>; <span class="hljs-comment">// update s; if necessary, first retrieve from disk</span><br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-comment">// p&#x27;s destructor writes back to disk</span><br></code></pre></td></tr></table></figure>

<p>Naturally, a realistic program would contain error-handling code and use a less naive way of interacting with the disk.</p>
</li>
<li><p>For ordinary pointers, use of <code>-&gt;</code> is synonymous with some uses of unary <code>*</code> and <code>[]</code>.</p>
<p>Given a class <code>Y</code> for which <code>-&gt;</code>, <code>*</code> and <code>[]</code> have their default meaning and a <code>Y*</code> called <code>p</code>, then:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">p-&gt;m == (*p).m; <span class="hljs-comment">// is true</span><br>(*p).m == p[<span class="hljs-number">0</span>].m; <span class="hljs-comment">// is true</span><br>p-&gt;m == p[<span class="hljs-number">0</span>].m; <span class="hljs-comment">// is true</span><br></code></pre></td></tr></table></figure>

<ul>
<li>As usual, no such guarantee is provided for user-defined operators.</li>
</ul>
<p>The equivalence can be provided where desired:</p>
<ul>
<li><p>```C++<br>template<typename T><br>class Ptr{</p>
<pre><code class="hljs">Y* p;
</code></pre>
<p>public:</p>
<pre><code class="hljs">Y* operator-&gt;() &#123; return p;&#125; // dereference to access member
Y&amp; operator*() &#123; return *p;&#125; // dereference to access whole object
Y&amp; operator[](int i) &#123; return p[i];&#125; // dereference to access element
</code></pre>
<p>};</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>    If you provide more than one of these operators, it might be wise to provide the equivalence, just as it is wise to ensure that `++x` <span class="hljs-literal">and</span> `x+=<span class="hljs-number">1</span>` have the same effect as `x=x+<span class="hljs-number">1</span>` for a simple variable `x` of some class `X` is `++`, `+=`, `=`, <span class="hljs-literal">and</span> `+` are provided.<br><span class="hljs-number">16</span>. The overloading of `-&gt;` is important to a class of interesting programs <span class="hljs-literal">and</span> is <span class="hljs-literal">not</span> just a minor curiosity.<br><br>    The reason is that ***indirection*** is a key concept <span class="hljs-literal">and</span> that overloading `-&gt;` provides a clean, direct, <span class="hljs-literal">and</span> efficient way of representing indirection in a program.<br><br>    - Iterators (Chapter <span class="hljs-number">33</span>) provide an important example of this.<br><span class="hljs-number">17</span>. Operator `-&gt;` must be a non-`static` member function.<br><br>    If used, it <span class="hljs-keyword">return</span> type must be a pointer <span class="hljs-literal">or</span> an object of a class to which you can apply `-&gt;`.<br><br>    The body of a template class member function is only checked if the function is used (section <span class="hljs-number">26.2</span>.<span class="hljs-number">1</span>), so we can define `operator-&gt;()` without worrying about types, such as `Ptr&lt;int&gt;`, for which `-&gt;` does <span class="hljs-literal">not</span> make sense.<br><span class="hljs-number">18</span>. Despite the similarity between `-&gt;` <span class="hljs-literal">and</span> `.` (dot), there is no way of overloading operator `.` (dot).<br><br>#### <span class="hljs-number">19.2</span>.<span class="hljs-number">4</span> Increment <span class="hljs-literal">and</span> Decrement<br><br><span class="hljs-number">19</span>. Once people invent <span class="hljs-string">&quot;smart pointers,&quot;</span> they often decide to provide the increment operator `++` <span class="hljs-literal">and</span> the decrement operator   `--` to mirror these operators&#x27; use for built-in types.<br><br>    - This is especially obvious <span class="hljs-literal">and</span> necessary where the aim is to replace an ordinary pointer type with a <span class="hljs-string">&quot;smart pointer&quot;</span> type that has the same semantics, except that it adds a bit of run-time error checking.<br><span class="hljs-title">    - For example, consider a troublesome traditional program:</span><br><br>      - ```C++<br>        void f1(X a) // traditional use<br>        &#123;<br>            X v[<span class="hljs-number">200</span>]<span class="hljs-comment">;</span><br>            X* p = &amp;v[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br>            p--<span class="hljs-comment">;</span><br>            *p = a<span class="hljs-comment">; // oops: p out of range, uncaught</span><br>            ++p<span class="hljs-comment">;</span><br>            ++p = a<span class="hljs-comment">; // OK</span><br>        &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>Here, we might want to replace the <code>X*</code> with an object of a class <code>Ptr&lt;X&gt;</code> that can be dereferenced only if it actually points to an <code>X</code>.</p>
<p>We would also like to ensure that <code>p</code> can be incremented and decremented only if it points to an object with an array and  the increment and decrement operations yield an object within that array.</p>
</li>
<li><p>That is, we would like something like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(Ptr&lt;X&gt; a)</span> <span class="hljs-comment">// checked</span></span><br><span class="hljs-function"></span>&#123;<br>    X v[<span class="hljs-number">200</span>];<br>    <span class="hljs-function">Ptr&lt;X&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;v[<span class="hljs-number">0</span>],v)</span></span>;<br>    p--;<br>    *p = a; <span class="hljs-comment">// run-time error: p out of range</span><br>    ++p;<br>    *p = a; <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The increment and decrement operators are unique among C++ operators in that they can be used as both prefix and postfix operators.</p>
<p>Consequently, we must define prefix and postfix increment and decrement for <code>Ptr&lt;T&gt;</code>. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ptr</span>&#123;<br>    T* ptr;<br>    T* array;<br>    <span class="hljs-type">int</span> sz;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;</span><br><span class="hljs-function">    	<span class="hljs-title">Ptr</span><span class="hljs-params">(T* p, T(&amp;a)[N])</span></span>; <span class="hljs-comment">// bind to array a, sz==N, initial value p</span><br>    <span class="hljs-built_in">Ptr</span>(T* p, T* a, <span class="hljs-type">int</span> s); <span class="hljs-comment">// bind to array a of size s, initial value p</span><br>    <span class="hljs-built_in">Ptr</span>(T* p); <span class="hljs-comment">// bind to single objectm, sz==0, initial value p</span><br><br>    Ptr&amp; <span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// prefix</span><br>    Ptr <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix</span><br><br>    Ptr&amp; <span class="hljs-keyword">operator</span>--(); <span class="hljs-comment">// prefix</span><br>    Ptr <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>); <span class="hljs-comment">// postfix</span><br><br>    T&amp; <span class="hljs-keyword">operator</span>*(); <span class="hljs-comment">// prefix</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>int</code> argument is used to indicate that the function is to be invoked for postfix application of <code>++</code>.<ul>
<li>This <code>int</code> is never used; the argument is simply a dummy used to distinguish between prefix and postfix application.</li>
<li>The way to remember which version of an <code>operator++</code> is prefix is to note that the version without the dummy argument is prefix, exactly like all the other unary arithmetic and logical operators.</li>
<li>The dummy argument is used only for the “odd” postfix <code>++</code> and <code>--</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Consider ommiting postfix <code>++</code> and <code>--</code> in a design. They are not only odd syntactically, they tend to be marginally harder to implement than the prefix versions, less efficient, and less frequently used.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Ptr&amp; Ptr&lt;T&gt;::<span class="hljs-keyword">operator</span>++() <span class="hljs-comment">// return current object after incrementing</span><br>&#123;<br>    <span class="hljs-comment">// ... check that ptr+1 can be pointed to ...</span><br>    <span class="hljs-keyword">return</span> *++ptr;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>Ptr Ptr&lt;T&gt;::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <span class="hljs-comment">// increment and return a Ptr with the old value</span><br>&#123;<br>    <span class="hljs-comment">// ... check that ptr+1 can be pointed to ...</span><br>    Ptr&lt;T&gt; old&#123;ptr,array,sz&#125;;<br>    ++ptr;<br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>The pre-increment operator can return a reference to its object.</li>
<li>The post-increment operator must make a new object to return.</li>
</ul>
</li>
<li><p>Using <code>Ptr</code>, the example is equivalent to:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(T a)</span> <span class="hljs-comment">// checked</span></span><br><span class="hljs-function"></span>&#123;<br>    T v[<span class="hljs-number">200</span>];<br>    <span class="hljs-function">Ptr&lt;T&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;v[<span class="hljs-number">0</span>],v,<span class="hljs-number">200</span>)</span></span>;<br>    p.<span class="hljs-keyword">operator</span>--(<span class="hljs-number">0</span>); <span class="hljs-comment">// suffix: p--</span><br>    p.<span class="hljs-keyword">operator</span>*() = a; <span class="hljs-comment">// run-time error: p out of range (prefix * --&gt; *p)</span><br>    p.<span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// prefix: ++p</span><br>    p.<span class="hljs-keyword">operator</span>*() = a; <span class="hljs-comment">// OK (prefix * --&gt; *p)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Completing class <code>Ptr</code> is left as an exercise.</p>
<p>A pointer template that behaves correctly with respect to inheritance is presented in section 27.2.2.</p>
</li>
</ol>
<h4 id="19-2-5-Allocation-and-Deallocation"><a href="#19-2-5-Allocation-and-Deallocation" class="headerlink" title="19.2.5 Allocation and Deallocation"></a>19.2.5 Allocation and Deallocation</h4><ol start="22">
<li><p>Operator <code>new</code> acquires its memory by calling an <code>operator new()</code>. Similarly, operator <code>delete</code> frees its memory by calling an <code>operator delete()</code>.</p>
<p>A user can redefine the global <code>operator new()</code> and <code>operator delete()</code> or define <code>operator new()</code> and <code>operator delete</code> for particular class.</p>
</li>
<li><p>Using the standard-library type alias <code>size_t</code> (section 6.2.8) for sizes, the declarations of the global versions look like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>; <span class="hljs-comment">// use for individual object</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>); <span class="hljs-comment">// use for array</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span></span>; <span class="hljs-comment">// use for individual object</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>); <span class="hljs-comment">// use for array</span><br><br><span class="hljs-comment">// for more versions, see section 11</span><br></code></pre></td></tr></table></figure>

<p>That is, when <code>new</code> needs memory on the free store for an object of type <code>X</code>, it calls <code>operator new(sizeof(X))</code>.</p>
<p>Similarly, when <code>new</code> needs memory on the free store for an array of <code>N</code> objects of type <code>X</code>, it calls <code>operator new[](N*sizeof(X))</code>.</p>
<p>A <code>new</code> expression may ask for more memory that is indicated by <code>N*sizeof(X)</code>, but it will always do so in terms of a number of characters (i.e., a number of bytes).</p>
</li>
<li><p>Replacing the global <code>operator new()</code> and <code>operator delete()</code> is not for the fainthearted and not recommended.</p>
<ul>
<li>After all, someone else might rely on some aspect of the default behavior or might even have supplied other versions of these function.</li>
</ul>
<p>A more selective, and often better, approach is to supply these operations for a specific class. This class might be the base for many derived classes.</p>
<ul>
<li><p>For example, we might like to have a class <code>Employee</code> provide a specialized allocator and deallocator for itself and all of its derived classes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span></span>;<br><br>    <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>);<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Member <code>operator new()</code>s and <code>operator delete()</code>s are implicitly <code>static</code> members.</p>
<ul>
<li>Consequently, they don’t have a <code>this</code> pointer and do not modify an object.</li>
<li>The provide storage that a constructor can initialize and a destructor can clean up.</li>
</ul>
</li>
<li><p>```C++<br>void* Employee::operator new(size_t s)<br>{</p>
<pre><code class="hljs">// allocate s bytes of memory and return a pointer to it
</code></pre>
<p>}</p>
<p>void Employee::operator delete(void* p, size_t s)<br>{</p>
<pre><code class="hljs">if(p)&#123; // delete only if p!=0; see section 11.2, section 11.2.3
    // assume p points to s bytes of memory allocated by Employee::operator new()
    // and free that memory for reuse
&#125;
</code></pre>
<p>}</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>    Deleting <span class="hljs-keyword">a</span> <span class="hljs-string">&quot;plain&quot;</span> `Employee` gives <span class="hljs-keyword">an</span> argument <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> `sizeof(Employee)`; deleting <span class="hljs-keyword">a</span> `Manager` derived <span class="hljs-built_in">from</span> `Employee` that does <span class="hljs-keyword">not</span> have its own `operator <span class="hljs-built_in">delete</span>()` gives <span class="hljs-keyword">an</span> argument <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> `sizeof(Manager)`.<br><br>    - This allows <span class="hljs-keyword">a</span> class-specific allocator <span class="hljs-built_in">to</span> avoid storing size information <span class="hljs-keyword">with</span> <span class="hljs-keyword">each</span> allocation.<br><br>    Naturally, <span class="hljs-keyword">a</span> class-specific allocator can store such information (<span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> general-purpose allocator must) <span class="hljs-keyword">and</span> ignore <span class="hljs-keyword">the</span> `size_t` argument <span class="hljs-built_in">to</span> `operator <span class="hljs-built_in">delete</span>()`.<br><br>    - However, doing so makes <span class="hljs-keyword">it</span> harder <span class="hljs-built_in">to</span> improve significantly <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">speed</span> <span class="hljs-title">and</span> <span class="hljs-title">memory</span> <span class="hljs-title">consumption</span> <span class="hljs-title">of</span> <span class="hljs-title">a</span> <span class="hljs-title">general-purpose</span> <span class="hljs-title">allocator</span>.<br><span class="hljs-number">26.</span> How does <span class="hljs-keyword">a</span> compiler know how <span class="hljs-built_in">to</span> supply <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> size <span class="hljs-built_in">to</span> `operator <span class="hljs-built_in">delete</span>()`?<br><br>    - The type specified <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> `<span class="hljs-built_in">delete</span>` operation matches <span class="hljs-keyword">the</span> type <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> object being `<span class="hljs-built_in">delete</span>`d.<br><br>    If we `<span class="hljs-built_in">delete</span>` <span class="hljs-keyword">an</span> object through <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> base class, that base class must have <span class="hljs-keyword">a</span> `virtual` destructor (section <span class="hljs-number">17.2</span><span class="hljs-number">.5</span>) <span class="hljs-keyword">for</span> correct size <span class="hljs-built_in">to</span> be given:<br><br>    ```C++<br>    Employee* p = <span class="hljs-built_in">new</span> Manager;<span class="hljs-comment"> // potential trouble (the exact type is lost)</span><br>   <span class="hljs-comment"> // ... </span><br>    <span class="hljs-built_in">delete</span> p;<span class="hljs-comment"> // hope Employee has a virtual destructor</span><br></code></pre></td></tr></table></figure>

<p>In principle, deallocation is then done by the destructor (which knows the sizes of its class).</p>
</li>
</ol>
<h4 id="19-2-6-User-defined-Literals"><a href="#19-2-6-User-defined-Literals" class="headerlink" title="19.2.6 User-defined Literals"></a>19.2.6 User-defined Literals</h4><ol start="27">
<li><p>C++ provides literals for a variety of built-in types (section 6.2.6):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">123</span>; <span class="hljs-comment">// int</span><br><span class="hljs-number">1.2</span>; <span class="hljs-comment">// double</span><br><span class="hljs-number">1.2F</span>; <span class="hljs-comment">// float</span><br><span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// char</span><br><span class="hljs-number">1ULL</span>; <span class="hljs-comment">// unsigned long long</span><br><span class="hljs-number">0xD0</span>; <span class="hljs-comment">// hexadecimal</span><br><span class="hljs-string">&quot;as&quot;</span>; <span class="hljs-comment">// C-style string (const char[3])</span><br></code></pre></td></tr></table></figure>

<p>In addition, we can define literals for user-defined types and new forms of literals for built-in types.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;Hi!&quot;</span>s; <span class="hljs-comment">// string, not &quot;zero-terminated array of char&quot;</span><br><span class="hljs-number">1.2</span>i; <span class="hljs-comment">// imaginary</span><br><span class="hljs-number">101010111000101b</span>; <span class="hljs-comment">// binary</span><br><span class="hljs-number">123</span>s; <span class="hljs-comment">//seconds</span><br><span class="hljs-number">123.56</span>km; <span class="hljs-comment">// not miles!(units)</span><br><span class="hljs-number">123456789012345678901234567890123456789</span>x; <span class="hljs-comment">//extended-precision</span><br></code></pre></td></tr></table></figure>

<p>Such <em><strong>user-defined literals</strong></em> are supported through the notion of <em><strong>literal operators</strong></em> that map literals with a given suffix into a desired type.</p>
<p>The name of a literal operator is <code>operator&quot;&quot;</code> followed by the suffix. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">i</span>(<span class="hljs-type">long</span> <span class="hljs-type">double</span> d) <span class="hljs-comment">// imaginary literal</span><br>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,d&#125;; <span class="hljs-comment">// complex is a literal type</span><br>&#125;<br><br>std::string <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">s</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">size_t</span> n) <span class="hljs-comment">// std::string literal</span><br>&#123;<br>    <span class="hljs-keyword">return</span> string&#123;p,n&#125;; <span class="hljs-comment">// requires free-store allocation </span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>These two operators define suffixes <code>i</code> and <code>s</code>, respectively.</li>
<li>I use <code>constexpr</code> to enable compile-time evaluation.</li>
</ul>
</li>
<li><p>Given those, we can write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// pass pointer to char* </span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Hello&quot;</span>s); <span class="hljs-comment">// pass (five-character) string object</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>s); <span class="hljs-comment">// pass (six-character) string object</span><br><br>    <span class="hljs-keyword">auto</span> z = <span class="hljs-number">2</span>+<span class="hljs-number">1</span>i; <span class="hljs-comment">// complex&#123;2,1&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The basic (implementation) idea is that after parsing what could be a literal, the compiler always checks for a suffix.</p>
<p>The user-defined literal mechanism simply allows the user to specify a new suffix and define what is to be done with the literal before it.</p>
<p>It is not possible to redefine the meaning of a built-in literal suffix or augment the syntax of literals.</p>
</li>
<li><p>There are four kinds of literals that can be suffixed to make a user-defined literal:</p>
<ul>
<li><p>An integer literal (section 6.2.4.1):</p>
<ul>
<li>accepted by a literal operator taking an <code>unsigned long long</code> or</li>
<li><code>const char*</code> argument or</li>
<li>by a template literal operator,</li>
</ul>
<p>for example, <code>123m</code> or <code>12345678901234567890X</code></p>
</li>
<li><p>A floating-point literal (section 6.2.5.1):</p>
<ul>
<li>accepted by a literal operator taking a <code>long double</code> or</li>
<li>a <code>const char*</code> argument or</li>
<li>by a template literal operator,</li>
</ul>
<p>for example, <code>12345678901234567890.976543210x</code> or <code>3.99s</code></p>
</li>
<li><p>A string literal (section 7.3.2):</p>
<ul>
<li>accepted by a literal operator taking a (<code>const char*</code>, <code>size_t</code>) pair of argument,</li>
</ul>
<p>for example, <code>&quot;string&quot;s</code> and <code>R&quot;(Foo\bar)&quot;_path</code></p>
</li>
<li><p>A charactor literal (section 6.2.3.2):</p>
<ul>
<li>accepted by a literal operator taking a character argument of type <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>,</li>
</ul>
<p>for example, <code>&#39;f&#39;_runic</code> or <code>u&#39;BEEF&#39;_w</code>.</p>
</li>
</ul>
<p>For example, we could define a literal operator to collect digits for integer values that cannot be represented in any of the built-in integer types:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">Bignum <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">x</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*p) <span class="hljs-comment">// require a C-style string for my operator</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Bignum</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Bignum)</span></span>;<br><br><span class="hljs-built_in">f</span>(<span class="hljs-number">123456789012345678901234567890123456789012345</span>x); <span class="hljs-comment">// did not put those digits in double quotes.</span><br><span class="hljs-comment">// the compiler derived a C-style string from the digits provided</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Here, the C-style string <code>&quot;123456789012345678901234567890123456789012345&quot;</code> is passed to <code>operator&quot;&quot; x()</code>.</li>
<li>Note that I did not put those digits in double quotes.<ul>
<li>I required a C-style string for my operator, and the compiler delivered it from the digits provided.</li>
</ul>
</li>
</ul>
</li>
<li><p>To get a C-style string from the program souce text into a literal operator, we request both the string and its number of  characters. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">string <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">s</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">size_t</span> n);<br><br>string s12 = <span class="hljs-string">&quot;one two&quot;</span>s; <span class="hljs-comment">// call operator &quot;&quot;(&quot;one two&quot;,7)</span><br>string s22 = <span class="hljs-string">&quot;two\ntwo&quot;</span>s; <span class="hljs-comment">// call operator &quot;&quot;(&quot;two\ntwo&quot;,7)</span><br>string sxx = R<span class="hljs-string">&quot;two\ntwo&quot;</span>s; <span class="hljs-comment">// call operator &quot;&quot;(&quot;two\ntwo&quot;,8)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>In the raw string (section 7.3.2.1), <code>&quot;\n&quot;</code> represents the two characters <code>&#39;\&#39;</code> and <code>n</code>.</li>
</ul>
<p>The rationale for requiring the number of character is that if we want to have “a different kind of string,” we almost always want to know the number of characters anyway.</p>
</li>
<li><p>A literal operator that takes just a <code>const char*</code> argument (and no size) can be applied to integer and floating-point literals.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">string <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">SS</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p); <span class="hljs-comment">// warning: this will not work as expected</span><br><br>string s12 = <span class="hljs-string">&quot;one two&quot;</span>SS; <span class="hljs-comment">// error: no applicable literal operator</span><br>string s13 = <span class="hljs-number">13</span>SS; <span class="hljs-comment">// OK, but why would anyone do that?</span><br></code></pre></td></tr></table></figure>

<p>A literal operator converting numberical values to strings could be quite confusing.</p>
</li>
<li><p>A <em><strong>template literal operator</strong></em> is a literal operator that takes its argument as a template parameter pack, rather than as a function argument. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span>...&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _b3(); <span class="hljs-comment">// base 3, i.e., ternary</span><br></code></pre></td></tr></table></figure>

<p>Given that, we get:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">201</span>_b3; <span class="hljs-comment">// means operator &quot;&quot; b3&lt;&#x27;2&#x27;,&#x27;0&#x27;,&#x27;1&#x27;&gt;(); so 9*2+3*0+1 == 19</span><br><span class="hljs-number">241</span>_b3; <span class="hljs-comment">// means operator &quot;&quot; b3&lt;&#x27;2&#x27;,&#x27;4&#x27;,&#x27;1&#x27;&gt;(); so error: 4 isn&#x27;t a ternary digit</span><br></code></pre></td></tr></table></figure>

<p>The variadic template techniques (section 3.4.4, section 28.6) can be disconcerting, but it is the only way of assigning nonstandard meanings to digits at compile time.</p>
</li>
<li><p>To define <code>operator&quot;&quot; _b3()</code>, we need some helper functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">ipow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// x to the nth power for n&gt;=0</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (n&gt;<span class="hljs-number">0</span>) ? x*<span class="hljs-built_in">ipow</span>(x,n<span class="hljs-number">-1</span>) : <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span> c&gt; <span class="hljs-comment">// handle the single ternary digit case</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">b3_helper</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(c&lt;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;not a ternary digit&quot;</span>);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span> c,<span class="hljs-type">char</span>... tail&gt; <span class="hljs-comment">// peel off one ternary digit (variadic template; section 3.4.4)</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">b3_helper</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(c&lt;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;not a ternary digit&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ipow</span>(<span class="hljs-number">3</span>,<span class="hljs-keyword">sizeof</span>...(tail))*(c-<span class="hljs-string">&#x27;0&#x27;</span>)+<span class="hljs-built_in">b3_helper</span>(tail...);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Given that, we can define our base 3 literal operator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">char</span>... chars&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _b3() <span class="hljs-comment">// base 3, i.e., ternary</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">b3_helper</span>(chars...)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Many suffixes will be short (e.g., <code>s</code> for <code>std::string</code>, <code>i</code> for imaginary, <code>m</code> for meter (section 28.7.3), and <code>x</code> for extended), so different uses could easily clash.</p>
<p>Use namespace to prevent clashes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> Numerics&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bignum</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;;<br><br>    <span class="hljs-keyword">namespace</span> literals&#123;<br>        Bignum <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">x</span>(<span class="hljs-type">char</span> <span class="hljs-type">const</span>*);<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Numerics::literals<br></code></pre></td></tr></table></figure></li>
<li><p>The standard library reserves all suffixs not starting with an initial underscore, so define your suffixes starting with an underscore or risk your code breaking in the future:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">123</span>km; <span class="hljs-comment">// reserved by the standard library</span><br><span class="hljs-number">123</span>_km; <span class="hljs-comment">// available for your use</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-3-A-String-Class"><a href="#19-3-A-String-Class" class="headerlink" title="19.3 A String Class"></a>19.3 A String Class</h3><ol start="36">
<li><p>The relatively simple string class presented in this section illustrates several techniques that are useful for the design and implementation of classes using conventionally defined operators.</p>
<ul>
<li>This <code>String</code> is a simplified version of the standard-library <code>string</code> (section 4.2, Chapter 36).</li>
<li><code>String</code> provides value semantics, checked and unchecked access to characters, stream I/O, support for range-<code>for</code> loops, equality operations, and concatenation operators.</li>
<li>I also added a <code>String</code> literal, which <code>std::string</code> does not (yet) have.</li>
</ul>
</li>
<li><p>To allow simple interoperability with C-style strings (including string literal (section 7.3.2)), I represent strings as zero-terminated arrays of characters.</p>
<ul>
<li>For realism, I implement the <em><strong>short string optimization</strong></em>. That is, a <code>String</code> with only a few characters stores those characters in the class object itself, rather than on the free store.<ul>
<li>This optimizas string usage for small strings.</li>
<li>Experience shows that for a huge number of applications most strings are short.</li>
<li>This optimization is particularly important in multi-threaded systems where sharing through pointers (or reference) is infeasible and free-store allocation and deallocation relatively expensive.</li>
</ul>
</li>
</ul>
<p>To allow <code>String</code>s to efficiently “grow” by adding character at the end, I implement a scheme for keeping extra space for such growth similar to the one used for <code>vector</code> (section 13.6.1).</p>
<ul>
<li>This makes <code>String</code> a suitable target for various forms of input.</li>
</ul>
</li>
<li><p>Writing a better string class and/or one that provides more facilities is a good exercise.</p>
<p>That done, we can throw away our exercises and use <code>std::string</code>.</p>
</li>
</ol>
<h4 id="19-3-1-Essential-Operations"><a href="#19-3-1-Essential-Operations" class="headerlink" title="19.3.1 Essential Operations"></a>19.3.1 Essential Operations</h4><ol start="39">
<li><p>Class <code>String</code> provides the usual set of constructors, a destructor, and assignment operation (section 17.1):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>(); <span class="hljs-comment">// default constructor: x&#123;&quot;&quot;&#125;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p)</span></span>; <span class="hljs-comment">// constructor from C-style string: x&#123;&quot;Euler&quot;&#125;</span><br><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp;); <span class="hljs-comment">// copy constructor</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp;); <span class="hljs-comment">// copy assignment</span><br><br>    <span class="hljs-built_in">String</span>(String&amp;&amp; x); <span class="hljs-comment">// move constructor</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(String&amp;&amp; x); <span class="hljs-comment">// move assignment</span><br><br>    ~<span class="hljs-built_in">String</span>() &#123; <span class="hljs-keyword">if</span>(short_max&lt;sz) <span class="hljs-keyword">delete</span>[] ptr;&#125; <span class="hljs-comment">// destructor</span><br><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>This <code>String</code> has value semantics.</p>
<ul>
<li>That is, after an assignment <code>s1=s2</code>, the two strings <code>s1</code> and <code>s2</code> are fully distinct, and subsequent changes to one have no effect on the other.</li>
</ul>
<p>The alternative would be to give <code>String</code> pointer semantics.</p>
<ul>
<li>That would be to let changes to <code>s2</code> after <code>s1=s2</code> also affect the value of <code>s1</code>.</li>
</ul>
<p>Where it makes sense, I prefer value semantics;</p>
<ul>
<li>examples are <code>complex</code>, <code>vector</code>, <code>Matrix</code>, and <code>string</code>.</li>
</ul>
<p>However, for value semantics to be affordable, we need to pass <code>String</code>s by reference when we don’t need copies and to implement move semantics (section 3.3.2, section 17.5.2) to optimize <code>return</code>s.</p>
<p>The slightly nontrivial representation of <code>String</code> is presentedin section 19.3.3.</p>
<ul>
<li>Note that it requires user-defined versions of the copy and move operations.</li>
</ul>
</li>
</ol>
<h4 id="19-3-2-Access-to-Characters"><a href="#19-3-2-Access-to-Characters" class="headerlink" title="19.3.2 Access to Characters"></a>19.3.2 Access to Characters</h4><ol start="40">
<li><p>The design of access operators for a string is a difficult topic because ideally access is by conventional notation (that is, using <code>[]</code>), maximally efficient, and range checked.</p>
<p>Unfortunately, you cannot have all of these properties simultaneously.</p>
<p>Here, I follow the standard library by providing efficient unchecked operations with the conventional <code>[]</code> subscript notation plus range-checked <code>at()</code> operations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> ptr[n];&#125; <span class="hljs-comment">// unchecked element access</span><br>    <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> n) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ptr[n];&#125; <span class="hljs-comment">// const version for const</span><br><br>    <span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-built_in">check</span>(n); <span class="hljs-keyword">return</span> ptr[n];&#125; <span class="hljs-comment">// range-checked element access</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">check</span>(n); <span class="hljs-keyword">return</span> ptr[n];&#125;<br><br>    String&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> c); <span class="hljs-comment">// add c at end</span><br><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> ptr;&#125; <span class="hljs-comment">// C-style string access</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> sz;&#125; <span class="hljs-comment">// number of elements</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// elements plus available space</span></span><br><span class="hljs-function">    	</span>&#123; <span class="hljs-keyword">return</span> (sz&lt;short_max) ? short_max : sz+space;&#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>I provide <code>const</code> and non-<code>const</code> versions of the access functions to allow them to be used for <code>const</code> as well as other objects.</li>
</ul>
</li>
<li><p>The idea is to use <code>[]</code> for ordinary use. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> h&#123;s[<span class="hljs-number">0</span>]&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i&#123;<span class="hljs-number">1</span>&#125;; i!=s.<span class="hljs-built_in">size</span>(); i++) h ^= s[i]&gt;&gt;<span class="hljs-number">1</span>; <span class="hljs-comment">// unchecked access to s</span><br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Here, using the checked <code>at()</code> would be redundant because we correctly access <code>s</code> only from <code>0</code> to <code>s.size()-</code>.</li>
</ul>
</li>
<li><p>We can use <code>at()</code> where we see a possibility of mistakes. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_in_order</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; s, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (x : index) cout &lt;&lt; s.<span class="hljs-built_in">at</span>(x) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Unfortunately, assuming that people will use <code>at()</code> consistently where mistakes can be made is overly optimistic, so some implementations of <code>std::string</code> (from which the <code>[]</code>/<code>at()</code> convention is borrowed) also check <code>[]</code>.</li>
<li>I personally prefer ta checked <code>[]</code> at least during development.</li>
<li>However, for serious string manipulation tasks, a range check on each character access could impose quite noticeable overhead.</li>
</ul>
</li>
</ol>
<h4 id="19-3-3-Representation"><a href="#19-3-3-Representation" class="headerlink" title="19.3.3 Representation"></a>19.3.3 Representation</h4><ol start="43">
<li><p>The representation for <code>String</code> was chosen to meet three goals:</p>
<ul>
<li>To make it easy to convert a C-style string (e.g., a string literal) to a <code>String</code> and to allow easy access to the characters of a <code>String</code> as a C-style string</li>
<li>To minimize the use of the free store</li>
<li>To make adding characters to the end of a <code>String</code> efficient</li>
</ul>
<p>The result is clearly messier than a simple {pointer,size} representation, but much more realistic:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	A simple string that implements the short string optimization</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	size()==sz is the number of elements</span><br><span class="hljs-comment">	if size()&lt;=short_max, the characters are held in the String object itself;</span><br><span class="hljs-comment">	otherwise the free store is used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	ptr points to the start of the character sequence</span><br><span class="hljs-comment">	the character sequence is kept zero-terminated: ptr[size()]==0;</span><br><span class="hljs-comment">	this allows us to use C library string functions and to easily return a C-style string: c_str()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	To allow efficient addition of characters at end, String grows by doubling its allocation;</span><br><span class="hljs-comment">	capacity() is the  amount of space available for characters</span><br><span class="hljs-comment">	(excluding the terminating 0): sz+space</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> short_max = <span class="hljs-number">15</span>;<br>    <span class="hljs-type">int</span> sz; <span class="hljs-comment">// number of characters</span><br>    <span class="hljs-type">char</span>* ptr;<br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-type">int</span> space; <span class="hljs-comment">// unused allocated space</span><br>        <span class="hljs-type">char</span> ch[short_max+<span class="hljs-number">1</span>]; <span class="hljs-comment">// leave space to terminating 0</span><br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> <span class="hljs-comment">// range check</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">0</span> || sz&lt;=n)<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;String::at()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ancillary member functions</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_from</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move_from</span><span class="hljs-params">(String&amp; x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This supports what is known as <em><strong>short string optimization</strong></em> by using two string representations:<ul>
<li>If <code>sz&lt;=short_max</code>, the characters are stored in the <code>String</code> object itself, in the array named <code>ch</code>.</li>
<li>If <code>!(sz&lt;=short_max)</code>, the characters are stored on the free store and we may allocate extra space for expansion. The member named <code>space</code> is the number of such characters.</li>
</ul>
</li>
<li>In both cases, the number of elements is kept in <code>sz</code> and we look at <code>sz</code>, to determine which implementation scheme is used for a given string.</li>
<li>In both cases, <code>ptr</code> points to the elements.<ul>
<li>This is essential for performance:<ul>
<li>the access functions do not need to test which representation is used; they simply use <code>ptr</code>.</li>
<li>Only the constructor, assignments, moves, and the destructor (section 19.3.4) must care about the two alternatives.</li>
</ul>
</li>
</ul>
</li>
<li>We use the array <code>ch</code> only if <code>sz&lt;=short_max</code> and the integer <code>space</code> only if <code>!(sz&lt;=short_max)</code>.<ul>
<li>Consequently, it would be a waste to allocate space for both <code>ch</code> and <code>space</code> in a <code>String</code> object.<ul>
<li>To avoid such waste, I use a <code>union</code> (section 8.3).</li>
<li>In particular, I used a form of <code>union</code> called an <em><strong>anonymous union</strong></em> (section 8.3.2), which is specially designed to allow a class to manage alternative representations of objects.<ul>
<li>All members of an anonymous union are allocated in the same memory, starting at the same address.</li>
<li>Only one member may be used at any one time, but otherwise they are accessed and used exactly as if they were separate members of the scope surrounding the anonymous union.</li>
<li>It is the programmer’s job to make sure that they are never misused.<ul>
<li>For example, all member functions of <code>String</code> that use <code>space</code> must make sure that it really was <code>space</code> that was set and not <code>ch</code>.</li>
<li>That is done by looking at <code>sz&lt;=short_max</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="19-3-3-1-Ancillary-Functions"><a href="#19-3-3-1-Ancillary-Functions" class="headerlink" title="19.3.3.1 Ancillary Functions"></a>19.3.3.1 Ancillary Functions</h5><ol start="44">
<li><p>In addition to functions intended for general use, I found that my code become cleaner when I provided three ancillary functions as “building blocks” to help me with somewhat triky representation and to minimize code replication.</p>
<ul>
<li>Two of those need to access the representation of <code>String</code>, so I made them members.</li>
</ul>
<p>However, I made them <code>private</code> members because they don’t represent operations that are generally useful and safe to use.</p>
<p>For many interesting classes, the implementation is not just the representation plus the <code>public</code> functions.</p>
<p>Ancillary functions can lead to less duplication of code, better design, and improved maintainability.</p>
</li>
<li><p>The first such function moves characters into newly allocated memory:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr, <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// expand into free store</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>    <span class="hljs-built_in">strcpy</span>(p,ptr); <span class="hljs-comment">// section 43.4</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>This function does not access the <code>String</code> representation, so I did not make it a member.</li>
</ul>
<p>The second implementation function is used by copy operations to give a <code>String</code> a copy of the members of another:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::copy_from</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// make *this a copy of x</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x.sz&lt;=short_max) &#123; <span class="hljs-comment">// copy *this</span><br>        <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>,&amp;x,<span class="hljs-built_in">sizeof</span>(x)); <span class="hljs-comment">// section 43.5</span><br>        ptr = ch;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// copy the elements</span><br>        ptr = <span class="hljs-built_in">expand</span>(x.ptr,x.sz+<span class="hljs-number">1</span>); <span class="hljs-comment">// zero-terminated</span><br>        sz = x.sz;<br>        space = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Any necessary cleanup of the target <code>String</code> is the task of callers of <code>copy_from()</code>;<ul>
<li><code>copy_from()</code> unconditionally overwrites its target.</li>
</ul>
</li>
<li>I use the standard-library <code>memcpy()</code> (section 43.5) to copy the bytes of the source into the target.<ul>
<li>That’s a low level and sometimes pretty nasty function.</li>
<li>It should be used only where there are no objects with constructors or destructors in the copied memory because <code>memcpy()</code> knows nothing about types.</li>
</ul>
</li>
<li>Both <code>String</code> copy operations use <code>copy_from()</code> (i.e., copy constructor and copy assignment).</li>
</ul>
<p>The corresponding function for move operation is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::move_from</span><span class="hljs-params">(String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x.sz&lt;=short_max) &#123; <span class="hljs-comment">// copy *this</span><br>        <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>,&amp;x,<span class="hljs-built_in">sizeof</span>(x)); <span class="hljs-comment">// section 43.5</span><br>        ptr = ch;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// grab the elements</span><br>        ptr = x.ptr;<br>        sz = x.sz;<br>        space = x.space;<br>        x.ptr = x.ch; <span class="hljs-comment">// x = &quot;&quot;</span><br>        x.sz = <span class="hljs-number">0</span>;<br>        x.ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>It too unconditionally makes its target a copy of its argument.<ul>
<li>However, it does not leave its argument owning any free store.</li>
</ul>
</li>
<li>I could also have used <code>memcpy()</code> in the long string case (<code>!(x.sz&lt;=short_max)</code>), but since a long string representation uses only part of <code>String</code>‘s representation, I decidied to copy the used members individually/</li>
</ul>
</li>
</ol>
<h4 id="19-3-4-Member-Functions"><a href="#19-3-4-Member-Functions" class="headerlink" title="19.3.4 Member Functions"></a>19.3.4 Member Functions</h4><ol start="46">
<li><p>The default constructor defines a <code>String</code> to be empty:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>() <span class="hljs-comment">// default constructor: x&#123;&quot;&quot;&#125;</span><br>    : sz&#123;<span class="hljs-number">0</span>&#125;, ptr&#123;ch&#125; <span class="hljs-comment">// ptr points to elements, ch is an initial location (section 19.3.3)</span><br>&#123;<br>    ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// terminating 0</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Given <code>copy_from()</code> and <code>move_from()</code>, the constructors, movesm and assignments are fairly simple to implement.</p>
<p>The constructor that takes a C-style string argument must determine the number of characters and store them appropriately:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p)<br>    : sz&#123;<span class="hljs-built_in">strlen</span>(p)&#125;,<br>	  ptr&#123;(sz&lt;=short_max) ? ch : <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[sz+<span class="hljs-number">1</span>]&#125;,<br>	  space&#123;<span class="hljs-number">0</span>&#125;<br>&#123;<br>    <span class="hljs-built_in">strcpy</span>(ptr,p); <span class="hljs-comment">// copy characters into ptr from p</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>If the argument is a short string, <code>ptr</code> is set to point to <code>ch</code>; otherwise, space is allocated on the free store.</li>
<li>In either case, the characters are copied from the argument string into the memory managed by <code>String</code>.</li>
</ul>
<p>The copy constructor simply copies the representation of its argument:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; x) <span class="hljs-comment">// copy constructor</span><br>&#123;<br>    <span class="hljs-built_in">copy_from</span>(x); <span class="hljs-comment">// copy representaion from x</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>I didn’t bother trying to optimize the case where the size of the source equals the size of the target (as was done for <code>vector</code>; section 13.6.3). I didn’t know if that would be worthwhile.</li>
</ul>
<p>Similarly, the move constructor moves the representation from its source (and possibly sets it argument to be the empty string):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">String::<span class="hljs-built_in">String</span>(String&amp;&amp; x) <span class="hljs-comment">// move constructor</span><br>&#123;<br>    <span class="hljs-built_in">move_from</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Like the copy constructor, the <strong>copy assignment</strong> uses <code>copy_from()</code> to clone its argument’s representation.</p>
<p>In addition, it has to <code>delete</code> any free store owned by the target and make sure it does not get into trouble with self-assignment (e.g., <code>s=s</code>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; x)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;x) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// deal with self-assignment</span><br>    <span class="hljs-type">char</span>* p = (short_max&lt;sz) ? ptr : <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">copy_from</span>(x);<br>    <span class="hljs-keyword">delete</span>[] p;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The <code>String</code> move assignment deletes its target’s free store (if there is any) and then moves:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; String::<span class="hljs-keyword">operator</span>=(String&amp;&amp; x)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==&amp;x) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// deal with self-assignment (x = move(x) is insanity)</span><br>    <span class="hljs-keyword">if</span>(short_max&lt;sz) <span class="hljs-keyword">delete</span>[] ptr; <span class="hljs-comment">// delete target</span><br>    <span class="hljs-built_in">move_from</span>(x); <span class="hljs-comment">// does not throw</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>It is logically possible to move a source into itself (e.g., <code>s=std::move(s)</code>), so again we have to protect against self-assignment (however unlikely).</li>
</ul>
</li>
<li><p>The logically most complicated <code>String</code> operation is <code>+=</code>, which adds a character to the end of the string, increasing its size of by one:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; String::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> c)<br>&#123;<br>    <span class="hljs-keyword">if</span>(sz==short_max) &#123; <span class="hljs-comment">// expand to long string</span><br>        <span class="hljs-type">int</span> n = sz+sz+<span class="hljs-number">2</span>; <span class="hljs-comment">// double the allocation (+2 because of the terminating 0)</span><br>        ptr = <span class="hljs-built_in">expand</span>(ptr,n);<br>        space = n-sz<span class="hljs-number">-2</span>; <span class="hljs-comment">// n - 1 - (sz + 1)</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(short_max&lt;sz) &#123;<br>        <span class="hljs-keyword">if</span>(space==<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// expand in free store</span><br>            <span class="hljs-type">int</span> n = sz+sz+<span class="hljs-number">2</span>; <span class="hljs-comment">// double the allocation (+2 because of the terminating 0)</span><br>            <span class="hljs-type">char</span>* p = <span class="hljs-built_in">expand</span>(ptr,n);<br>            <span class="hljs-keyword">delete</span>[] ptr;<br>            ptr = p;<br>            space = n-sz<span class="hljs-number">-2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            --space;<br>    &#125;<br>    ptr[sz] = c; <span class="hljs-comment">// add c at end</span><br>    ptr[++sz] = <span class="hljs-number">0</span>; <span class="hljs-comment">// increase size and set terminator</span><br><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>There is a lot going on here:<ul>
<li><code>operator+=()</code> has to keep track of which representation (short or long) is used and whether there is extra space available to expand into.<ul>
<li>If more space is needed, <code>expand()</code> is called to allocate that space and move the old characters into the new space.</li>
<li>If there was an old allocation that needs deleting, it is returned, so that <code>+=</code> can delete it.</li>
</ul>
</li>
<li>Once enough space is available, it is trivial to put the new character <code>c</code> into it and to add the terminating <code>0</code>.</li>
</ul>
</li>
<li>Note the calculation of available memory for space.<ul>
<li>Of all the String implementation that took the longest to get right:<ul>
<li>its a messy little calculation prone to off-by-one errors.</li>
</ul>
</li>
<li>That repeated constant <code>2</code> feels awfully like a ‘‘magic constant.’’</li>
</ul>
</li>
</ul>
<p>All <code>String</code> members take care not to modify a new representation before they are certain that a new one can be put in place.</p>
<ul>
<li>In particular, they don’t <code>delete</code> until after any possible <code>new</code> operations have been done.</li>
<li>In fact, the <code>String</code> members provides the strong exception guarantee (section 13.2).</li>
</ul>
</li>
<li><p>If you don’t like the kind of fiddly code presented as part of the implementation of <code>String</code>, simply use <code>std::string</code>.</p>
<p>To a large extent, the standard-library facilities exist to save us from programming at this low level most of the time.</p>
<p>Stronger: writing a string class, a vector class, or a map is an excellent exercise.</p>
<ul>
<li>However, once the exercise is done, one outcome should be an appreciation of what the standard offers and a desire not to maintain your own version.</li>
</ul>
</li>
</ol>
<h4 id="19-3-5-Helper-Functions"><a href="#19-3-5-Helper-Functions" class="headerlink" title="19.3.5 Helper Functions"></a>19.3.5 Helper Functions</h4><ol start="50">
<li><p>To complete class <code>String</code>, I provide a set of useful functions, stream I/O, support for range-<code>for</code> loops, comparison, and concatenation.</p>
<ul>
<li>These all mirror the design choices used for <code>std::string</code>.</li>
</ul>
</li>
<li><p>In particular, <code>&lt;&lt;</code> just prints the characters without added formatting, and <code>&gt;&gt;</code> skips initial whitespace before reading until it finds terminating whitespace (or the end of the stream):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> String&amp; s)<br>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; s.<span class="hljs-built_in">c_str</span>(); <span class="hljs-comment">// section 36.3.3</span><br>&#125;<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, String&amp; s)<br>&#123;<br>    s = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// clear the target string</span><br>    is&gt;&gt;ws; <span class="hljs-comment">// skip whitespace (section 38.4.5.1)</span><br>    <span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;&#x27;;</span><br><span class="hljs-string">    while(is.get(ch) &amp;&amp; !isspace(ch))</span><br><span class="hljs-string">        s += ch;</span><br><span class="hljs-string">    return is;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure></li>
<li><p>I provide <code>==</code> and <code>!=</code> for comparison:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; a, <span class="hljs-type">const</span> String&amp; b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i!=a.<span class="hljs-built_in">size</span>(); ++i)<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> String&amp; a, <span class="hljs-type">const</span> String&amp; b)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(a==b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Adding <code>&lt;</code>, etc., would be trivial.</p>
</li>
<li><p>To support the range-<code>for</code> loop, we need <code>begin()</code> and <code>end()</code> (section 9.5.1).</p>
<p>Again, we can provide those as freestanding (nonmember) functions without direct access to the <code>String</code> implementation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">(String&amp; x)</span> <span class="hljs-comment">// C-string-style access</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">(String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>()+x.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">c_str</span>()+x.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Given the member function <code>-=</code> that adds a character at the end, concatenation operator are easily provided as nonmember functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">String&amp; <span class="hljs-keyword">operator</span>+=(Strng&amp; a, <span class="hljs-type">const</span> String&amp; b) <span class="hljs-comment">// concatenation</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : b)<br>        a+=x;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>String&amp; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; a, <span class="hljs-type">const</span> String&amp; b) <span class="hljs-comment">// concatenation</span><br>&#123;<br>    String res&#123;a&#125;;<br>    res += b;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>I feel that I may have slight “cheated” here.</p>
<ul>
<li><p>Should I have provided a member <code>+=</code> that added a C-style string to the end?</p>
<ul>
<li><p>The standard-library <code>string</code> does, but without it, concatenation with a C-style string still works.</p>
</li>
<li><p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">String s = <span class="hljs-string">&quot;Njal&quot;</span>;<br>s += <span class="hljs-string">&quot;Gunnar&quot;</span>; <span class="hljs-comment">// concatenate: add to the end of s</span><br></code></pre></td></tr></table></figure>

<ul>
<li>This use of <code>+=</code> is interpreted as <code>operator+=(s,String(&quot;Gunnar&quot;))</code>.</li>
</ul>
</li>
<li><p>My guess is that I could provide a more efficient <code>String::operator+=(const char*)</code>, but I have no idea if the added performance would be worthwhile in real-world code.</p>
</li>
<li><p>In such cases, I try to be conservative and deliver the minimal design.</p>
</li>
<li><p>Being able to do something is not by itself a good reason for doing it.</p>
</li>
</ul>
</li>
<li><p>Similarly, I do not try to optimize <code>+=</code> by taking the size of a source string into account.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Adding <code>_s</code> as a string literal suffix meaning <code>String</code> is trivial:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">String <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _s(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">size_t</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> String&#123;p&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>We can now write:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; <span class="hljs-comment">// C-style string</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp;)</span></span>; <span class="hljs-comment">// our string</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Madden&#x27;s&quot;</span>); <span class="hljs-comment">// f(const char*)</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;Christopher&#x27;s&quot;</span>_s); <span class="hljs-comment">// f(const String&amp;)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="19-3-6-Using-Our-String"><a href="#19-3-6-Using-Our-String" class="headerlink" title="19.3.6 Using Our String"></a>19.3.6 Using Our String</h4><ol start="56">
<li><p>The main program simply exercises the <code>String</code> operators a bit:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;abcdefghij&quot;</span>)</span></span>;<br>    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;k&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;l&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;m&#x27;</span>;<br>    s += <span class="hljs-string">&#x27;n&#x27;</span>;<br>    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    String s2 = <span class="hljs-string">&quot;Hell&quot;</span>;<br>    s2 += <span class="hljs-string">&quot; and high water&quot;</span>;<br>    cout &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    String s3 = <span class="hljs-string">&quot;qwerty&quot;</span>;<br>    s3 = s3;<br>    String s4 = <span class="hljs-string">&quot;the quick brown fox jumped over the lazy dog&quot;</span>;<br>    s4 = s4;<br>    cout &lt;&lt; s3 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cout &lt;&lt; s + <span class="hljs-string">&quot;. &quot;</span> + s3 + <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;. &quot;</span>) + <span class="hljs-string">&quot;Horsefeathers\n&quot;</span>;<br><br>    String buf;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;buf &amp;&amp; buf!=<span class="hljs-string">&quot;quit&quot;</span>)<br>        cout &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; buf.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; buf.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>The <code>String</code> lacks many features that you might consider important or even essential.</p>
<p>However, for what it does it closely resembles <code>std::string</code> (Chapter 36) and illustrates techniques used for the implementation of the standard-library <code>string</code>.</p>
</li>
</ol>
<h3 id="19-4-Friends"><a href="#19-4-Friends" class="headerlink" title="19.4 Friends"></a>19.4 Friends</h3><ol start="58">
<li><p>An ordinary member function declaration specifies three logically distinct things:</p>
<ul>
<li>The function can access the private part of the class declaration.</li>
<li>The function is in the scope of the class.</li>
<li>The function must be invoked on an object (has a <code>this</code> pointer).</li>
</ul>
<p>By declaring a member function <code>static</code> (section 16.2.12), we can give it the first two properties only.</p>
<p>By declaring a nonmember function a <code>friend</code>, we can give it the first property only.</p>
<ul>
<li><p>That is, a function declared <code>friend</code> is granted access to the implementation of a class just like a member function but is otherwise independent of that class.</p>
</li>
<li><p>For example, we could define an operator that multiplies a <code>Matric</code> by a <code>Vector</code>.</p>
<ul>
<li><p>Naturally, <code>Vector</code> and <code>Matrix</code> hide their repective representations and provide a complete set of operations for manipulating objects of their type.</p>
</li>
<li><p>However, our multiplication routine cannot be a member of both.</p>
</li>
<li><p>Also, we don’t really want to provide low-level access functions to allow every user to both read and write the complete representation of both <code>Matrix</code> and <code>Vector</code>.</p>
</li>
<li><p>To avoid this, we declare the <code>operator*</code> a <code>friend</code> of both:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> rc_max&#123;<span class="hljs-number">4</span>&#125;; <span class="hljs-comment">// row and column size</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br>    <span class="hljs-type">float</span> v[rc_max];<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">friend</span> Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp;, <span class="hljs-type">const</span> Vector&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span> &#123;<br>	Vector v[rc_max];<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">friend</span> Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp;, <span class="hljs-type">const</span> Vector&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Now <code>operator*()</code> can reach into the implementation of both <code>Vector</code> and <code>Matrix</code>. That would allow sophisticated implementation techniques, but a simple implementation would be:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp; m, <span class="hljs-type">const</span> Vector&amp; v)<br>&#123;<br>    Vector r;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i!=rc_max; i++) &#123; <span class="hljs-comment">// r[i] = m[i] * v</span><br>        r.v[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j!=rc_max; j++)<br>            r.v[i] += m.v[i].v[j] * v.v[j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="59">
<li><p>A <code>friend</code> declaration can be placed in either the private or the public part of a class declaration; it does not matter where.</p>
<p>Like a member function, a friend function is explicitly declared in the declaration of the class of which it is a friend.</p>
<ul>
<li>It is therefore as much a part of that interface as is a member function. (既是接口也是成员函数)</li>
</ul>
</li>
</ol>
<ol start="60">
<li><p>A member function of one class can be the friend of another. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">List_iterator</span> &#123;<br>	<span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span>* <span class="hljs-title">List_iterator::next</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>There is a shorthand for making all functions of one class friends of another. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">List_iterator</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>This <code>friend</code> declaration makes all of <code>List_iterator</code>‘s member function friends of <code>List</code>.</li>
</ul>
<p>Declaring a class a <code>friend</code> grants access to every function of that class.</p>
<ul>
<li>That implies that we can not know the set of functions that can access the granting class’s representation just by looking at the class itself.</li>
<li>In this, a friend class declaration differs from the declaration of member function and a friend function.</li>
<li>Clearly, friend classes should be used with caution and only to express closely connected concepts.</li>
</ul>
</li>
</ol>
<ol start="61">
<li><p>It is possible to make a template argument a <code>friend</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-keyword">friend</span> T;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>; <span class="hljs-comment">// redundant &quot;class&quot;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Often, there is a choice between making a class a member (a nested class) or a nonmember friend (section 18.3.1)</p>
</li>
</ol>
<h4 id="19-4-1-Finding-Friends"><a href="#19-4-1-Finding-Friends" class="headerlink" title="19.4.1 Finding Friends"></a>19.4.1 Finding Friends</h4><ol start="62">
<li><p>A friend must be previously declared in an enclosing scope or defined in the non-class scope immediately enclosing the class that is declaring it to be a <code>friend</code>.</p>
<p>Scopes outside the innermost enclosing namespace scope are not considered for a name first declared as a <code>friend</code>.</p>
<p>Consider a technical example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span> &#123;&#125;; <span class="hljs-comment">// will become friend of N::C</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// will become friend of N::C</span><br><br><span class="hljs-keyword">namespace</span> N &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span> &#123;&#125;; <span class="hljs-comment">// will become friend of C</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// will become friend of C</span><br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>        <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>; <span class="hljs-comment">// OK (previously defined)</span><br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C3</span>; <span class="hljs-comment">// OK (defined in enclosing namespace)</span><br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C4</span>; <span class="hljs-comment">// First declared in N and assumed to be in N (but actually not)</span><br>        <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span></span>;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C3</span> &#123;&#125;; <span class="hljs-comment">// friend of C</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> </span>&#123; C x; x.x = <span class="hljs-number">1</span>;&#125; <span class="hljs-comment">// OK: friend of C</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C4</span> &#123;&#125;; <span class="hljs-comment">// not friend of N::C</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> </span>&#123; N::C x; x.x = <span class="hljs-number">1</span>;&#125; <span class="hljs-comment">// Error: x is private and f4() is not a friend of N::C</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="63">
<li><p>A friend function can be found through its argument (section 14.2.4) even if it was not declared in the immediately enclosing scope. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Matrix&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">invert</span>(m); <span class="hljs-comment">// Matrix&#x27;s friend invert()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Thus, a friend function should be explicitly declared in an enclosing scope or take an argument of its class or a class derived from that.</p>
<p>If not, the friend cannot be called.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// no f() in this scope</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// useless</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp;)</span></span>; <span class="hljs-comment">// can be found through its argument</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// no f() in scope</span><br>    <span class="hljs-built_in">h</span>(x); <span class="hljs-comment">// X&#x27;s friend h() (X&#x27;s friend h(const X&amp;) can be found through its argument)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="19-4-2-Friends-and-Members"><a href="#19-4-2-Friends-and-Members" class="headerlink" title="19.4.2 Friends and Members"></a>19.4.2 Friends and Members</h4><ol start="64">
<li><p>When should we use a friend function, and when is a member function the better choice for specifying an operation?</p>
<ul>
<li>First, we try to minimize the number of functions that access the representation of a class and try to make the set of access function as appropriate as possible.<ul>
<li>Therefore, the first question is not “Should it be a member, a <code>static</code> member, or a friend?” but rather “Does it really nedd access?”</li>
</ul>
</li>
<li>Typically, the set of functions that need access is smaller that we are willing to believe at first.</li>
<li>Some operations must be members.<ul>
<li>For example, constructors, destructors, and virtual functions (section 3.2.3, section 17.2.5)</li>
<li>But typically there is a choice.</li>
<li>Because member names are local to the class, a function that requires direct access to the representation should be a member unless there is a specific reason for it to be a nonmember.</li>
</ul>
</li>
</ul>
<p>Consider a class <code>X</code> supplying alternative ways of presenting an operation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span>);<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// member\</span><br><span class="hljs-comment">    int m2() const;</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">(X&amp;)</span></span>; <span class="hljs-comment">// friend, not member (no implicit conversion)</span><br>    <span class="hljs-function">firned <span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp;)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">f3</span><span class="hljs-params">(X)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Member functions can be invoked for objects of their class only; no user-defined conversions are applied to the leftmost operand of a <code>.</code> and <code>-&gt;</code> (but see section 19.2.3). For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-number">99.</span><span class="hljs-built_in">m1</span>(); <span class="hljs-comment">// error: X(99).m1() not tried</span><br>    <span class="hljs-number">99.</span><span class="hljs-built_in">m2</span>(); <span class="hljs-comment">// error: X(99).m2() not tried</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The global function <code>f1()</code> has a similar property because <strong>implicit conversions are not used for non-<code>const</code> reference arguments</strong> (section 7.7).</p>
<p>However, conversions may be applied to the argument of <code>f2()</code> and <code>f3()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f1</span>(<span class="hljs-number">99</span>); <span class="hljs-comment">// error: f1(X(99)) not tried: non-const X&amp; argument</span><br>    <span class="hljs-built_in">f2</span>(<span class="hljs-number">99</span>); <span class="hljs-comment">// OK: f2(X(99)); const X&amp; argument</span><br>    <span class="hljs-built_in">f3</span>(<span class="hljs-number">99</span>); <span class="hljs-comment">// OK: f3(X(99)); X argument</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ol start="65">
<li><p>An operation modifying the state of a class object should therefore be a member or a function taking a non-<code>const</code> reference argument (or a non-<code>const</code> pointer argument).</p>
<p>Operators that modify an operand (e.g., <code>=</code>, <code>*=</code>, and <code>++</code>) are most naturally defined as members for user-defined types.</p>
<p>Conversely, if implicit type conversion is desired for all operands of an operation, the function implementing it must be a nonmember function taking a <code>const</code> reference argument or a non-reference argument.</p>
<ul>
<li>This is often the case for the functions implementing operators that do not require lvalue operands when applied to fundamental types (e.g., <code>+</code>, <code>-</code>, and <code>||</code>)</li>
<li>However, such operators often need access to the representations of their operand class.</li>
<li>Consequently, binary operators are the most common source of friend function.</li>
</ul>
</li>
</ol>
<ol start="66">
<li><p>Unless type conversions are defined, there appears to be no compelling reason to choose a member over a friend taking reference argument, or vice versa.</p>
<p>In some cases, the programmer may have a preference for one call syntax over another.</p>
<ul>
<li>For example, most people seem to prefer the notion <code>m2=inv(m)</code> for producing a inverted <code>Matrix</code> from <code>m</code> to the alternative <code>m2=m.inv()</code>.</li>
<li>On the other hand, if <code>inv()</code> inverts <code>m</code> itself, rather than producing a new <code>Matrix</code> that is the inverse of <code>m</code>, it should be a member.</li>
</ul>
<p>All other things considered equal, implement operations that need direct access to a representation as member function:</p>
<ul>
<li><p>It is not possible to know if someone someday will define a conversion operator.</p>
</li>
<li><p>The member function call syntax makes it clear to the user that the object may be modified; a reference argument is far less obvious.</p>
</li>
<li><p>Expressions in the body of a member can be noticeably shorter than the equivalent expressions in a global function.</p>
<p>A nonmember function must use an explicit argument, whereas the member can use <code>this</code> implicitly.</p>
</li>
<li><p>Member names are local to a class, so they tend to be shorter than the names of nonmember functions.</p>
</li>
<li><p>If we have defined a member <code>f()</code> and we later feel the need for a nonmember <code>f()</code>, we can simply define it to mean <code>x.f()</code>.</p>
</li>
</ul>
<p>Conversely, operations that do not need direct access to a representation are often best represented as nonmember functions, possibly in a namespace that makes their relationship with the class explicit (section 18.3.6).</p>
</li>
</ol>
<h3 id="19-5-Advice"><a href="#19-5-Advice" class="headerlink" title="19.5 Advice"></a>19.5 Advice</h3><ul>
<li>Use <code>operator[]()</code> for subscripting and for selection based on a single value; section 19.2.1.</li>
<li>User <code>operator()()</code> for call semantices, for subscripting, and for selection based on multiple values; section 19.2.2.</li>
<li>User <code>operator-&gt;()</code> to dereference “smart pointer”; section 19.2.3.</li>
<li>Prefer prefix <code>++</code> over suffix <code>++</code>; section 19.2.4</li>
<li>Define the global <code>operator new()</code> and <code>operator delete()</code> only if you really have to; section 19.2.5.</li>
<li>Define member <code>operator new()</code> and member <code>operator delete()</code> to control allocation and deallocation of objects of a specific class or hierarchy of classes; section 19.2.5. </li>
<li>Use user-defined literals to mimic conventional notation; section 19.2.6.</li>
<li>Place literal operators in separate namespaces to allow selective use; section 19.2.6.</li>
<li>For nonspecialize uses, prefer the standard <code>string</code> (Chapter 36) to the result of your own exercises; 19.3.</li>
<li>Use a friend function if you need a nonmember function to have access to the representation of a class. (e.g., to improve notation or to access the representation of two classes); section 19.4</li>
<li>Prefer member functions to friend functions for granting access to the implementation of a class; section 19.4.2.</li>
</ul>
<h2 id="Chapter-20-Derived-Classes"><a href="#Chapter-20-Derived-Classes" class="headerlink" title="Chapter 20. Derived Classes"></a>Chapter 20. Derived Classes</h2><ul>
<li>Introduction</li>
<li>Derived Classes<ul>
<li> Member Functions</li>
<li>Constructors and Destructors</li>
</ul>
</li>
<li>Class Hierarchies<ul>
<li>Type Field</li>
<li>Virtual Functions</li>
<li>Explicit Qualification</li>
<li>Override Control</li>
<li><code>using</code> Base Members</li>
<li>Return Type Relaxation</li>
</ul>
</li>
<li>Abstract Classes</li>
<li>Access Control<ul>
<li><code>protected</code> Members</li>
<li>Access to Base Classes</li>
<li><code>using</code>-Declarations and Access Control</li>
</ul>
</li>
<li>Pointers to Members<ul>
<li>Pointers to Function Members</li>
<li>Pointers to Data Members</li>
<li>Base and Derived Members</li>
</ul>
</li>
<li>Advice</li>
</ul>
<h3 id="20-1-Introduction"><a href="#20-1-Introduction" class="headerlink" title="20.1 Introduction"></a>20.1 Introduction</h3><ol>
<li><p>From [Simula](<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Simula">Simula - Wikipedia</a>), C++ borrowed the ideas of classes and class hierarchies.</p>
<p>In addition, it borrowed the design idea that classes should be used to model concepts in the progrmmer’s and the application’s world.</p>
<ul>
<li>C++ provides language constructs that directly support these design notions.</li>
<li>Conversely, using the language features in support of design ideas distinguishes effective use of C++. Using language constructs as just notional props for traditional types of programming is to miss key strength of C++.</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>A concept (idea, notion, etc.) does not exist in isolation. </p>
<p>It coexists with realed concepts and derives much of its power from relationships with other concepts.</p>
<ul>
<li>For example, try to explain what a car is. Soon you’ll have introduced the notions of wheels, engines, drivers, pedestrains, trucks, ambulances, roads, oil, sppeding tickets, motels, etc.</li>
</ul>
<p>Since we uses classes to represent concepts, the issue becomes how to represent relationships among concepts.</p>
<p>However, we can’t express arbitrary relationships directly in a programming language.</p>
<ul>
<li>Even if we could, we wouldn’t want to.</li>
<li>To be useful, our classes should be more narrowly defined that our everyday concepts – and more precise.</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>The notion of a derived class and its associated language mechanisms are provided to express hierachical relationships, that is, to express commonality between classes.</p>
<ul>
<li>For example, the concepts of a circle and a triangle are related in that they are both shapes; that is, they have the concept of a shape in common.<ul>
<li>Thus, we explicitly define class <code>Circle</code> and class <code>Triangle</code> to have class <code>Shape</code> in common.</li>
<li>In that case, the common class, here <code>Shape</code>, is refered to as the <em><strong>base</strong></em> class or <em><strong>superclasses</strong></em> and classes derived from that, here <code>Circle</code> and <code>Triangle</code>, are refered to as <em><strong>derived</strong></em> classes or <em><strong>subclasses</strong></em>.</li>
<li>Representing a circle and a triangle in a program without involving the notion of a shape would be to miss something essential.</li>
</ul>
</li>
</ul>
<p>This chapter is an exploration of the implications of this simple idea, which is the basis for what is commonly called <em><strong>object-oriented programming</strong></em>.</p>
<p>The language features support building new classes from existing ones:</p>
<ul>
<li><em><strong>implementation inheritance</strong></em>: to save implementation effort by sharing facilities provided by a base class.</li>
<li><em><strong>Interface inheritance</strong></em>: to allow different derived classes to be used interchangeably through the interface provided by a common base class.</li>
</ul>
<p>Interface inheritance is often refered to as <em><strong>run-time polymorphism</strong></em> (or <em><strong>dynamic polymorphism</strong></em>).</p>
<p>In contrast, the uniform use of classes not related by inheritance provided by templates (section 3.4, Chapter 23) is often reffered to as <em><strong>compile-time polymorphism</strong></em> (or <em><strong>static polymorphism</strong></em>).</p>
</li>
</ol>
<ol start="4">
<li>The discussion of class hierarchies is organized into three chapters:<ul>
<li><em><strong>Derived Classes</strong></em> (Chapter 20): <ul>
<li>This chapter introduces the basic languge features supporting object-oriented programming.</li>
<li>Base and derived classes, virtual functionsm and access control are covered.</li>
</ul>
</li>
<li><em><strong>Class Hierarchies</strong></em> (Chapter 21):<ul>
<li>This chapter focuses on the use of base and derived classes to effectively organize code around the notion of class hierarchies.</li>
<li>Most of this chapter is devoted to discussion of programming techniques, but technical aspects of multiple inheritance (classes with more than one base class) are also covered.</li>
</ul>
</li>
<li><em><strong>Run-time Type Identification</strong></em> (Chapter 22):<ul>
<li>This chapter describes the techniques for explicitly navigating class hierarchies.</li>
<li>In particular, the type conversion operations <code>dynamic_cast</code> and <code>static_cast</code> are presented, as is the operation for determining the type of an object given one of its base classes (<code>typeid</code>).</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>A brief introduction to the basic idea of hierarchical organization of types can be found in Chapter 3: base and derived classes (section 3.2.2) and virtual functions (section 3.2.3).</p>
<p>These chapters (Chapter 20,21,22) examine these fundamental features and their associated programming and design techniques in greater detail.</p>
</li>
</ol>
<h3 id="20-2-Derived-Classes"><a href="#20-2-Derived-Classes" class="headerlink" title="20.2 Derived Classes"></a>20.2 Derived Classes</h3><ol start="6">
<li><p>Cosider building a program dealing with people employed by a firm.</p>
<ul>
<li><p>Such a program might have a data structure like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Employee</span> &#123;<br>    string first_name, family_name;<br>    <span class="hljs-type">char</span> middle_initial;<br>    Data hiring_date;<br>    <span class="hljs-type">short</span> department;<br>    /<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Next, we might try to define a manager:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Manager</span> &#123;<br>    Employee emp; <span class="hljs-comment">// manager&#x27;s empoyee record</span><br>    list&lt;Emplotee*&gt; group; <span class="hljs-comment">// people managed</span><br>    <span class="hljs-type">short</span> level;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>A manager is also an employee; the <code>Employee</code> data is stored in the <code>emp</code> member of a <code>Manager</code> object.</p>
<ul>
<li>This may be obvious to a human reader – especially a careful reader – but there is nothing that tells the compiler and other tools that <code>Manager</code> is also an <code>Employee</code>.</li>
</ul>
</li>
<li><p>A <code>Manager*</code> is not an <code>Employee*</code>, so one cannot simply use one where the other is required.</p>
<ul>
<li>In particular, one cannot put a <code>Manger</code> onto a list of <code>Employee</code>s without writing special code.</li>
<li>We could either use explicit type conversion on a <code>Manager*</code> or put the address of the <code>emp</code> member onto a list of <code>employee</code>s.</li>
<li>However, both solutions are inelegant and can be quite obscure.</li>
</ul>
</li>
<li><p>The correct approach is to explicitly state that a <code>Manager</code> is an <code>Employee</code>, with a few pieces of information added.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Manager</span> : <span class="hljs-keyword">public</span> Employee &#123;<br>    list&lt;Employee*&gt; group;<br>    <span class="hljs-type">short</span> level;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>The <code>Manager</code> is <em><strong>derived</strong></em> from <code>Employee</code>, and conversely, <code>Employee</code> is a <em><strong>base class</strong></em> for <code>Manager</code>.</li>
<li>The class <code>Manager</code> has the members of class <code>Employee</code> (<code>first_name</code>, <code>department</code>, etc.) in addition to its own members (<code>group</code>, <code>level</code>, etc.).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="7">
<li><p>Derivation is often represented graphically by a pointer from the derived class to its base class indicating that the derived class refers to its base (rather than other way around):</p>
<ul>
<li><img src="D:\obsidian\Louis\计算机专业知识\C++.assets\image-20230129145841357.png" srcset="/img/loading.gif" lazyload alt="image-20230129145841357"></li>
</ul>
<p>A derived class is often said to inherit properties from its base, so the relationship is also called <em><strong>inheritance</strong></em>.</p>
<p>A base class is sometimes called a <em><strong>superclass</strong></em> and a derived class a <em><strong>subclass</strong></em>. </p>
<ul>
<li>This terminology, however, is confusing to people who observe that the data in a derived class object is a superset of the data of an object of its base class.</li>
</ul>
<p>A derived class is typically larger (and never smaller) than its base class in the sense that it holds more data and provides more functions.</p>
</li>
</ol>
<h2 id="Chapter-21-Class-Hierarchies"><a href="#Chapter-21-Class-Hierarchies" class="headerlink" title="Chapter 21. Class Hierarchies"></a>Chapter 21. Class Hierarchies</h2><h2 id="Chapter-22-Run-Time-Type-Information"><a href="#Chapter-22-Run-Time-Type-Information" class="headerlink" title="Chapter 22. Run-Time Type Information"></a>Chapter 22. Run-Time Type Information</h2><h2 id="Chapter-23-Templates"><a href="#Chapter-23-Templates" class="headerlink" title="Chapter 23. Templates"></a>Chapter 23. Templates</h2><h2 id="Chapter-24-Generic-Programming"><a href="#Chapter-24-Generic-Programming" class="headerlink" title="Chapter 24. Generic Programming"></a>Chapter 24. Generic Programming</h2><h2 id="Chapter-25-Specialization"><a href="#Chapter-25-Specialization" class="headerlink" title="Chapter 25. Specialization"></a>Chapter 25. Specialization</h2><h2 id="Chapter-26-Instantiation"><a href="#Chapter-26-Instantiation" class="headerlink" title="Chapter 26. Instantiation"></a>Chapter 26. Instantiation</h2><h2 id="Chapter-27-Templates-and-Hierachies"><a href="#Chapter-27-Templates-and-Hierachies" class="headerlink" title="Chapter 27. Templates and Hierachies"></a>Chapter 27. Templates and Hierachies</h2><h2 id="Chapter-28-Metaprogramming"><a href="#Chapter-28-Metaprogramming" class="headerlink" title="Chapter 28. Metaprogramming"></a>Chapter 28. Metaprogramming</h2><h2 id="Chapter-29-A-Matrix-Design"><a href="#Chapter-29-A-Matrix-Design" class="headerlink" title="Chapter 29. A Matrix Design"></a>Chapter 29. A Matrix Design</h2><h1 id="The-C-Programming-Language-Part-Ⅳ-The-Standard-Liberary"><a href="#The-C-Programming-Language-Part-Ⅳ-The-Standard-Liberary" class="headerlink" title="The C++ Programming Language  Part Ⅳ : The Standard Liberary"></a>The C++ Programming Language  Part Ⅳ : The Standard Liberary</h1><h2 id="Chapter-30-Standard-Library-Summary"><a href="#Chapter-30-Standard-Library-Summary" class="headerlink" title="Chapter 30. Standard Library Summary"></a>Chapter 30. Standard Library Summary</h2><h2 id="Chapter-31-STL-container"><a href="#Chapter-31-STL-container" class="headerlink" title="Chapter 31. STL container"></a>Chapter 31. STL container</h2><h2 id="Chapter-32-STL-Algorithms"><a href="#Chapter-32-STL-Algorithms" class="headerlink" title="Chapter 32. STL Algorithms"></a>Chapter 32. STL Algorithms</h2><h2 id="Chapter-33-STL-Iterators"><a href="#Chapter-33-STL-Iterators" class="headerlink" title="Chapter 33. STL Iterators"></a>Chapter 33. STL Iterators</h2><h2 id="Chapter-34-Memory-and-Resources"><a href="#Chapter-34-Memory-and-Resources" class="headerlink" title="Chapter 34. Memory and Resources"></a>Chapter 34. Memory and Resources</h2><h2 id="Chapter-35-Utilities"><a href="#Chapter-35-Utilities" class="headerlink" title="Chapter 35. Utilities"></a>Chapter 35. Utilities</h2><h2 id="Chapter-36-Strings"><a href="#Chapter-36-Strings" class="headerlink" title="Chapter 36. Strings"></a>Chapter 36. Strings</h2><h2 id="Chapter-37-Regular-Expressions"><a href="#Chapter-37-Regular-Expressions" class="headerlink" title="Chapter 37. Regular Expressions"></a>Chapter 37. Regular Expressions</h2><h2 id="Chapter-38-I-O-Streams"><a href="#Chapter-38-I-O-Streams" class="headerlink" title="Chapter 38. I/O Streams"></a>Chapter 38. I/O Streams</h2><h2 id="Chapter-39-Locales"><a href="#Chapter-39-Locales" class="headerlink" title="Chapter 39. Locales"></a>Chapter 39. Locales</h2><h2 id="Chapter-40-Numberics"><a href="#Chapter-40-Numberics" class="headerlink" title="Chapter 40. Numberics"></a>Chapter 40. Numberics</h2><h2 id="Chapter-41-Concurrency"><a href="#Chapter-41-Concurrency" class="headerlink" title="Chapter 41. Concurrency"></a>Chapter 41. Concurrency</h2><h2 id="Chapter-42-Threads-and-Tasks"><a href="#Chapter-42-Threads-and-Tasks" class="headerlink" title="Chapter 42. Threads and Tasks"></a>Chapter 42. Threads and Tasks</h2><h2 id="Chapter-43-The-C-Standard-Library"><a href="#Chapter-43-The-C-Standard-Library" class="headerlink" title="Chapter 43. The C Standard Library"></a>Chapter 43. The C Standard Library</h2><h2 id="Chapter-44-Compatibility"><a href="#Chapter-44-Compatibility" class="headerlink" title="Chapter 44. Compatibility"></a>Chapter 44. Compatibility</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ Programming Language Notes</div>
      <div>http://example.com/2023/01/13/C-Programming-Language-Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 13, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/08/%E5%89%91%E6%8C%87offer/" title="剑指offer">
                        <span class="hidden-mobile">剑指offer</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
