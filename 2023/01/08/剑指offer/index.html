

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="V. Louis">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考书剑指offer 剑指 Offer 04. 二维数组中的查找 解题思路：从右下角往左上角查找，即一定程度的中间位置开始查找。 行减一表示当前值减小； 列加一表示当前值增加； 不断调整直到找到目标值。   注意点 ： 边界条件判断； matrix一维大小需要大于0；二维大小也要大于0。利用一个短路判定。 从左下往右上，i只会减少，j只会增加。所以只需要判断一侧的边界条件即可。     参考代码1">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="http://example.com/2023/01/08/%E5%89%91%E6%8C%87offer/index.html">
<meta property="og:site_name" content="V. Louis">
<meta property="og:description" content="参考书剑指offer 剑指 Offer 04. 二维数组中的查找 解题思路：从右下角往左上角查找，即一定程度的中间位置开始查找。 行减一表示当前值减小； 列加一表示当前值增加； 不断调整直到找到目标值。   注意点 ： 边界条件判断； matrix一维大小需要大于0；二维大小也要大于0。利用一个短路判定。 从左下往右上，i只会减少，j只会增加。所以只需要判断一侧的边界条件即可。     参考代码1">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-01-08T12:27:12.000Z">
<meta property="article:modified_time" content="2023-01-08T12:27:47.013Z">
<meta property="article:author" content="V. Louis">
<meta property="article:tag" content="algorithem">
<meta property="article:tag" content="剑指offer">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>剑指offer - V. Louis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Villian Louis&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="剑指offer"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-08 20:27" pubdate>
          January 8, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          46k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          384 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">剑指offer</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h1><p><a href="D:\OneDrive\Books\剑指Offer.pdf">剑指offer</a></p>
<h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h1><ul>
<li><strong>解题思路</strong>：从右下角往左上角查找，即一定程度的中间位置开始查找。<ul>
<li>行减一表示当前值减小；</li>
<li>列加一表示当前值增加；</li>
<li>不断调整直到找到目标值。</li>
</ul>
</li>
<li><strong>注意点</strong> ：<ul>
<li>边界条件判断；<ul>
<li>matrix一维大小需要大于0；二维大小也要大于0。利用一个短路判定。</li>
<li>从左下往右上，i只会减少，j只会增加。所以只需要判断一侧的边界条件即可。</li>
</ul>
</li>
</ul>
</li>
<li>参考代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 从右下角往左上角查找，即一定程度的中间位置开始查找。</span><br><br>        <span class="hljs-comment">// 行减一表示当前值减小</span><br><br>        <span class="hljs-comment">// 列加一表示当前值增加</span><br><br>        <span class="hljs-comment">// 不断调整直到找到目标值</span><br><br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 短路判定</span><br><br>        <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左下角坐标</span><br><br>        <span class="hljs-keyword">while</span> (i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &lt; m)&#123;<br><br>            <span class="hljs-keyword">if</span> (matrix[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target) --i;<br><br>            <span class="hljs-keyword">else</span> ++j;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><ul>
<li>两种思路：</li>
</ul>
<ol>
<li><p>创建新字符串：遍历，发现空格增加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 思路：遍历原字符串，新建结果字符串</span><br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        string result;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s)&#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c)) result += <span class="hljs-string">&quot;%20&quot;</span>;<br><br>            <span class="hljs-keyword">else</span> result += c;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在原有的内存位置上替换：保证有足够的内存空间，遍历空格确定最终长度，利用双指针替换。</p>
<ul>
<li>这里用C++语言实现的时候需要用到string类的 resize(<em>new length</em>)函数，获取扩充长度之后的字符串。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 遍历获取空格数量，使用双指针进行替换</span><br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">int</span> numberOfSpace = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c)) ++numberOfSpace;<br><br>        <span class="hljs-type">int</span> p = s.<span class="hljs-built_in">size</span>(), q = p + <span class="hljs-number">2</span> * numberOfSpace; <span class="hljs-comment">// p指向原字符串末尾/0, 从结尾字符串开始</span><br><br>        <span class="hljs-comment">/* 根据空格数量扩充数组大小 */</span><br><br>        s.<span class="hljs-built_in">resize</span>(q);<br><br>        <span class="hljs-keyword">while</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(s[p])) &#123;<br><br>                s[q--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>                s[q--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br><br>                s[q--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> s[q--] = s[p];<br><br>            --p;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s;<br><br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h1><ul>
<li>两种思路：需要考虑是否允许修改原链表。</li>
</ul>
<ol>
<li>不允许修改原链表。利用 <strong>栈</strong> 实现，可以显式用自己申请的vector作为栈，或是系统栈（递归）。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>	        vector&lt;<span class="hljs-type">int</span>&gt; myVector;<br>	<br>	        ListNode* p = head;<br>	<br>	        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>	<br>	            myVector.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>	<br>	            p = p-&gt;next;<br>	<br>	        &#125;<br>	<br>	        <span class="hljs-built_in">reverse</span>(myVector.<span class="hljs-built_in">begin</span>(), myVector.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 使用reverse() 函数</span><br>	<br>	        <span class="hljs-keyword">return</span> myVector;<br>	<br>	    &#125;<br><br><span class="hljs-comment">// 实现2</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>	        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>	<br> <br>	<br>	        vector&lt;<span class="hljs-type">int</span>&gt; myVector;<br>	<br>	        ListNode* p = head;<br>	<br>	        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>	<br>	            myVector.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>	<br>	            p = p-&gt;next;<br>	<br>	        &#125;<br>	<br>	        <span class="hljs-comment">// reverse(myVector.begin(), myVector.end());</span><br>	<span class="hljs-comment">// 不适用reverse，直接返回一个逆序</span><br>	        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(myVector.<span class="hljs-built_in">rbegin</span>(), myVector.<span class="hljs-built_in">rend</span>());<br><br>	    &#125;<br></code></pre></td></tr></table></figure></li>
<li>如果允许修改原链表，可以通过双指针就地逆置链表，最后实现遍历达到逆转链表的目的。</li>
</ol>
<h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h1><ul>
<li>解题思路：利用先序序列确定根节点，用根节点和中序序列对序列切割，递归完成构建二叉树的过程。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 利用递归实现</span><br><br>        <span class="hljs-keyword">if</span> (preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>  <br><br>        TreeNode* currentRoot = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-type">int</span> rootIndex = <span class="hljs-built_in">distance</span>(inorder.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">find</span>(inorder.<span class="hljs-built_in">begin</span>(), inorder.<span class="hljs-built_in">end</span>(), preorder[<span class="hljs-number">0</span>]));<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left_pre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span>, preorder.begin() + rootIndex + <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right_pre</span><span class="hljs-params">(preorder.begin() + rootIndex + <span class="hljs-number">1</span>, preorder.end())</span></span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left_ino</span><span class="hljs-params">(inorder.begin(), inorder.begin() + rootIndex)</span></span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right_ino</span><span class="hljs-params">(inorder.begin() + rootIndex + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br><br>  <br><br>        currentRoot-&gt;left = <span class="hljs-built_in">buildTree</span>(left_pre, left_ino);<br><br>        currentRoot-&gt;right = <span class="hljs-built_in">buildTree</span>(right_pre, right_ino);<br><br>        <span class="hljs-keyword">return</span> currentRoot;<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：利用两个栈来模拟，其中一个栈负责压栈，另外一个负责出栈。</p>
<ul>
<li>负责压栈的辅助栈stack1只需要支持压栈操作，不会出现其他的特殊情况。</li>
<li>负责出栈的辅助栈stack2需要哦考虑到<strong>出栈栈为空的特殊情况</strong> ，需要注意处理。<ul>
<li>当栈不为空，直接出栈即可；</li>
<li>当栈为空的时候，需要将辅助栈stack1中的元素倒入，因为栈是先进后出，而队列是先进先出，所以需要将栈stack1的末尾元素压栈到stack2的栈底。保证最后压入的元素，符合队列的后出的特性。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">CQueue</span>() &#123;<br><br>  <br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br><br>        myStack1.<span class="hljs-built_in">push</span>(value);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (!myStack2.<span class="hljs-built_in">empty</span>()) &#123;<br><br>            <span class="hljs-type">int</span> res = myStack2.<span class="hljs-built_in">top</span>();<br><br>            myStack2.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">return</span> res;<br><br>        &#125;<br><br>        <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-keyword">while</span> (!myStack1.<span class="hljs-built_in">empty</span>()) &#123;<br><br>                <span class="hljs-type">int</span> temp = myStack1.<span class="hljs-built_in">top</span>();<br><br>                myStack1.<span class="hljs-built_in">pop</span>();<br><br>                myStack2.<span class="hljs-built_in">push</span>(temp);<br><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!myStack2.<span class="hljs-built_in">empty</span>()) &#123;<br><br>                <span class="hljs-type">int</span> res = myStack2.<span class="hljs-built_in">top</span>();<br><br>                myStack2.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-keyword">return</span> res;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    stack&lt;<span class="hljs-type">int</span>&gt; myStack1, myStack2;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><p><strong>解题思路</strong> ：根据题意，旋转之后的数组具有很好的特性，即分为两个子数组，数组下标小的数组为较大值的非降序列，数组下标大的数组为较小值的非降序列。可以通过二分法进行查找，中间位置的元素与最右端元素之间存在三种确定的关系。</p>
<ul>
<li>中间位置元素 &lt; 最右端元素。此时说明这两个位置的都属于右端序列，而最小元素应该在中间位置元素的左侧或者就是中间元素。![[Pasted image 20220621103322.png]]</li>
<li>中间位置元素 &gt; 最右端元素。此时说明这两个位置属于不同的子数组，最小元素在此之间，并且一定在中间位置元素的右侧而不可能是中间位置元素。</li>
<li>![[Pasted image 20220621103333.png]]</li>
<li>中间位置元素 == 最右端元素。特殊情况，此时出现了很多重复元素，我们不能确定中间位置元素是位于哪一个子数组，但是可以确定的是最右端元素一定不是我们最终想要的结果，因为一定有一个小于或等于它的元素，位于其左侧。![[Pasted image 20220621103345.png]]<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 找出原本的升序首元素，即为答案</span><br><br>        <span class="hljs-comment">// 使用二分查找的思想</span><br><br>        <span class="hljs-type">int</span> lo = <span class="hljs-number">0</span>, hi = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (lo &lt; hi)&#123;<br><br>            <span class="hljs-type">int</span> mi = (lo + hi) &gt;&gt; <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">if</span> (numbers[mi] &gt; numbers[hi])&#123;<br><br>                <span class="hljs-comment">//中间位置的元素比右端元素大，说明首元素一定在此之间</span><br><br>                lo = mi + <span class="hljs-number">1</span>;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mi] &lt; numbers[hi])&#123;<br><br>                <span class="hljs-comment">//中间位置元素与最右端元素之间一定都是升序的，所以首元素一定在左端</span><br><br>                hi = mi;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">//特殊情况，此时numbers[mi] == numbers[hi],无法判断移动区间方向，缩短右侧</span><br><br>                --hi;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> numbers[lo];<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：非常简单，根据定义，使用迭代法求解。只需要三个临时变量作为滚动数组即可。</p>
<ul>
<li>根据定义已知 $f(0) = 0 , f(1) = 1$；</li>
<li>注意结果需求取模。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> f_pre = <span class="hljs-number">0</span>, f_p = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f_pre;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> f_p;<br><br>  <br><br>        <span class="hljs-type">int</span> f_n = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br><br>            f_n = (f_pre + f_p) % MOD;<br><br>            f_pre = f_p;<br><br>            f_p = f_n;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f_n;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：与上题基本一样，区别在于初始条件有所区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 斐波那契</span><br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> f_pre = <span class="hljs-number">1</span>, f_p = <span class="hljs-number">1</span>, f_n = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br><br>            f_n = (f_pre + f_p) % MOD;<br><br>            f_pre = f_p;<br><br>            f_p = f_n;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f_n;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>拓展</strong> <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&&tqId=11162&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">JZ71 跳台阶扩展问题</a></p>
<ul>
<li>解题思路：第n阶台阶可以从前面的所有n-1阶梯到达，所以有<ul>
<li>$f(n) = \Sigma_{i=0}^{i = n-1}f(i)$ ;</li>
<li>$f(0) = 1， f(1) = 1$;<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-comment">// 累加就行，因为第n阶台阶可以从前面的(n-1)台阶都可以到达</span><br>        <span class="hljs-comment">// f(n) = 2 * f(n-1)</span><br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span> || number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> f_pre = <span class="hljs-number">1</span>, f_p = <span class="hljs-number">1</span>, f_n = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= number; ++i) &#123;<br>            f_n *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f_n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
拓展<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">JZ70 矩形覆盖</a></li>
</ul>
</li>
<li>解题思路：$2 \times n$ 的矩阵，由 $2 \times 1$ 的小矩阵覆盖。可以简化为两种情况。![[Pasted image 20220621170241.png]]</li>
<li>$f(n) = f(n -1) + f(n - 2)$</li>
<li>采用类似的迭代思路求解。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-comment">// f(n) = f(n-1) + f(n-2)</span><br>        <span class="hljs-comment">// f(0) = 0, f(1) = 1;</span><br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span> || number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-type">int</span> f_pre = <span class="hljs-number">1</span>, f_p = <span class="hljs-number">1</span>, f_n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= number; ++i) &#123;<br>            f_n = f_pre + f_p;<br>            f_pre = f_p;<br>            f_p = f_n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f_n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h1><p><strong>解题思路</strong> ：</p>
<ol>
<li>可以通过不断移位，末尾使用掩码0x1来不断累加。对数时间复杂度。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (mask != <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (n &amp; mask) ++ans;<br><br>            mask = mask &lt;&lt; <span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>可以进一步改进。n &amp; (n - 1) 的结果，等价于将原数 n 的二进制形式中的最右端的 1 变为 0 。时间复杂度为二进制 1 个数的线性时间复杂度。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br><br>            n = n &amp; (n - <span class="hljs-number">1</span>);<br><br>            ++cnt;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cnt;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h1><p><strong>解题思路</strong> ：注意 n 的取值范围，n 可以为负数。</p>
<ul>
<li>利用快速指数幂方法快速求解幂。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 注意 n 的取值范围</span><br><br>        <span class="hljs-type">long</span> N = n;<br><br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">fastExponential</span>(x, N) : <span class="hljs-number">1.0</span> / <span class="hljs-built_in">fastExponential</span>(x, -N);<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fastExponential</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> n)</span></span>&#123;<br><br>        <span class="hljs-comment">// 计算 x的n次幂，n为正整数</span><br><br>        <span class="hljs-comment">// 快速指数幂方法</span><br><br>        <span class="hljs-type">double</span> result = <span class="hljs-number">1.0</span>;<br><br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) result *= x;<br><br>            x *= x;<br><br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h1><p><strong>解题思路</strong> ：利用双指针，一个从前往后，一个从后往前。前指针找到第一个偶数准备后放，后指针找到一个奇数准备前放。</p>
<ul>
<li>注意边界条件</li>
<li>数组大小小于等于1的时候不用操作，直接返回<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 双指针</span><br><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;<br><br>        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, q = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (p &lt; q) &#123;<br><br>            <span class="hljs-keyword">while</span> (nums[p] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; p &lt; q) ++p;<br><br>            <span class="hljs-keyword">while</span> (nums[q] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; p &lt; q) --q;<br><br>            <span class="hljs-built_in">swap</span>(nums[p], nums[q]);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><p><strong>解题思路</strong> ：经典的双指针问题，需要特别注意边界条件的考虑：</p>
<ul>
<li>如果头指针为空，k $\leq$ 0的情况，都直接返回空指针；</li>
<li>k的值大于链表的长度，需要特别注意前指针移动；间隔 k - 1步；</li>
<li>同步移动两个指针直达前指针到达结尾。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 典型的双指针</span><br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || k &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        ListNode* p = head, *q = p;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; ++i) &#123;<br><br>            <span class="hljs-keyword">if</span> (q-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br><br>                q = q-&gt;next;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (q-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// q 指向末尾非空结点为终止条件</span><br><br>            p = p-&gt;next;<br><br>            q = q-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：双指针问题，额外利用一个辅助指针。将链表视为两部分，前面的已经是完成逆转的，后面的是待逆转的。</p>
<ul>
<li>特殊情况判定，如果链表为空，或者链表中只有一个元素，都可以直接返回头指针；</li>
<li><strong>特别注意原头节点为结果链表的末尾结点，需要将其next指针置为空</strong></li>
<li>借用辅助指针记录后面的位置，完成不断反转链表。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 双指针</span><br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>  <br><br>        ListNode* p = head, *q = head-&gt;next;<br><br>        p-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//结果结点的末尾结点的next置为空</span><br><br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">nullptr</span>) &#123;<br><br>            ListNode *temp = q-&gt;next;<br><br>            q-&gt;next = p;<br><br>            p = q;<br><br>            q = temp;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：减而治之，采用递归或迭代的方法，不断将链表合并的问题规模变小。</p>
<ul>
<li><p>递归法</p>
<ul>
<li>两个链表的头节点相比，较小的作为最终结果加入；</li>
<li>进一步将问题规模减小1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 递归版</span><br><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l2;<br><br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l1;<br><br>  <br><br>        ListNode* currentNode = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br><br>            currentNode = l1;<br><br>            l1 = l1-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">else</span> &#123;<br><br>            currentNode = l2;<br><br>            l2 = l2-&gt;next;<br><br>        &#125;<br><br>        currentNode-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1, l2);<br><br>        <span class="hljs-keyword">return</span> currentNode;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>迭代法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 迭代版本</span><br><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l2;<br><br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l1;<br><br>  <br><br>        <span class="hljs-comment">// 两个指针都不为空的时候</span><br><br>        ListNode* head = <span class="hljs-literal">nullptr</span>, *tail = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br><br>            head = l1;<br><br>            l1 = l1-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">else</span> &#123;<br><br>            head = l2;<br><br>            l2 = l2-&gt;next;<br><br>        &#125; <span class="hljs-comment">// 确定头节点</span><br><br>        tail = head; <span class="hljs-comment">// 尾插法</span><br><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br><br>                tail-&gt;next = l1;<br><br>                l1 = l1-&gt;next;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br><br>                tail-&gt;next = l2;<br><br>                l2 = l2-&gt;next;<br><br>            &#125;<br><br>            tail = tail-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">nullptr</span>) tail-&gt;next = l1;<br><br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">nullptr</span>) tail-&gt;next = l2;<br><br>        <span class="hljs-keyword">return</span> head;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h1><p><strong>解题思路</strong> ：需要判断树A是否包含树B的这个子结构。所以需要对于A进行遍历，但是A遍历的过程中，如果遇到了与B树根节点相同的结点，则可能是树B子结构，所以需要进一步判断。</p>
<ul>
<li>树A结点与树B根节点相同，可能是，需要进一步判断。</li>
<li>判断过程中，需要注意，A的子结构可能比B树更大，所以有子结构的情况，一定是B树遍历完成了；而失败的情况一定是树A子结构中结点与B中不同，或者是A中直接没有对应的结点。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br><br>        <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;<br><br>  <br><br>        <span class="hljs-keyword">if</span> (A != <span class="hljs-literal">nullptr</span> &amp;&amp; B != <span class="hljs-literal">nullptr</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (A-&gt;val == B-&gt;val) &#123;<br><br>                result = <span class="hljs-built_in">DoesTree1HaveTree2</span>(A, B); <span class="hljs-comment">// 进一步判断</span><br><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">false</span>) &#123;<br><br>                result = <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B);<br><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">false</span>) &#123;<br><br>                result = <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DoesTree1HaveTree2</span><span class="hljs-params">(TreeNode* T1, TreeNode* T2)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (T2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (T1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <br><br>        <span class="hljs-keyword">if</span> (T1-&gt;val != T2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DoesTree1HaveTree2</span>(T1-&gt;left, T2-&gt;left) &amp;&amp; <span class="hljs-built_in">DoesTree1HaveTree2</span>(T1-&gt;right, T2-&gt;right);<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：二叉树的镜像，等价于自上向下，将根的两个左右孩子结点交换位置，不断向下，直达空结点（叶子结点的孩子）。</p>
<ul>
<li><p>递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <br>		<span class="hljs-comment">// 交换左右孩子</span><br>        TreeNode* temp = root-&gt;left;<br><br>        root-&gt;left = root-&gt;right;<br><br>        root-&gt;right = temp;<br><br><br>		<span class="hljs-comment">// 对子树递归镜像处理</span><br>        <span class="hljs-built_in">mirrorTree</span>(root-&gt;left);<br><br>        <span class="hljs-built_in">mirrorTree</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>迭代版本，利用队列层次遍历，逐个结点处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 迭代版本，利用队列进行层次遍历，对每个结点的左右孩子交换</span><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>  <br><br>        queue&lt;TreeNode*&gt; myQueue;<br><br>        myQueue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (!myQueue.<span class="hljs-built_in">empty</span>()) &#123;<br><br>            TreeNode* currentNode = myQueue.<span class="hljs-built_in">front</span>();<br><br>            myQueue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span> (currentNode != <span class="hljs-literal">nullptr</span>) &#123;<br><br>                myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;left);<br><br>                myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;right);<br><br>                <span class="hljs-built_in">swap</span>(currentNode-&gt;left, currentNode-&gt;right);<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：模拟打印过程，用四个位置的边界条件确定矩阵。</p>
<ul>
<li>![[Pasted image 20220623203112.png]]<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 模拟</span><br><br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>  <br><br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;<br><br>            <span class="hljs-comment">// 输出 [(top,left), (top, right)]</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = left; col &lt;= right; ++col) result.<span class="hljs-built_in">push_back</span>(matrix[top][col]);<br><br>            <span class="hljs-comment">// 输出 [(top+1, right), (bottom, right)]</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = top + <span class="hljs-number">1</span>; row &lt;= bottom; ++row) result.<span class="hljs-built_in">push_back</span>(matrix[row][right]);<br><br>            <span class="hljs-comment">// 根据情况判断是否存在, </span><br><br>            <span class="hljs-comment">// [(bottom, left + 1), (bottom, right - 1)]和[(bottom, left), (top - 1, left)]</span><br><br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = right - <span class="hljs-number">1</span>; col &gt; left; --col) result.<span class="hljs-built_in">push_back</span>(matrix[bottom][col]);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = bottom; row &gt; top; --row) result.<span class="hljs-built_in">push_back</span>(matrix[row][left]);<br><br>            &#125;<br><br>            <span class="hljs-comment">// 打印完一圈，更新边界条件</span><br><br>            ++top;<br><br>            --bottom;<br><br>            ++left;<br><br>            --right;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>  <br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：需要实时地不断更新当前栈中地最小值并且保存起来，才能实现 $O(1)$ 的min()。所以有两种思路，采用额外的辅助栈，或者是每次压栈或出栈都是当前值加上一个当前最小值一起操作。下面给出后者想法的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>  <br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><br>        myStack.<span class="hljs-built_in">push</span>(minValue);<br><br>        minValue = x &lt; minValue ? x : minValue;<br><br>        myStack.<span class="hljs-built_in">push</span>(x);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (!myStack.<span class="hljs-built_in">empty</span>()) &#123;<br><br>            myStack.<span class="hljs-built_in">pop</span>();<br><br>            minValue = myStack.<span class="hljs-built_in">top</span>();<br><br>            myStack.<span class="hljs-built_in">pop</span>();<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> myStack.<span class="hljs-built_in">top</span>();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> minValue;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    stack&lt;<span class="hljs-type">int</span>&gt; myStack;<br><br>    <span class="hljs-type">int</span> minValue = INT_MAX; <span class="hljs-comment">// 保存的是当前位置到栈底的最小值</span><br><br>&#125;;<br><br>  <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * int param_4 = obj-&gt;min();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h1 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h1><p><strong>解题思路</strong> ：直观的想法就是利用一个栈直接进行模拟。</p>
<ul>
<li>当栈顶元素刚好与当前想要的出栈序列的index元素相同的时候，就可以出栈，并且index加一，期待下一个出栈序列元素。需要保证栈不为空。</li>
<li>最终如果栈刚好为空，则说明完美匹配出栈序列，是合法的弹出序列。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pushed, vector&lt;<span class="hljs-type">int</span>&gt;&amp; popped)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 根据出栈序列模拟压栈</span><br><br>        stack&lt;<span class="hljs-type">int</span>&gt; myStack;<br><br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录目前模拟已经出栈的元素位置</span><br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> num : pushed) &#123;<br><br>            myStack.<span class="hljs-built_in">push</span>(num);<br><br>            <span class="hljs-keyword">while</span> (!myStack.<span class="hljs-built_in">empty</span>() &amp;&amp; myStack.<span class="hljs-built_in">top</span>() == popped[index]) &#123;<br><br>                myStack.<span class="hljs-built_in">pop</span>();<br><br>                ++index;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> myStack.<span class="hljs-built_in">empty</span>();<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h1><p><strong>解题思路</strong> ：就是要求层次遍历，利用一个队列实现即可。</p>
<ul>
<li>边界条件，root不为空。</li>
<li>队列不为空就一直循环，出队元素，再压入其不为空的孩子。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 树的层次遍历</span><br><br>        queue&lt;TreeNode *&gt; myQueue;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        myQueue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (!myQueue.<span class="hljs-built_in">empty</span>()) &#123;<br><br>            TreeNode* currentNode = myQueue.<span class="hljs-built_in">front</span>();<br><br>            myQueue.<span class="hljs-built_in">pop</span>();<br><br>            result.<span class="hljs-built_in">push_back</span>(currentNode-&gt;val);<br><br>  <br><br>            <span class="hljs-keyword">if</span> (currentNode-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br><br>                myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;left);<br><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (currentNode-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br><br>                myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;right);<br><br>            &#125;<br><br>        &#125; <br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h2></li>
</ul>
<p><strong>解题思路</strong> ：上面问题的一个变体，关键在于对于一层的处理之前，我们先记录该层有多少个需要出队的元素。</p>
<ul>
<li>利用一个循环控制出队元素个数；</li>
<li>一层的元素出队完成之后，作为一个子向量压入到结果向量中去。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-comment">// 层次遍历的遍历，可以记录每一层的个数</span><br><br>        <span class="hljs-comment">// 队列遵循先入先出，所以当前层的元素就是前num个元素</span><br><br>        queue&lt;TreeNode *&gt; myQueue;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) myQueue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (!myQueue.<span class="hljs-built_in">empty</span>()) &#123;<br><br>            <span class="hljs-type">int</span> num = myQueue.<span class="hljs-built_in">size</span>();<br><br>            vector&lt;<span class="hljs-type">int</span>&gt; currentLayer;<br><br>            <span class="hljs-keyword">while</span> (num--) &#123;<br><br>                TreeNode *currentNode = myQueue.<span class="hljs-built_in">front</span>();<br><br>                myQueue.<span class="hljs-built_in">pop</span>();<br><br>  <br><br>                currentLayer.<span class="hljs-built_in">push_back</span>(currentNode-&gt;val);<br><br>                <span class="hljs-keyword">if</span> (currentNode-&gt;left != <span class="hljs-literal">nullptr</span>) myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;left);<br><br>                <span class="hljs-keyword">if</span> (currentNode-&gt;right != <span class="hljs-literal">nullptr</span>) myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;right);<br><br>            &#125;<br><br>            result.<span class="hljs-built_in">push_back</span>(currentLayer);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h2><p><strong>解题思路</strong> ：上述问题的进一步变体，唯一的区别在于需要不断改变子向量的顺序。</p>
<ul>
<li>利用一个reverseFlag来决定是否逆转当前层子向量</li>
<li>完成一层子向量压入之后，reversFlag取反<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-comment">// 继续变体，可以利用一个reverseFlag来记录当前是否应该反转</span><br><br>        <span class="hljs-comment">// 只需要再将结果子向量压入结果向量之前逆转以下即可</span><br><br>        queue&lt;TreeNode *&gt; myQueue;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) myQueue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">bool</span> reverseFlag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (!myQueue.<span class="hljs-built_in">empty</span>()) &#123;<br><br>            <span class="hljs-type">int</span> num = myQueue.<span class="hljs-built_in">size</span>();<br><br>            vector&lt;<span class="hljs-type">int</span>&gt; currentLayer;<br><br>            <span class="hljs-keyword">while</span> (num--) &#123;<br><br>                TreeNode *currentNode = myQueue.<span class="hljs-built_in">front</span>();<br><br>                myQueue.<span class="hljs-built_in">pop</span>();<br><br>                currentLayer.<span class="hljs-built_in">push_back</span>(currentNode-&gt;val);<br><br>                <span class="hljs-keyword">if</span> (currentNode-&gt;left != <span class="hljs-literal">nullptr</span>) myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;left);<br><br>                <span class="hljs-keyword">if</span> (currentNode-&gt;right != <span class="hljs-literal">nullptr</span>) myQueue.<span class="hljs-built_in">push</span>(currentNode-&gt;right);<br><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (reverseFlag == <span class="hljs-literal">true</span>) <span class="hljs-built_in">reverse</span>(currentLayer.<span class="hljs-built_in">begin</span>(), currentLayer.<span class="hljs-built_in">end</span>());<br><br>            reverseFlag = !reverseFlag;<br><br>            result.<span class="hljs-built_in">push_back</span>(currentLayer);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h1><p><strong>解题思路</strong> ：以查错的方式进行验证是否是合法的后序遍历序列。</p>
<ul>
<li>注意这里是二叉搜索树，需要满足 左子树 &lt; 根节点 &lt; 右子树</li>
<li>根据二叉搜索树的这个性质进行递归验证子树</li>
<li>根节点就是序列的最后一个元素</li>
<li>根据根节点可以将序列划分成三部分：左子树得呃后序序列、右子树的后序序列、根节点。当然划分也需要满足二叉搜索树的性质，这也是排除该序列为后序序列的依据。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DivideAndConquer</span>(postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DivideAndConquer</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 闭区间 [start, end]</span><br><br>        <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 解题关键在于找错，是否存在违反二叉搜索树定义的点，递归到此说明都是合法的</span><br><br>        <span class="hljs-comment">// 二叉搜索树的特点，左子树 &lt; 根节点 &lt; 右子树</span><br><br>        <span class="hljs-comment">// 根节点postorder[end]</span><br><br>        <span class="hljs-type">int</span> index = start, root = postorder[end];<br><br>        <span class="hljs-keyword">while</span> (postorder[index] &lt; root) ++index;<br><br>        <span class="hljs-type">int</span> middle = index;<br><br>        <span class="hljs-keyword">while</span> (postorder[index] &gt; root) ++index;<br><br>        <span class="hljs-type">int</span> high = index; <br><br>        <span class="hljs-comment">// 需要保证两个子树序列都是合法的，即左子树都小于根，右子树都大于根</span><br><br>        <span class="hljs-comment">// index应该指向end位置才对</span><br><br>        <span class="hljs-keyword">return</span> (high == end) &amp;&amp; <span class="hljs-built_in">DivideAndConquer</span>(postorder, start, middle - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">DivideAndConquer</span>(postorder, middle, high - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：先序遍历，要找的是从根节点到叶子节点的路径。递归，直到叶子结点，不断去凑target。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-built_in">findPath</span>(root, target);<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPath</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 处理根节点，判断是否是符合条件的路径</span><br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br><br>        target -= root-&gt;val;<br><br>        <span class="hljs-type">bool</span> isLeaf = root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span> &amp;&amp; isLeaf) &#123;<br><br>            result.<span class="hljs-built_in">push_back</span>(path);<br><br>        &#125;<br><br>		<span class="hljs-comment">//递归左右子树</span><br>        <span class="hljs-built_in">findPath</span>(root-&gt;left, target); <br><br>        <span class="hljs-built_in">findPath</span>(root-&gt;right, target);<br><br>		<span class="hljs-comment">// 当前root结点左右子树执行完成，弹出作为路径。</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h1><p><strong>解题思路</strong> ：采用递归思路，用一个私有的无序映射，记录当前已经复制的原链表结点与复制后的结点的对应关系。</p>
<ul>
<li>如果头节点为空，链表为空，直接返回</li>
<li>头节点不为空，查询无序映射，确定待复制的当前的head所指的结点是否已经创建过。如果没有则进行创建，并且记录在映射中，然后递归复制next和random子链表。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">if</span> (!nodeCache.<span class="hljs-built_in">count</span>(head)) &#123; <span class="hljs-comment">// 当前head结点未被复制创建，下面创建。</span><br><br>            Node *currentNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br><br>            nodeCache[head] = currentNode;<br><br>            currentNode-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br><br>            currentNode-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nodeCache[head];<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    unordered_map&lt;Node*, Node*&gt; nodeCache; <span class="hljs-comment">// 存拷贝之后的结点指针与结点的对应关系</span><br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：利用二叉搜索树的特性，中序遍历的结果是有序的。</p>
<ul>
<li>构建双向链表，利用两个指针，一个currentTail，指向当前已经完成的双向链表最右端的结点。一个head结点，作为整个链表的头节点，只会有一个头节点，就是二叉搜索最左端结点。</li>
<li>中序遍历进行处理。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 二叉搜索树的中序遍历就是有序的</span><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-built_in">tree22List</span>(root); <span class="hljs-comment">// 处理完成获得的是一个双向链表，头尾指针需要单独处理。</span><br><br>        head-&gt;left = currentTail;<br><br>        currentTail-&gt;right = head;<br><br>        <span class="hljs-keyword">return</span> head;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    Node *currentTail = <span class="hljs-literal">nullptr</span>, *head = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tree22List</span><span class="hljs-params">(Node *currentNode)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (currentNode == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>  <br><br>        <span class="hljs-built_in">tree22List</span>(currentNode-&gt;left); <span class="hljs-comment">// 处理左子树</span><br><br>        <span class="hljs-keyword">if</span> (currentTail != <span class="hljs-literal">nullptr</span>) currentTail-&gt;right = currentNode; <span class="hljs-comment">//连接原有链表和当前结点</span><br><br>        <span class="hljs-keyword">else</span> head = currentNode; <span class="hljs-comment">// 头节点</span><br><br>        currentNode-&gt;left = currentTail; <span class="hljs-comment">// 当前结点反向连接原链表</span><br><br>        currentTail = currentNode; <span class="hljs-comment">// 更新currentTail</span><br><br>        <span class="hljs-built_in">tree22List</span>(currentNode-&gt;right); <span class="hljs-comment">// 处理右子树</span><br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：根据字符串，生成其字典序的所有排列。</p>
<ul>
<li>nextPermutation函数<ul>
<li>每次先从序列倒数第二的位置往左开始找顺序的位置，s[index] &lt; s[index + 1]。注意边界条件判断，如果没有，则说明已经找完了所有的排列，返回错误。</li>
<li>再从末尾往左找第一个大于s[index] 的数，s[index] &lt; s[j]。</li>
<li>找到之后替换两个位置。</li>
<li>将末尾的所有元素逆转，因为一轮nextPermutation之后，余下的这部分元素是降序排列的。</li>
</ul>
</li>
<li>初始化为顺序的字符串，压入结果向量中，然后根据nextPermuation不断压入新的排列，直到所有的排列都完成。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        vector&lt;string&gt; result;<br><br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">do</span> &#123;<br><br>            result.<span class="hljs-built_in">push_back</span>(s);<br><br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">nextPermutation</span>(s));<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; <span class="hljs-comment">// index后面至少还有一个j的位置。</span><br><br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= s[index + <span class="hljs-number">1</span>]) --index; <span class="hljs-comment">// 找到从右往左第一个s[index] &lt; s[index+1]位置</span><br><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不存在index，说明已经是最大的排列了，没有nextPermutation</span><br><br>        <span class="hljs-type">int</span> j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= s[j]) --j;<br><br>        <span class="hljs-built_in">swap</span>(s[index], s[j]);<br><br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + index + <span class="hljs-number">1</span>, s.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：摩尔投票法，数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。</p>
<ul>
<li>前提条件：存在这样的数字</li>
<li>用一个候选者，作为可能的目标</li>
<li>一个计数器，决定是否更换候选者</li>
<li>考虑容错，如果不存在这样的超过一半的元素，需要特别考虑，检查最终的结果。</li>
</ul>
<p><strong>还可以使用快速排序的思路来做</strong> ：出现次数超过一半，一定是统计意义上的中位数，通过不断随机选择元素并调整，一旦找到最终位置为中间位置的元素，就是目标元素。也需要容错检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 摩尔投票法</span><br><br>        <span class="hljs-type">int</span> candidate = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br><br>                candidate = nums[i];<br><br>                cnt = <span class="hljs-number">1</span>;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] != candidate) --cnt;<br><br>            <span class="hljs-keyword">else</span> ++cnt;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">moreThanHalf</span>(nums, candidate)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br><br>        <span class="hljs-keyword">return</span> candidate;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">moreThanHalf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> num)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> numCnt = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums) &#123;<br><br>            <span class="hljs-keyword">if</span> (n == num) ++numCnt;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> numCnt &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">面试题40. 最小的k个数</a></h1><p><strong>解题思路</strong> ：可以利用大顶堆实现，大顶堆的堆顶元素大于堆内的所有元素，所需我们只需要最小的k个元素，维护一个大小为k的大顶堆，依次插入元素并弹出最大元素，剩下的即为目标元素集合。<br><strong>还可以使用上面的快速排序partition思路来做</strong> ：一旦确定最终位置为k的元素，其左端及自身即为最终的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 利用大顶堆最容易实现</span><br><br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt; k) <span class="hljs-keyword">return</span> arr;<br><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; pQueue;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) pQueue.<span class="hljs-built_in">push</span>(arr[i]); <span class="hljs-comment">// 只需要O(k)空间</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><br>            pQueue.<span class="hljs-built_in">push</span>(arr[i]);<br><br>            pQueue.<span class="hljs-built_in">pop</span>();<br><br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp; res : result) &#123;<br><br>            res = pQueue.<span class="hljs-built_in">top</span>();<br><br>            pQueue.<span class="hljs-built_in">pop</span>();<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h1><p><strong>解题思路</strong> ：动态规划问题，对于长度为 $i$ 的连续子数组的最大和，记为 $maxSum(i) = f(i)$ ，对于长度为 $i + 1$ 的连续子数组的最大和为 $maxSum(i + 1) = max(nums[i + 1], f(i) + nums[i + 1]$ ，需要不断遍历更新整个数组，在遍历的过程中顺便记录下最大值。</p>
<ul>
<li>可以使用单独的dp数组，但是这里不需要记录过多的信息，只需要保存当前的几个状态信息：之前的以末尾元素构成的最长数组连续和，当前最大和。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> resultMax = nums[<span class="hljs-number">0</span>], currentSum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num : nums) &#123;<br><br>            currentSum = <span class="hljs-built_in">max</span>(currentSum + num, num);<br><br>            resultMax = <span class="hljs-built_in">max</span>(currentSum, resultMax);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> resultMax;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h1><p><strong>解题思路</strong> ：![[Pasted image 20220703165448.png]]</p>
<ul>
<li>用mulk表示 $10^k$ ，从低位到高位不同段统计数位为1的个数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mulk = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化为 10^0</span><br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; n &gt;= mulk; ++k) &#123; <span class="hljs-comment">// 从低位往高位枚举</span><br><br>            result += (n / (mulk * <span class="hljs-number">10</span>)) * mulk + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>((n % (mulk * <span class="hljs-number">10</span>)) - mulk + <span class="hljs-number">1</span>, <span class="hljs-number">0LL</span>), mulk);<br><br>            mulk *= <span class="hljs-number">10</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h1><p><strong>解题思路</strong> ：基本思路，想要组成最小的数，以两个元素{x, y}为例，需要按照两种可能的组合方式给两个数排序，及 x + y 与 y + x 的大小关系。因此根据这种新的排序规则，我们定义一个新的排序函数，将所有的待组合元素排序，最后将所有的元素拼接起来得到最终的结果，即为答案。</p>
<ul>
<li>int可能会溢出，转换为string类型，string可以直接用 + 拼接，比较大小。</li>
<li>利用修改之后的快速排序。<ul>
<li>选择数组最左端元素作为 pivot元素</li>
<li>确定pivot元素的最终位置，<ul>
<li>保证满足 numsString[左边的元素] + numsString[pivot] &lt;= numsString[pivot] + numsString[左边的元素]。</li>
<li>保证满足 numsString[pivot] + numsString[右边的元素] &lt;= numsString[右边的元素] + numsString[pivot]。 </li>
</ul>
</li>
<li>将pivot元素放入最终位置。</li>
<li>递归子数组排序。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// int类型的数据可能溢出，所以要转为string</span><br><br>        <span class="hljs-comment">// 根据新的排序规则对于待拼接数组进行排序，从而得到拼接结果</span><br><br>        vector&lt;string&gt; numsString;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br><br>            numsString.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(num));<br><br>        &#125;<br><br>        <span class="hljs-built_in">quickSort</span>(numsString, <span class="hljs-number">0</span>, numsString.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        string result;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : numsString) &#123;<br><br>            result += s;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;string&gt;&amp; numsString, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 利用快速排序的思想</span><br><br>        <span class="hljs-comment">// 新的排序规则: 对于字符串 x + y &lt; y + x ， 则有x &lt; y</span><br><br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> i = left, j = right;<br><br>        <span class="hljs-comment">// 将numsString[left] 作为 pivot元素</span><br><br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br><br>            <span class="hljs-comment">// 根据新的规则调整序列元素</span><br><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; (numsString[left] + numsString[j] &lt;= numsString[j] + numsString[left])) --j;<br><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; (numsString[i] + numsString[left] &lt;= numsString[left] + numsString[i])) ++i;<br><br>            <span class="hljs-built_in">swap</span>(numsString[i], numsString[j]);<br><br>        &#125; <span class="hljs-comment">// 循环终止条件 i == j</span><br><br>        <span class="hljs-built_in">swap</span>(numsString[i], numsString[left]);<br><br>        <span class="hljs-built_in">quickSort</span>(numsString, left, i - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">quickSort</span>(numsString, i + <span class="hljs-number">1</span>, right);<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h1><p><strong>解题思路</strong> ：找第n个丑数，动态规划，不断将2，3，5的倍数作为丑数加入到结果数组中。</p>
<ul>
<li>1是第一个丑数</li>
<li>每次加入结果中的丑数是三个倍数中最小的数</li>
<li>三个数的倍数可能是相同的数，即该丑数同时是2，3，5若干数的倍数</li>
<li>需要保证不重复<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> pointer_2 = <span class="hljs-number">1</span>, pointer_3 = <span class="hljs-number">1</span>, pointer_5 = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br><br>            <span class="hljs-type">int</span> multiple_2 = dp[pointer_2] * <span class="hljs-number">2</span>;<br><br>            <span class="hljs-type">int</span> multiple_3 = dp[pointer_3] * <span class="hljs-number">3</span>;<br><br>            <span class="hljs-type">int</span> multiple_5 = dp[pointer_5] * <span class="hljs-number">5</span>;<br><br>  <br><br>            dp[i] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(multiple_2, multiple_3), multiple_5);<br><br>            <span class="hljs-keyword">if</span> (dp[i] == multiple_2) ++pointer_2;<br><br>            <span class="hljs-keyword">if</span> (dp[i] == multiple_3) ++pointer_3;<br><br>            <span class="hljs-keyword">if</span> (dp[i] == multiple_5) ++pointer_5;<br><br>        &#125; <br><br>        <span class="hljs-keyword">return</span> dp[n];<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h1><p><strong>解题思路</strong> ：利用hash表计数，两次遍历即可。</p>
<ul>
<li>第一次遍历计数各字符出现的次数</li>
<li>第二次遍历找出出现一次的字符</li>
<li>利用unordered_map方便实现，利用vector也可以。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; myUnorderMap;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br><br>            myUnorderMap[c] += <span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br><br>            <span class="hljs-keyword">if</span> (myUnorderMap[c] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> c;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h1><p><strong>解题思路</strong> ：分治法处理，基于归并排序，并在归并序列的过程中，计数逆序对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(nums, temp, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 利用分治法，不断归并来计数逆序对数</span><br><br>        <span class="hljs-comment">// nums:待处理数据</span><br><br>        <span class="hljs-comment">// temp:辅助用的中间数组,记录每一轮的有序结果</span><br><br>        <span class="hljs-comment">// 闭区间 [left, right] 分为两部分递归处理 [left, middle], [middle + 1, right]</span><br><br>  <br><br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <br><br>        <span class="hljs-comment">// 1.分：分为两个子序列[left, middle], [middle + 1, right]递归处理子序列</span><br><br>        <span class="hljs-type">int</span> middle = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> countInversions = <span class="hljs-built_in">mergeSort</span>(nums, temp, left, middle) + <span class="hljs-built_in">mergeSort</span>(nums, temp, middle + <span class="hljs-number">1</span>, right);<br><br>  <br><br>        <span class="hljs-comment">// 2.治：已有两个有序子序列，归并并计数逆序对</span><br><br>        <span class="hljs-type">int</span> i = left, j = middle + <span class="hljs-number">1</span>, index = left; <span class="hljs-comment">// 两个子序列的工作指针,index 纪录归并结果的指针</span><br><br>        <span class="hljs-keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= right) &#123;<br><br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br><br>                <span class="hljs-comment">// 注意这里优先放入左边序列的值到最终结果中，因为相同的数不是逆序对</span><br><br>                temp[index++] = nums[i++];<br><br>                <span class="hljs-comment">// 只有左边序列的数往结果数组中放的时候，才说明是逆序的，仅此而已。</span><br><br>                <span class="hljs-comment">// 因为此时左边序列的当前值nums[i](i自增之前的值)是大于右边序列nums[j]之前的所有数，总数为(j - (middle + 1))</span><br><br>                countInversions += (j - (middle + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 右边序列 nums[j] 之前的元素个数</span><br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br><br>                temp[index++] = nums[j++];<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 特殊情况处理，因为可能会出现有序列之一没有遍历完成</span><br><br>        <span class="hljs-comment">// case 1：左侧序列没有遍历完成</span><br><br>        <span class="hljs-keyword">while</span> (i &lt;= middle) &#123;<br><br>            temp[index++] = nums[i++];<br><br>            countInversions += j - (middle + <span class="hljs-number">1</span>);<br><br>        &#125;<br><br>        <span class="hljs-comment">// case 2: 右边的序列没有处理完</span><br><br>        <span class="hljs-keyword">while</span> (j &lt;= right) &#123;<br><br>            temp[index++] = nums[j++];<br><br>        &#125;<br><br>        <span class="hljs-comment">// 复制temp中的有序序列到原来的nums对应位置中去</span><br><br>        <span class="hljs-built_in">copy</span>(temp.<span class="hljs-built_in">begin</span>() + left, temp.<span class="hljs-built_in">begin</span>() + right + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">begin</span>() + left); <span class="hljs-comment">// 拷贝的是闭区间[left, right]</span><br><br>        <span class="hljs-comment">// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!特别小心，这里是都是从begin()开始的偏移位置</span><br><br>        <span class="hljs-keyword">return</span> countInversions;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h1><p><strong>解题思路</strong> ：很容易想到双指针。但是可以更巧妙。</p>
<ul>
<li>两个链表有公共结点，那么一定是在末尾对齐的某一个位置上。</li>
<li>所以一种方法可以考虑记录长度，然后长的链表对其短的链表，然后同步移动寻找公共结点。</li>
<li>另一种思路可以参考leetcode，更简便。![[Pasted image 20220706172352.png]]</li>
</ul>
<p><strong>方法 1</strong> ：直接遍历记录长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br><br>        ListNode* pA = headA, *pB = headB;<br><br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (pA) &#123; <span class="hljs-comment">// 记录链表A的长度</span><br><br>            ++lenA;<br><br>            pA = pA-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (pB) &#123; <span class="hljs-comment">//记录链表B的长度</span><br><br>            ++lenB;<br><br>            pB = pB-&gt;next;<br><br>        &#125;<br>	<br>		<span class="hljs-comment">// 按末尾将两个链表的起点对齐</span><br>        pA = headA, pB = headB;<br><br>        <span class="hljs-keyword">while</span> (lenA &gt; lenB) &#123; <br><br>            pA = pA-&gt;next;<br><br>            --lenA;<br><br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (lenA &lt; lenB) &#123;<br><br>            pB = pB-&gt;next;<br><br>            --lenB;<br><br>        &#125;<br><br>		<span class="hljs-comment">// 对其之后的两个链表指针同步移动，寻找公共结点</span><br>        <span class="hljs-keyword">while</span> (pA &amp;&amp; pB) &#123;<br><br>            <span class="hljs-keyword">if</span> (pA == pB) <span class="hljs-keyword">return</span> pA;<br><br>            pA = pA-&gt;next;<br><br>            pB = pB-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>方法 2</strong> ：参考leetcode，如果两个链表的长度不等，先遍历完的指针就指向另外的指针，而另一个指针遍历完也采用相同的操作。最坏情况就是两个指针分别遍历了两个链表依次，都在链表都回合了，此时pA == pB == nullptr。</p>
<ul>
<li>这样处理就需要判断两个链表其一是否为空。可以快速处理特殊情况，不加也不会有影响。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        ListNode* pA = headA, *pB = headB;<br><br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br><br>            pA = pA == <span class="hljs-literal">nullptr</span> ? headB : pA-&gt;next; <span class="hljs-comment">// 如果先遍历完，就将其重置为另外链表表头</span><br><br>            pB = pB == <span class="hljs-literal">nullptr</span> ? headA : pB-&gt;next; <span class="hljs-comment">// 至多两轮就可以同时到达链表尾。</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pA;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h1><p><strong>解题思路</strong> ：很直观的想法是用二分查找。根据邓俊辉老师的课程中实现的二分查找函数，可以返回最大的不大于带查找目标元素的下标。</p>
<ul>
<li>利用二分查找找到最大不大于目标的位置，如果有多个相同元素，返回的是最大的下标。</li>
<li>再利用二分查找找到最大不大于（目标 - 1）的位置</li>
<li>两个位置的差值就是目标数重复的次数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums, target) - <span class="hljs-built_in">binarySearch</span>(nums, target - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 左闭右开区间[low, high)</span><br><br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br><br>            <span class="hljs-type">int</span> middle = (low + high) &gt;&gt; <span class="hljs-number">1</span>; <br><br>            (target &lt; nums[middle]) ? high = middle : low = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// 条件是小于</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> --low; <span class="hljs-comment">// 需要自减1</span><br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h1><p><strong>解题思路</strong> ：很容易想到BFS和DFS。</p>
<ul>
<li><p>BFS需要借助队列，并且与之前的32题相似![[剑指offer 二刷笔记#剑指 Offer 32 - II 从上到下打印二叉树 II https leetcode cn problems cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof]]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; Q;<br>        Q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> sz = Q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (sz &gt; <span class="hljs-number">0</span>) &#123;<br>                TreeNode* node = Q.<span class="hljs-built_in">front</span>();Q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) Q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) Q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                sz -= <span class="hljs-number">1</span>;<br>            &#125;<br>            ans += <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>DFS，实现跟简单，只需要考虑左右子树的高度最大值，加上根节点本身的高度1即可。递归处理子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <br><br>        <span class="hljs-type">int</span> depth = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> depth;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h1><p><strong>解题思路</strong> ：很容易根据定义直到怎么处理，关键在于对于树的深度如何有效地处理。</p>
<ul>
<li>可以显示地求出子树地高度再判断，但是会重复计算很多，效率不够。</li>
<li>考虑后序遍历，刚好可有有效地满足本题地需求。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBalanced</span>(root, depth);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span>&amp; depth)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 因为需要判断二叉平衡树，需要直到子树的高度</span><br><br>        <span class="hljs-comment">// 利用树的后序遍历可以很巧妙地实现这一点</span><br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br><br>            depth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果为空，则树的高度为0</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        &#125;<br><br>  <br><br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isBalanced</span>(root-&gt;left, leftDepth) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right, rightDepth)) &#123; <span class="hljs-comment">// 左右子树</span><br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftDepth - rightDepth) &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 根节点处理：左右子树都是平衡的</span><br><br>                depth = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftDepth, rightDepth); <span class="hljs-comment">// 根节点的深度加1</span><br><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回树为平衡二叉树</span><br><br>            &#125;<br><br>        &#125; <br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 根节点处理：左右子树不平衡</span><br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h1><p><strong>解题思路</strong> ：数学知识，异或的使用：相同的两个数的异或结果为0。</p>
<ul>
<li>$a$ ^ $a$ = 0</li>
<li>$a$ ^ $a$ ^ $b$ = $b$</li>
<li>一共只有两个数是只出现一次的, 记为a, b，所以对全体所有数的异或结果xorResult，就是两个出现一次的数的异或结果</li>
<li>根据这个异或结果xorResult，对于其中不为0的位，一定是两个出现一次的数a ^ b 的结果，找出位为 1 的位，一定是a 和 b 不同的位（根据异或的定义）。</li>
<li>根据这个为 1 的位，可以将数组分成两个组，而两个组中的元素一定是两两一对加上出现一次的数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> xorResult = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br><br>            xorResult ^= num;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 需要第一个非0的异或位，用这个位将原来的nums分为两个组</span><br><br>        <span class="hljs-comment">// 因为两个数是不同异或结果，所以该位一定可以将两个出现一次的数字分到两个组中。</span><br><br>        <span class="hljs-type">int</span> mask = <span class="hljs-number">0x1</span>;<br><br>        <span class="hljs-keyword">while</span> ((mask &amp; xorResult) == <span class="hljs-number">0</span>) mask &lt;&lt;= <span class="hljs-number">1</span>;<br><br>  <br><br>        <span class="hljs-type">int</span> num1 = <span class="hljs-number">0</span>, num2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储两个结果，分组异或的结果就是目标的出现一次的两个数</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br><br>            <span class="hljs-keyword">if</span> (num &amp; mask) num1 ^= num;<br><br>            <span class="hljs-keyword">else</span> num2 ^= num;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;num1, num2&#125;;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h1><p><strong>解题思路</strong> ：有序数组，目标是合为s的两个数。双指针，不断调整low和high去寻找目标。</p>
<ul>
<li>特殊情况，数组的大小 $\leq$ 1，不符合条件，直接返回空。</li>
<li>正常情况，直接寻找nums[low] + nums[high] == target 的值。</li>
<li>nums[low] + nums[high] &lt; target ，就让 low += 1；</li>
<li>nums[low] + nums[high] &gt; target ，就让 high -= 1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 双指针</span><br><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br><br>            <span class="hljs-type">int</span> currentSum = nums[low] + nums[high];<br><br>            <span class="hljs-keyword">if</span> (currentSum == target) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[low], nums[high]&#125;;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentSum &lt; target) ++low;<br><br>            <span class="hljs-keyword">else</span> --high; <br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h1><p><strong>解题思路</strong> ：题意是要寻找满足合为s的所有连续正整数序列。考虑滑动窗口。</p>
<ul>
<li>采用左开右闭区间 $[low, high)$，当区间的元素之和为s的时候就是我们想要的结果。</li>
<li>从窗口为0，正整数 1 开始滑动窗口。</li>
<li>得到一个连续的序列之和，需要继续寻找下一个序列，此时滑动窗口。无论滑动low还是high之一，都需要在滑动对应的high或low一次。因为如果low右移，值一定是小于 s，所以一定会右移 high。如果右移high，一定会大于 s，所以一定会右移 low。故此时可以同时移动 low 和 high。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-comment">// 寻找的返回是正整数序列</span><br><br>        <span class="hljs-comment">// 滑动窗口，左闭右开区间[low, high)</span><br><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>, high = <span class="hljs-number">1</span>; <span class="hljs-comment">// 窗口大小为0</span><br><br>        <span class="hljs-type">int</span> currentSum = <span class="hljs-number">0</span>;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>  <br><br>        <span class="hljs-keyword">while</span> (low &lt;= target / <span class="hljs-number">2</span>) &#123; <br><br>            <span class="hljs-comment">//因为寻找的是正整数序列，所以当最小的数low都大于target的时候，不可能加上high能够=target</span><br><br>            <span class="hljs-keyword">if</span> (currentSum &lt; target) &#123;<br><br>                <span class="hljs-comment">// 区间[low, high)内的元素和是符合条件的连续正整数序列，记录结果</span><br><br>                currentSum += high;<br><br>                ++high;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentSum &gt; target) &#123;<br><br>                currentSum -= low;<br><br>                ++low;<br><br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br><br>                vector&lt;<span class="hljs-type">int</span>&gt; currentResult;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = low; i &lt; high; ++i) &#123;<br><br>                    currentResult.<span class="hljs-built_in">push_back</span>(i);<br><br>                &#125;<br><br>                result.<span class="hljs-built_in">push_back</span>(currentResult);<br><br>                <span class="hljs-comment">// low, high同时往右调整</span><br><br>                currentSum -= low;<br><br>                currentSum += high;<br><br>                ++low;<br><br>                ++high;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h1><p><strong>解题思路</strong> ：逆转链表常规思路。</p>
<ul>
<li>$(A^TB^T)^T = BA$</li>
<li>自己实现得reverse函数比调用算法库里得快很多。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">reverse</span>(s, n, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> s;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br><br>            <span class="hljs-built_in">swap</span>(s[low], s[high]);<br><br>            ++low;<br><br>            --high;<br><br>        &#125;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h1><p><strong>解题思路</strong> ：与上一题58-Ⅱ类似。</p>
<ul>
<li>可以考虑先逆转整个序列，在处理每个单词。</li>
<li>只有空格字符串返回空字符串</li>
<li>这里参考leetcode解题思路<ul>
<li>首先逆转整个字符串</li>
<li>再找到第一个不为空格的地方起点，说明接下来有新的单词要逆转。非首单词添加空格将他们隔开。</li>
<li>通过end不断往后找单词结束的地方，并且不断往前移位到最终位置</li>
<li>逆转单词，将start赋值为end继续循环</li>
<li>需要利用erase函数将s的末尾空格去除。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> resultIdx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 指向结果字符串末尾后一位置</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; n; ++start) &#123;<br><br>            <span class="hljs-keyword">if</span> (s[start] != <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 多个空格都跳过</span><br><br>                <span class="hljs-keyword">if</span> (resultIdx != <span class="hljs-number">0</span>) s[resultIdx++] = <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// 马上又要加入新的结果单词，用空格分隔</span><br><br>                <span class="hljs-type">int</span> end = start;<br><br>                <span class="hljs-keyword">while</span> (end &lt; n &amp;&amp; s[end] != <span class="hljs-string">&#x27; &#x27;</span>) s[resultIdx++] = s[end++]; <span class="hljs-comment">// 将end一直后移，直到遇到第一个空格或末尾</span><br><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + resultIdx - (end - start), s.<span class="hljs-built_in">begin</span>() + resultIdx);<br><br>                start = end;<br><br>            &#125;<br><br>        &#125;<br><br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + resultIdx, s.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> s;<br><br>    &#125;<br><br>  <br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h1></li>
</ul>
</li>
</ul>
<p><strong>解题思路</strong> ：要构成题中的顺子，意思就是需要连续，但是可以用joker来替代任意牌。</p>
<ul>
<li>对于顺子排序，<strong>最大的牌 - 最小的牌 &lt; 5</strong> 的，一旦超过了，那么不可能用joker替换了，这种情况直接返回false</li>
<li>对于可以用joker替换的情况，排序之后，除joker以外的最大牌和最小牌应该也是符合最大的牌 - 最小的牌 &lt; 5的</li>
<li>joker数量需要记录，这样可以找到最小的非joker牌</li>
<li>最大的牌就是nums[4]</li>
<li>最大的牌 - 最小的牌(非joker) &lt; 5 –&gt; nums[4] - nums[joker]<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 排序</span><br><br>        <span class="hljs-comment">// 如果有相同的0，则++joker</span><br><br>        <span class="hljs-comment">// 如果是相同的其他数字，则一定不可能是顺子</span><br><br>        <span class="hljs-comment">// 最后，如果是顺子，则最大的牌与最小的牌的差距一定是小于5的，即最大到最小值之间不超过5，而最小值为nums[joker]</span><br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> joker = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br><br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) ++joker;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：约瑟夫环问题，每次从剩余的序列中删除第m个数字 (循环取余)。</p>
<ul>
<li>第一次删除的第m个元素</li>
<li>第二次删除的是相对于m位置之后m个位置的元素</li>
<li>用 $f(n,m)$ 该函数的返回值为最终留下的元素的序号。![[Pasted image 20220711184358.png]]<ul>
<li>$f(n,m) = (f(n - 1) + m) \ % \ n$   ，即删除第m个位置元素之后，需要从序列长度为n-1的序列中去删除第m个元素，直到剩最后一个元素。而相对于原来数组的下标位置就是 $(f(n - 1) + m) \ % \ n$ </li>
<li>序列长度为 1 的时候，数组下标为0，这是唯一的元素，所有就是结果，直接返回。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(n, m);<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">f</span>(n - <span class="hljs-number">1</span>, m);<br><br>        <span class="hljs-keyword">return</span> (m + x) % n; <span class="hljs-comment">// 第一次删除第m个位置的元素，第二次删除的是第m个位置加f(n - 1, m)位置元素。都是原数组位置。</span><br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 迭代</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> f = <span class="hljs-number">0</span>; <span class="hljs-comment">// f 代表 f(n, m)</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123; <span class="hljs-comment">// i 代表n的取值，从2 --&gt; n</span><br><br>            f = (f + m) % i;  <span class="hljs-comment">// 每次在原来序列的删除第m个元素留下最后一个元素的基础上，加上m，再对序列长度取余，</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f;<br><br>    &#125;<br><br>  <br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h1><p><strong>解题思路</strong> ：不能使用条件判断语句，考虑使用逻辑运算符 &amp;&amp; ，利用其判断能力和短路机制可以很有效解决问题。</p>
<ul>
<li>A &amp;&amp; B 为真，当且仅当 A 和 B 同时为真</li>
<li>A 为假，则不会执行 B</li>
<li>值得好好学习<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        n &amp;&amp; (n += <span class="hljs-built_in">sumNums</span>(n - <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">return</span> n;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h1><p><strong>解题思路</strong> ：用位运算模拟加法。计算机存整数是二进制形式</p>
<ul>
<li>二进制形式的数，不进位的加法 $\Leftrightarrow$ 二进制异或运算 ^</li>
<li>二进制形式的数，进位 $\Leftrightarrow$ 二进制与运算 &amp;</li>
<li>C++中负数不支持移位，本题中可能为负数，所以需要注意类型转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 利用二进制位运算做整数加法</span><br><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, carry = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">do</span> &#123;<br><br>            sum = a ^ b; <span class="hljs-comment">// 用异或运算模拟二进制加法，只有0-1，1-0相加才是1，0-0，1-1相加为0</span><br><br>            carry = (<span class="hljs-type">unsigned</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 用与运算模拟二进制进位，只有1-1才会才会产生进位.</span><br><br>                                            <span class="hljs-comment">//C++中负数不支持左移位，因为结果是不定的</span><br><br>            a = sum; <span class="hljs-comment">// 接下来将进位和求和结果相加就是最终结果</span><br><br>            b = carry; <span class="hljs-comment">// 因为可能存在多次进为，所以需要一直加到进位为0位置</span><br><br>        &#125; <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> a;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h1></li>
</ul>
<p><strong>解题思路</strong> ：本题可以使用状态机解，但是不够直观简单。采用模拟法直接模拟，注意边界条件。</p>
<ul>
<li>分别存储符号位和绝对值</li>
<li>给定的字符串前面可能存在多个空格，所以使用一个循环跳过所有的空格</li>
<li>在出现数字之前可能出现一个符号位，判断该符号位，如果为 ‘-’ 则符号位取 -1</li>
<li>对于绝对值结果就是不断乘10加当前位值，<ul>
<li>最大的int值绝对值为 INT_MAX</li>
<li>最小的int值绝对值为 INT_MAX + 1</li>
</ul>
</li>
<li>最终的返回结果就是符号位乘上绝对值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> currentIndex = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (str[currentIndex] == <span class="hljs-string">&#x27; &#x27;</span>) ++currentIndex; <span class="hljs-comment">// 跳过空格</span><br><br>        <span class="hljs-keyword">if</span> (currentIndex == str.<span class="hljs-built_in">size</span>() || (!<span class="hljs-built_in">isdigit</span>(str[currentIndex]) &amp;&amp; str[currentIndex] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; str[currentIndex] != <span class="hljs-string">&#x27;+&#x27;</span>))&#123;<br>			<span class="hljs-comment">// 判读除去前面多个空格之后的是否还有可能为数字</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (str[currentIndex] == <span class="hljs-string">&#x27;-&#x27;</span> || str[currentIndex] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (str[currentIndex] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br><br>                sign = <span class="hljs-number">-1</span>;<br><br>            &#125;<br><br>            ++currentIndex;<br><br>        &#125;<br><br>  <br><br>        <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;  <span class="hljs-comment">// int 可能会越界</span><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(str[currentIndex]) &amp;&amp; currentIndex &lt; str.<span class="hljs-built_in">size</span>()) &#123;<br><br>            result = result * <span class="hljs-number">10</span> + (str[currentIndex] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>            ++currentIndex;<br><br>            <span class="hljs-keyword">if</span> (result &gt;= INT_MAX &amp;&amp; sign == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INT_MAX;<br><br>            <span class="hljs-keyword">if</span> (result &gt; INT_MAX &amp;&amp; sign == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> INT_MIN;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sign * result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h1><p><strong>解题思路</strong> ：暴力法可以解，但是不够高效。仔细分析有如下结论：假设 $A[0..n-1]$ –&gt; $B[0..n-1]$</p>
<ul>
<li>$B[i] = \prod \limits_{j \neq i}^{n-1} A[j]$</li>
<li>$B[i] = \prod \limits_{j = 0}^{i-1} A[j] * \prod \limits_{j = i + 1}^{n-1} A[j]$ </li>
<li>将 $B[i]$ 的求解看成是两个阶段，第一个阶段先计算小于 $i$ 的前半部分的乘积，而这里显然可以利用之前的计算结果来快速求得后一元素的结果，$B[i] = \prod \limits_{j = 0}^{i-1} A[j] = (\prod \limits_{j = 0}^{i-2} A[j]) * A[i - 1] = B[i - 1] * A[i - 1]$ </li>
<li>第二阶段，需要用一个变量来存当前的累积乘积，与第一阶段类似。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">constructArr</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        <span class="hljs-comment">// B[i] = a[0] * .. * a[i - 1] * a[i + 1] * .. * a[n - 1], 可以以i为界分为两部分</span><br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">B</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 申请结果向量存储结果B，与a大小相同，初始化为全1</span><br><br>        <span class="hljs-comment">// 1.首先计算 B[i] = a[0] * .. * a[i - 1], 可以利用B[i] = B[i - 1] * a[i - 1]，基于前面计算结果，一步乘法就可</span><br><br>        <span class="hljs-comment">// B[0] = 1</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br><br>            B[i] = B[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]; <br><br>        &#125;<br><br>  <br><br>        <span class="hljs-comment">// 2.计算B[i] = B[i] * a[i + 1] * .. * a[n - 1]，基于前面的结果继续累乘</span><br><br>        <span class="hljs-comment">// B[n - 1] = B[n - 1]</span><br><br>        <span class="hljs-type">int</span> currentProduct = <span class="hljs-number">1</span>; <span class="hljs-comment">// 暂存变量，存储 a[n - 1] * .. * a[i + 1] 的乘积，方便用于之后的计算</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br><br>            currentProduct *= a[i + <span class="hljs-number">1</span>];<br><br>            B[i] *= currentProduct;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> B;<br><br>    &#125;<br><br>&#125;;<br>```  <br><br># [剑指 Offer <span class="hljs-number">19.</span> 正则表达式匹配](https:<span class="hljs-comment">//leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)</span><br>**解题思路** ：关键在于 * 的多字母匹配。<br>- 模式串中第二个字符不是 * ，则可以直接比较模式串与字符串是否相同，或者看模式串中是否是 . （可以匹配任意一个字符），然后递归处理其余的字符串和模式串。<br>- 模式串中第二个字符是 * ，则可以分为两种情况，因为 * 可以匹配多个或者一个字符。结果都需要 &amp;&amp; 当前字符的匹配结果，如果当前不匹配，则不应该继续之后的匹配<br>	- 匹配 <span class="hljs-number">0</span> 个字符，则直接将模式串后移两位，而字符串不动，继续递归处理<br>	- 如果匹配多个字符，则模式串不动，字符串后移一位继续递归匹配<br>```C++<br><span class="hljs-keyword">class</span> Solution &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">isMatch</span>(string s, string p) &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMatch</span>(s, p, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">isMatch</span>(<span class="hljs-type">const</span> string&amp; str,<span class="hljs-type">const</span> string&amp; ptn, <span class="hljs-type">int</span> s_index, <span class="hljs-type">int</span> p_index) &#123;<br><br>        <span class="hljs-keyword">if</span> (ptn[p_index] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br><br>            <span class="hljs-comment">// 当模式串匹配结束的时候，去查看待匹配的串时候结束</span><br><br>            <span class="hljs-keyword">return</span> str[s_index] == <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        &#125;<br><br>        <span class="hljs-comment">//对于当前元素进行位匹配</span><br><br>        <span class="hljs-type">bool</span> currentMatch = (str[s_index] != <span class="hljs-string">&#x27;\0&#x27;</span>) &amp;&amp; (str[s_index] == ptn[p_index] || ptn[p_index] == <span class="hljs-string">&#x27;.&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (ptn[p_index + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; ptn[p_index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br><br>            <span class="hljs-built_in">return</span> (currentMatch &amp;&amp; <span class="hljs-built_in">isMatch</span>(str, ptn, s_index + <span class="hljs-number">1</span>, p_index)) || <span class="hljs-built_in">isMatch</span>(str, ptn, s_index, p_index + <span class="hljs-number">2</span>); <span class="hljs-comment">// 是 * </span><br><br>        &#125;<br><br>        <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-built_in">return</span> (currentMatch &amp;&amp; <span class="hljs-built_in">isMatch</span>(str, ptn, s_index + <span class="hljs-number">1</span>, p_index + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 不是 *</span><br><br>        &#125;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h1><p><strong>解题思路</strong> ：关键是分清楚题中合法字符串的规律</p>
<ul>
<li>分类讨论，最多三部分组成 $A[.[B]][e|E \ C]$ </li>
<li>A、C是有符号整数</li>
<li>B如果存在，一定是无符号整数</li>
<li>利用一个ScanUnsignedInteger函数判断从当前index开始是否存在无符号整数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 分类讨论，最多三部分组成 A[.[B]][e|E C]</span><br><br>        <span class="hljs-comment">// 只需要判断是否是合法的数值类型</span><br><br>        <span class="hljs-comment">// 有以下几种情况</span><br><br>        <span class="hljs-comment">// 1. 整数，即只有A的部分，A可以是正数，也可以是负数</span><br><br>        <span class="hljs-comment">// 2. A可以存在也可以不存在，有小数点和B，只有B必须是非负数</span><br><br>        <span class="hljs-comment">// 3. 一旦存在e或是E，则C一定要存在，C可以是负数，且前面一定也要是数字才行</span><br><br>  <br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> currentIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用该变量存储当前遍历字符串s的位置</span><br><br>  <br><br>        <span class="hljs-comment">// 可能存在若干空格，用一个循环跳过所有的空格</span><br><br>        <span class="hljs-keyword">while</span> (s[currentIndex] == <span class="hljs-string">&#x27; &#x27;</span>) ++currentIndex;<br><br>  <br><br>        <span class="hljs-comment">// 首先判断A是否存在</span><br><br>        <span class="hljs-type">bool</span> isNumeric = <span class="hljs-built_in">ScanInteger</span>(s, currentIndex);<br><br>  <br><br>        <span class="hljs-comment">// 出现小数点，B一定要是数字</span><br><br>        <span class="hljs-keyword">if</span> (s[currentIndex] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br><br>            ++currentIndex;<br><br>            isNumeric = <span class="hljs-built_in">ScanUnsignedInteger</span>(s, currentIndex) || isNumeric; <span class="hljs-comment">// A可以不存在，所以关键在于B</span><br><br>        &#125;<br><br>  <br><br>        <span class="hljs-comment">// 出现e或是E, </span><br><br>        <span class="hljs-keyword">if</span> (s[currentIndex] == <span class="hljs-string">&#x27;e&#x27;</span> || s[currentIndex] == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br><br>            ++currentIndex;<br><br>            isNumeric = isNumeric &amp;&amp; <span class="hljs-built_in">ScanInteger</span>(s, currentIndex); <span class="hljs-comment">// 前后必须存在，利用短路，先判断前面</span><br><br>        &#125;<br><br>  <br><br>        <span class="hljs-comment">// 结尾可能存在多个空格，并且可能不符合，如“12e+5  .4”</span><br><br>        <span class="hljs-keyword">while</span> (s[currentIndex] == <span class="hljs-string">&#x27; &#x27;</span>) ++currentIndex;<br><br>        <span class="hljs-keyword">return</span> isNumeric &amp;&amp; currentIndex == s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//刚好所有的字符串遍历完才行</span><br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ScanUnsignedInteger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span>&amp; currentIndex)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 基于字符串s，和当前的下标，去看是否存在一个或是多个数字</span><br><br>        <span class="hljs-type">int</span> before = currentIndex;<br><br>        <span class="hljs-keyword">while</span> (currentIndex != s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[currentIndex])) ++currentIndex;<br><br>        <span class="hljs-keyword">return</span> before &lt; currentIndex; <span class="hljs-comment">// 只有当存在至少一个数字的时候，才会返回真，否则就是不存在数字</span><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ScanInteger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span>&amp; currentIndex)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (s[currentIndex] == <span class="hljs-string">&#x27;-&#x27;</span> || s[currentIndex] == <span class="hljs-string">&#x27;+&#x27;</span>) ++currentIndex;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ScanUnsignedInteger</span>(s, currentIndex);<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h1><p><strong>解题思路</strong> ：二叉搜索树的中序有序性质。</p>
<ul>
<li>左子树 &lt; 根 &lt; 右子树</li>
<li>如果采用左根右的遍历方式获取的就是 <strong>递增序列</strong> </li>
<li>采用 <strong>右根左</strong> 的遍历方式，获取的就是 <strong>递减序列</strong> <ul>
<li>递减序列的第k个元素就是我们想要的第k大的结点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 二叉搜索树的中序遍历序列是有序序列</span><br><br>        <span class="hljs-comment">// 调整中序遍历，右根左，则遍历到第k个顶点就是结果</span><br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">Inorder</span>(root, k, result);<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Inorder</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span>&amp; k, <span class="hljs-type">int</span>&amp; result)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>  <br><br>        <span class="hljs-keyword">if</span> (root-&gt;right) <span class="hljs-built_in">Inorder</span>(root-&gt;right, k, result);<br><br>        <span class="hljs-keyword">if</span> (--k == <span class="hljs-number">0</span>) result = root-&gt;val; <span class="hljs-comment">// k 用于计数当前根节点是第k大的，当k等于0的时候就是目标元素</span><br><br>        <span class="hljs-keyword">if</span> (root-&gt;left) <span class="hljs-built_in">Inorder</span>(root-&gt;left, k, result);<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/algorithem/">#algorithem</a>
      
        <a href="/tags/%E5%89%91%E6%8C%87offer/">#剑指offer</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>剑指offer</div>
      <div>http://example.com/2023/01/08/剑指offer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>V. Louis</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 8, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/21/C-Programming-Languge/" title="C++ Programming Languge">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++ Programming Languge</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/08/Merriam-Webster-Vocabulary-Builder/" title="Merriam-Webster-Vocabulary-Builder">
                        <span class="hidden-mobile">Merriam-Webster-Vocabulary-Builder</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
